[{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/e2e/example.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/eslint-plugin-custom-rules/index.js","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":2,"column":33,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":2,"endColumn":75,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/playwright.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/setupTests.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":35,"column":35,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":35,"endColumn":45,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1293,1303],"text":"(store[key] != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1293,1303],"text":"(store[key] ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1293,1303],"text":"(Boolean(store[key]))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":40,"column":33,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":40,"endColumn":58,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1618,1643],"text":"(Object.keys(store)[index] != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1618,1643],"text":"(Object.keys(store)[index] ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1618,1643],"text":"(Boolean(Object.keys(store)[index]))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { vi, beforeAll } from 'vitest';\nimport { test } from '@playwright/test';\nimport type { GamePhrase, ActivityType } from './src/types/Types';\n\ndeclare global {\n  interface Window {\n    setNextTutorial: (tutorial: GamePhrase | null) => void;\n    setActivity: (activity: ActivityType) => void;\n    ActivityType: typeof ActivityType;\n  }\n}\n\n// Initialize localStorage before any tests run\nbeforeAll(() => {\n  if (typeof window.localStorage === 'undefined') {\n    const store: Record<string, string | undefined> = {};\n    window.localStorage = {\n      getItem: (key: string) => store[key] ?? null,\n      setItem: (key: string, value: string) => { store[key] = value; },\n      removeItem: (key: string) => { store[key] = undefined; },\n      clear: () => { Object.keys(store).forEach(key => { store[key] = undefined; }); },\n      length: Object.keys(store).length,\n      key: (index: number) => Object.keys(store)[index] ?? null\n    };\n  }\n});\n\n// Initialize localStorage and window methods for all tests\ntest.beforeEach(async ({ context }) => {\n  await context.addInitScript(() => {\n    // Initialize localStorage\n    if (typeof window.localStorage === 'undefined') {\n      const store: Record<string, string | undefined> = {};\n      window.localStorage = {\n        getItem: (key: string) => store[key] || null,\n        setItem: (key: string, value: string) => { store[key] = value; },\n        removeItem: (key: string) => { store[key] = undefined; },\n        clear: () => { Object.keys(store).forEach(key => { store[key] = undefined; }); },\n        length: Object.keys(store).length,\n        key: (index: number) => Object.keys(store)[index] || null\n      };\n    }\n\n    // Initialize tutorial state\n    window.localStorage.setItem('tutorial-state', JSON.stringify({ currentStep: 0 }));\n\n    // Initialize window methods\n    if (typeof window.setActivity === 'undefined') {\n      window.setActivity = vi.fn();\n    }\n    if (typeof window.setNextTutorial === 'undefined') {\n      window.setNextTutorial = vi.fn();\n    }\n  });\n});\n\n// Suppress console warnings by mocking console methods\nvi.spyOn(console, 'warn').mockImplementation(() => {});\nvi.spyOn(console, 'error').mockImplementation(() => {});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/App.tsx","messages":[{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":47,"column":7,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":61,"endColumn":8},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":56,"column":13,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":58,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useRef, useState } from 'react';\n\nimport { useComputed } from '@preact/signals-react';\n\nimport { HandTermWrapper, type IHandTermWrapperMethods } from './components/HandTermWrapper';\nimport { Output } from './components/Output';\nimport { ActivityMediatorProvider } from './contexts/ActivityMediatorContext';\nimport { AppProvider } from './contexts/AppContext';\nimport { CommandProvider } from './contexts/CommandProvider';\nimport { useAuth } from './hooks/useAuth';\nimport { bypassTutorialSignal } from './signals/appSignals';\nimport { TerminalCssClasses } from './types/TerminalTypes';\nimport { ActivityType } from './types/Types';\nimport { parseLocation } from './utils/navigationUtils';\n\nexport function App(): JSX.Element {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [containerWidth, setContainerWidth] = useState<number>(0);\n\n  const auth = useAuth();\n  const handexTermWrapperRef = useRef<IHandTermWrapperMethods>(null);\n  const isBypassActive = useComputed(() => bypassTutorialSignal.value);\n\n  const getContainerWidth = useCallback(() => {\n    return containerRef.current?.clientWidth ?? 0\n  }, [containerRef]);\n\n  useEffect(() => {\n    const handleResize = () => {\n      const w = getContainerWidth();\n      setContainerWidth(w);\n    };\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, [getContainerWidth]);\n\n  useEffect(() => {\n    const w = getContainerWidth();\n    setContainerWidth(w);\n\n    const handleOutsideTerminalClick = (event: MouseEvent | TouchEvent) => {\n      const currentRef = handexTermWrapperRef.current;\n      if (currentRef === null) return;\n\n      // Check if the click is outside of the terminal area\n      if ((event.target as HTMLElement).id !== TerminalCssClasses.Terminal) {\n        event.stopPropagation();\n        currentRef.focusTerminal();\n\n        if (\n          event instanceof MouseEvent ||\n          (event instanceof TouchEvent && event.touches.length === 1)\n        ) {\n          setTimeout(() => {\n            if (handexTermWrapperRef.current !== null) {\n              handexTermWrapperRef.current.focusTerminal();\n            }\n          }, 1000);\n        }\n      }\n    };\n\n    // Attach the event listener to the document body\n    document.body.addEventListener('click', handleOutsideTerminalClick);\n    document.body.addEventListener('touchstart', handleOutsideTerminalClick);\n\n    // Clean up the event listener\n    return () => {\n      document.body.removeEventListener('click', handleOutsideTerminalClick);\n      document.body.removeEventListener('touchstart', handleOutsideTerminalClick);\n    };\n  }, [getContainerWidth]);\n\n  return (\n    <ActivityMediatorProvider>\n      <div className='app' ref={containerRef}>\n        <AppProvider>\n          <CommandProvider\n            auth={auth}\n            handTermRef={handexTermWrapperRef}\n          >\n            {parseLocation().activityKey !== ActivityType.EDIT\n              && <Output />\n            }\n            {isBypassActive.value && (\n              <div style={{ position: 'fixed', top: 0, right: 0, color: 'black', background: '#222', padding: '5px' }}>\n                Bypass Mode Active\n              </div>\n            )}\n            <HandTermWrapper\n              ref={handexTermWrapperRef}\n              auth={auth}\n              terminalWidth={containerWidth}\n              onOutputUpdate={() => {}}\n            />\n          </CommandProvider>\n        </AppProvider>\n      </div>\n    </ActivityMediatorProvider>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/Persistence.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__mocks__/@octokit/app.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__mocks__/@octokit/core.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__mocks__/@octokit/rest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__mocks__/@preact/signals-react.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__mocks__/canvasMock.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__mocks__/signals/appSignals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__mocks__/signals/commandLineSignals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__mocks__/signals/tutorialSignals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__tests__/activitySwitching.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__tests__/basic.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__tests__/hooks/useActivityMediator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__tests__/useActivityMediator.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/allChords.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/BypassCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/GitHubCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/HelpCommand.tsx","messages":[{"ruleId":"import/no-named-as-default-member","severity":1,"message":"Caution: `ReactDOMServer` also has a named export `renderToStaticMarkup`. Check if you meant to write `import {renderToStaticMarkup} from 'react-dom/server'` instead.","line":31,"column":9,"nodeType":"MemberExpression","endLine":31,"endColumn":44}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import ReactDOMServer from 'react-dom/server';\n\nimport { Chord } from '../components/Chord';\nimport { commandRegistry } from './commandRegistry';\nimport { type ICommand, type ICommandResponse, type ICommandContext } from '../contexts/CommandContext';\nimport { type ParsedCommand } from '../types/Types';\n\nexport const HelpCommand: ICommand = {\n  name: 'help',\n  description: 'Display help information',\n  execute: (\n    context: ICommandContext,\n    parsedCommand: ParsedCommand,\n  ): Promise<ICommandResponse> => {\n    if (\n      parsedCommand.command === 'help'\n      || parsedCommand.command === '411'\n    ) {\n      const commandChords = [\n        'DELETE (Backspace)',\n        'Return (ENTER)',\n        'UpArrow',\n        'LeftArrow',\n        'DownArrow',\n        'RightArrow',\n        'ESCAPE',\n      ].map(c => (\n        <Chord key={c} displayChar={c} />\n      ));\n      const commandChordsHtml = commandChords.map(element => (\n        ReactDOMServer.renderToStaticMarkup(element)\n      )).join('');\n      const commandList = commandRegistry.getHelp();\n      const response = `\n        <div class='chord-display-container'>${commandChordsHtml}</div>\n        <div class='command-list-container'>\n          <h3>Available Commands:</h3>\n          <pre>${commandList}</pre>\n        </div>\n      `;\n      return Promise.resolve<ICommandResponse>({ status: 200, message: response });\n    }\n    return Promise.resolve<ICommandResponse>({ status: 404, message: \"Help command not recognized\" });\n  }\n};","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/ListPhrasesCommand.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/LoginCommand.ts","messages":[{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":29,"column":13,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":31,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/commands/LoginCommand.ts\n\nimport { isInLoginProcessSignal, tempUserNameSignal, setTempUserName, setIsInLoginProcess } from 'src/signals/appSignals';\n\nimport { type ICommand, type ICommandContext, type ICommandResponse } from '../contexts/CommandContext';\nimport { type ParsedCommand } from '../types/Types';\nimport { createLogger } from '../utils/Logger';\n\nconst logger = createLogger();\n\ninterface LoginErrorResponse {\n    status: number;\n    message: string;\n}\n\nexport const LoginCommand: ICommand = {\n    name: 'login',\n    description: 'Log in to the system',\n    execute: async (context: ICommandContext, parsedCommand: ParsedCommand): Promise<ICommandResponse> => {\n        const { auth } = context;\n\n        if (parsedCommand.args.length === 1) {\n            // Start login process\n            setIsInLoginProcess(true);\n            const username = parsedCommand.args[0];\n            setTempUserName(username);\n\n            // Demonstrate usage of tempUserNameSignal\n            if (tempUserNameSignal.value !== username) {\n                logger.error('Username mismatch');\n            }\n\n            return { status: 200, message: 'Enter password:' };\n        } else if (parsedCommand.args.length === 2 && isInLoginProcessSignal.value) {\n            // Complete login process\n            const tempUsername = parsedCommand.args[0];\n            const password = parsedCommand.args[1];\n\n            try {\n                const result = await auth.login(tempUsername, password);\n                setIsInLoginProcess(false);\n\n                return {\n                    status: result.status,\n                    message: result.status === 200 ? 'Login successful!' : `Login failed: ${result.message}`,\n                    sensitive: true // Mark as sensitive to mask password\n                };\n            } catch (error) {\n                setIsInLoginProcess(false);\n\n                // Type narrowing for error\n                const errorResponse: LoginErrorResponse =\n                    error instanceof Error\n                    ? { status: 500, message: error.message }\n                    : { status: 500, message: 'An unknown error occurred' };\n\n                return {\n                    status: errorResponse.status,\n                    message: `Login error: ${errorResponse.message}`,\n                    sensitive: true // Mark as sensitive to mask password\n                };\n            }\n        } else {\n            return { status: 400, message: 'Usage: login <username>' };\n        }\n    }\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/SignUpCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/SpecialCommand.tsx","messages":[{"ruleId":"import/no-named-as-default-member","severity":1,"message":"Caution: `ReactDOMServer` also has a named export `renderToStaticMarkup`. Check if you meant to write `import {renderToStaticMarkup} from 'react-dom/server'` instead.","line":20,"column":7,"nodeType":"MemberExpression","endLine":20,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import ReactDOMServer from 'react-dom/server';\n\nimport { Chord } from '../components/Chord';\nimport { type ICommand, type ICommandContext, type ICommandResponse } from '../contexts/CommandContext';\nimport { type ParsedCommand } from '../types/Types';\n\nexport const SpecialCommand: ICommand = {\n  name: 'special',\n  description: 'Display special characters',\n  execute: async (\n    _context: ICommandContext,\n    _parsedCommand: ParsedCommand,\n  ): Promise<ICommandResponse> => {\n    await Promise.resolve();\n    const specialChars = ['~', '`', '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '-', '_', '+', '=', '{', '[', '}', ']', '|', '\\\\', ':', ';', '\"', \"'\", '<', '>', ',', '.', '?', '/'];\n    const chordElements = specialChars.map(char => (\n      <Chord key={char} displayChar={char} />\n    ));\n    const chordsHtml = chordElements.map(element =>\n      ReactDOMServer.renderToStaticMarkup(element)\n    ).join('');\n\n    return {\n      status: 200,\n      message: `<div class='chord-display-container'>${chordsHtml}</div>`\n    };\n  }\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/__tests__/LoginCommand.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/archiveCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/cleanCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/clearCommand.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":33,"column":10,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":33,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1078,1096],"text":"(handTerm?.current) == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":64,"column":9,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":64,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/commands/clearCommand.tsx\nimport { type IHandTermWrapperMethods } from \"../components/HandTermWrapper\";\nimport { type ICommand, type ICommandContext, type ICommandResponse } from '../contexts/CommandContext';\nimport { LogKeys } from '../types/TerminalTypes';\nimport { type ParsedCommand, type OutputElement } from '../types/Types';\n\ninterface HandTermState {\n  commandHistory?: unknown[];\n  outputElements?: unknown[];\n}\n\ninterface HandTermInstance extends IHandTermWrapperMethods {\n  setState: (state: Partial<HandTermState>) => void;\n  terminalReset: () => void;\n  prompt: () => void;\n}\n\n// Extend ICommandContext to include handTerm\ninterface ExtendedCommandContext extends ICommandContext {\n  handTerm?: React.RefObject<HandTermInstance>;\n  appendToOutput: (output: OutputElement) => void;\n}\n\nexport const clearCommand: ICommand = {\n  name: 'clear',\n  description: 'Clear the command history',\n  execute: async (\n    context: ExtendedCommandContext,\n    parsedCommand: ParsedCommand\n  ): Promise<ICommandResponse> => {\n    const handTerm = context.handTerm;\n\n    if (!handTerm?.current) {\n      const outputElement: OutputElement = {\n        command: parsedCommand,\n        response: 'No command context available.',\n        status: 404,\n        commandTime: new Date()\n      };\n      context.appendToOutput(outputElement);\n      return { status: 404, message: 'No command context available.' };\n    }\n\n    // Logic to clear the command history from localStorage\n    const removeKeys = Object.keys(localStorage).filter(key => {\n      const matchesDefaultKeys = key.includes(LogKeys.Command ?? '') ||\n        key.includes('terminalCommandHistory') ||\n        key.includes(LogKeys.CharTime ?? '');\n\n      const matchesArg = parsedCommand.args.length > 0 &&\n        key.includes(parsedCommand.args[0] ?? '');\n\n      return matchesDefaultKeys ?? matchesArg;\n    });\n\n    await Promise.all(removeKeys.map(async (removeKey) => {\n      await new Promise<void>((resolve) => {\n        localStorage.removeItem(removeKey); // Clear localStorage.length\n        resolve();\n      });\n    }));\n\n    const handTermInstance = handTerm.current;\n    if (handTermInstance) {\n      handTermInstance.setState({ commandHistory: [] });\n      handTermInstance.setState({ outputElements: [] });\n      handTermInstance.terminalReset();\n      handTermInstance.prompt();\n    }\n\n    const outputElement: OutputElement = {\n      command: parsedCommand,\n      response: 'Command history cleared.',\n      status: 200,\n      commandTime: new Date()\n    };\n    context.appendToOutput(outputElement);\n\n    return { status: 200, message: 'Command history cleared.' };\n  }\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/commandRegistry.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":20,"column":29,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":20,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[529,536],"text":"(filter == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[530,536],"text":"(filter ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[529,536],"text":"(!Boolean(filter))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/commands/commandRegistry.ts\n\nimport { type ICommand } from '../contexts/CommandContext';\n\nexport type ICommandRegistryItems = Record<string, ICommand>;\n\nclass CommandRegistry {\n    private commands: ICommandRegistryItems = {};\n\n    register(command: ICommand) {\n        this.commands[command.name] = command;\n    }\n\n    getCommand(name: string): ICommand | undefined {\n        return this.commands[name];\n    }\n\n    getHelp(filter?: string): string {\n        return Object.values(this.commands)\n            .filter(cmd => !filter || cmd.name.includes(filter))\n            .map(cmd => `${cmd.name}: ${cmd.description}`)\n            .join('\\n\\n');\n    }\n\n}\n\nexport const commandRegistry = new CommandRegistry();\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/editCommand.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/index.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":31,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":31,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[906,927],"text":"(commandModule.default != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/commands/index.ts\nimport { type ICommand } from '../contexts/CommandContext';\n\nimport { commandRegistry } from './commandRegistry';\n\n// Interface for command modules\ninterface CommandModule {\n  default?: ICommand;\n  [key: string]: ICommand | undefined;\n}\n\n// Type guard to check if a value is a valid command\nfunction isValidCommand(command: unknown): command is ICommand {\n  return (\n    typeof command === 'object' &&\n    command !== null &&\n    'name' in command &&\n    'execute' in command &&\n    typeof (command as ICommand).name === 'string' &&\n    typeof (command as ICommand).execute === 'function'\n  );\n}\n\n// Dynamically import and register all command files\nconst commandModules = import.meta.glob('./*Command.ts*', { eager: true });\n\nObject.entries(commandModules).forEach(([_path, module]) => {\n  const commandModule = module as CommandModule;\n\n  // Check for default export first\n  if (commandModule.default && isValidCommand(commandModule.default)) {\n    commandRegistry.register(commandModule.default);\n    return;\n  }\n\n  // If no default, check other exports\n  const commands = Object.values(commandModule).filter(isValidCommand);\n  commands.forEach(command => {\n    commandRegistry.register(command);\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/toggleVideoCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/wrtCommand.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":54,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":54,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1765,1773],"text":"(fileName != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1765,1773],"text":"(fileName ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1765,1773],"text":"(Boolean(fileName))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":54,"column":25,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":54,"endColumn":45,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1777,1797],"text":"(context.auth.getFile != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":57,"column":44,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":57,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1934,1947],"text":"(response.data != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1934,1947],"text":"(response.data ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1934,1947],"text":"(Boolean(response.data))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":69,"column":18,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":69,"endColumn":34},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":71,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":71,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2622,2630],"text":"(fileName != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2622,2630],"text":"(fileName ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2622,2630],"text":"(Boolean(fileName))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":71,"column":25,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":71,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2634,2653],"text":"(context.setEditMode != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":71,"column":48,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":71,"endColumn":96,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2657,2705],"text":"((context.activityMediator?.determineActivityState) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":77,"column":18,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":77,"endColumn":34},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":79,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":79,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3070,3078],"text":"(fileName != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3070,3078],"text":"(fileName ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3070,3078],"text":"(Boolean(fileName))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":79,"column":25,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":79,"endColumn":45,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3082,3102],"text":"(context.auth.getFile != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":79,"column":49,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":79,"endColumn":71,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3106,3128],"text":"(context.handleEditSave != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":82,"column":44,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":82,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3265,3278],"text":"(response.data != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3265,3278],"text":"(response.data ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3265,3278],"text":"(Boolean(response.data))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type React from 'react';\n\nimport { type ICommand, type ICommandResponse, type ICommandContext } from '../contexts/CommandContext';\nimport { type IAuthProps } from '../hooks/useAuth';\nimport { ActivityType, type OutputElement, type ParsedCommand } from '../types/Types';\nimport { isNotNullOrUndefined } from '../utils/typeSafetyUtils';\n\n// Extend the command context with optional methods\ninterface ExtendedCommandContext extends ICommandContext {\n  auth: IAuthProps & {\n    getFile?: (fileName: string, format: string) => Promise<{\n      status: number;\n      data?: string;\n      message?: string;\n    }>;\n  };\n  setEditMode?: (mode: boolean) => void;\n  activityMediator?: {\n    determineActivityState?: (activity: ActivityType) => void;\n  };\n  handleEditSave?: (content: string) => void;\n}\n\nexport const wrtCommand: ICommand = {\n  name: 'wrt',\n  description: 'Write to the terminal',\n  switches: {\n    'file': 'Write the contents of a file to the terminal',\n    'edit': 'Edit the contents of a file',\n    'save': 'Save the contents of a file',\n  },\n  execute: async (\n    context: ExtendedCommandContext,\n    parsedCommand: ParsedCommand\n  ): Promise<ICommandResponse> => {\n    const switches = parsedCommand.switches;\n    const args = parsedCommand.args;\n\n    const getFileName = (switchKey: string): string | null => {\n      const fileName = switches[switchKey];\n      return typeof fileName === 'string' ? fileName : null;\n    };\n\n    const createOutputElement = (message: string | React.ReactNode): OutputElement => ({\n      command: parsedCommand,\n      response: message,\n      status: 200,\n      commandTime: new Date()\n    });\n\n    try {\n      if (isNotNullOrUndefined(switches['file'])) {\n        const fileName = getFileName('file');\n        if (fileName && context.auth.getFile) {\n          try {\n            const response = await context.auth.getFile(fileName, 'txt');\n            if (response.status === 200 && response.data) {\n              context.appendToOutput(createOutputElement(response.data));\n            } else {\n              context.appendToOutput(createOutputElement(`Error reading file: ${fileName}`));\n            }\n          } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n            context.appendToOutput(createOutputElement(`Error reading file: ${errorMessage}`));\n          }\n        } else {\n          context.appendToOutput(createOutputElement('Please provide a file name or file reading is not supported.'));\n        }\n      } else if (switches['edit']) {\n        const fileName = getFileName('edit');\n        if (fileName && context.setEditMode && context.activityMediator?.determineActivityState) {\n          context.setEditMode(true);\n          context.activityMediator.determineActivityState(ActivityType.EDIT);\n        } else {\n          context.appendToOutput(createOutputElement('Please provide a file name to edit or edit mode is not supported.'));\n        }\n      } else if (switches['save']) {\n        const fileName = getFileName('save');\n        if (fileName && context.auth.getFile && context.handleEditSave) {\n          try {\n            const response = await context.auth.getFile(fileName, 'txt');\n            if (response.status === 200 && response.data) {\n              context.handleEditSave(response.data);\n            } else {\n              context.appendToOutput(createOutputElement(`Error reading file: ${fileName}`));\n            }\n          } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n            context.appendToOutput(createOutputElement(`Error reading file: ${errorMessage}`));\n          }\n        } else {\n          context.appendToOutput(createOutputElement('Please provide a file name to save or save functionality is not supported.'));\n        }\n      } else if (args.length > 0) {\n        // Write the provided arguments to the terminal\n        context.appendToOutput(createOutputElement(args.join(' ')));\n      } else {\n        return { status: 400, message: 'Please provide text to write or use a switch.' };\n      }\n\n      return { status: 200, message: 'Command executed successfully.' };\n    } catch (error) {\n      return {\n        status: 500,\n        message: error instanceof Error ? error.message : 'An unexpected error occurred'\n      };\n    }\n  }\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/Chord.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/CommandOutput.tsx","messages":[{"ruleId":"import/no-named-as-default","severity":1,"message":"Using exported name 'WpmTable' as identifier for default import.","line":11,"column":8,"nodeType":"ImportDefaultSpecifier","endLine":11,"endColumn":16},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":52,"column":14,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":52,"endColumn":18},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":52,"column":22,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":52,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/components/CommandOutput.tsx\n\nimport {type ReactNode} from 'react';\nimport type React from 'react';\n\nimport { parsedCommandToString } from 'src/utils/commandUtils';\n\nimport { type ParsedCommand, type WPMs } from '../types/Types';\n\nimport { TimeDisplay } from './TimeDisplay';\nimport WpmTable from './WpmTable';\n\ninterface CommandOutputProps {\n    command: ParsedCommand;\n    response: ReactNode;\n    status: number;\n    wpms: WPMs;\n    commandTime: Date;\n}\n\nexport const CommandOutput: React.FC<CommandOutputProps> = ({\n    command,\n    response,\n    status,\n    wpms,\n    commandTime\n}) => {\n    // Function to check if a string contains HTML tags\n    const containsHTML = (str: string) => {\n        return typeof str === 'string' && /<[a-z][\\s\\S]*>/i.test(str);\n    };\n\n    // Render response based on its type and content\n    const renderResponse = () => {\n        if (typeof response === 'string' && containsHTML(response)) {\n            return <div className=\"response\" dangerouslySetInnerHTML={{ __html: response }} />;\n        }\n        return <div className=\"response\">{response}</div>;\n    };\n\n    return (\n        <div data-status={status}>\n            <div className=\"log-line\">\n                <span className=\"log-time\">\n                    <TimeDisplay time={commandTime} />\n                </span>\n                <span className=\"wpm-label\">WPM:</span>\n                <span className=\"wpm\">{(wpms.wpmAverage ?? 0).toFixed(0)}</span>\n                <span className=\"content\">{parsedCommandToString(command)}</span>\n            </div>\n            {renderResponse()}\n            {wpms && wpms.charWpms && wpms.charWpms.length > 0 && (\n                <WpmTable wpms={wpms.charWpms} name=\"slow-char\" />\n            )}\n        </div>\n    );\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/ErrorDisplay.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":28,"column":8,"nodeType":"Identifier","messageId":"conditionErrorString","endLine":28,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[683,697],"text":"(mismatchedChar.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[683,697],"text":"(mismatchedChar !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[683,697],"text":"(Boolean(mismatchedChar))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useImperativeHandle, forwardRef } from 'react';\n\nimport { Chord } from './Chord';\n\ninterface ErrorDisplayProps {\n  mismatchedChar: string;\n  isVisible: boolean;\n}\n\nconst ErrorDisplay = forwardRef((props: ErrorDisplayProps, ref) => {\n  const [errorCount, setErrorCount] = useState(0);\n  const { mismatchedChar } = props;\n\n\n  const showError = () => {\n    setErrorCount(prevCount => prevCount + 1);\n  };\n\n\n  // Use useImperativeHandle to expose functions to the parent component\n  useImperativeHandle(ref, () => ({\n    showError,\n  }));\n\n  return (\n    <div style={{ display: props.isVisible ? 'block' : 'none' }} >\n      <div>Error Count: {errorCount}</div>\n      {mismatchedChar &&\n        <Chord displayChar={mismatchedChar} />\n      }\n    </div>\n  );\n});\n\nErrorDisplay.displayName = 'ErrorDisplay';\n\nexport default ErrorDisplay;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/HandTermWrapper.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has an unnecessary dependency: 'tutorialSignal.value'. Either exclude it or remove the dependency array. Outer scope values like 'tutorialSignal.value' aren't valid dependencies because mutating them doesn't re-render the component.","line":145,"column":6,"nodeType":"ArrayExpression","endLine":145,"endColumn":45,"suggestions":[{"desc":"Update the dependencies array to be: [currentActivity]","fix":{"range":[5431,5470],"text":"[currentActivity]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { forwardRef, useCallback, useEffect, useImperativeHandle, useRef, useState } from 'react';\n\nimport { useComputed } from '@preact/signals-react';\n\nimport { Game, type IGameHandle } from '../game/Game';\nimport { useActivityMediator } from '../hooks/useActivityMediator';\nimport { type IAuthProps } from '../hooks/useAuth';\nimport { useTerminal } from '../hooks/useTerminal';\nimport { useWPMCalculator } from '../hooks/useWPMCaculator';\nimport { activitySignal, isShowVideoSignal } from '../signals/appSignals';\nimport { commandTimeSignal } from '../signals/commandLineSignals';\nimport { setGamePhrase } from '../signals/gameSignals';\nimport { tutorialSignal } from '../signals/tutorialSignals';\nimport { ActivityType, type GamePhrase, type OutputElement } from '../types/Types';\nimport { getFileContent } from '../utils/apiClient';\nimport { createLogger, LogLevel } from '../utils/Logger';\nimport { navigate, parseLocation } from '../utils/navigationUtils';\nimport WebCam from '../utils/WebCam';\n\nimport { Chord } from './Chord';\nimport { MonacoEditor } from './MonacoEditor';\nimport NextCharsDisplay, { type NextCharsDisplayHandle } from './NextCharsDisplay';\nimport { Prompt } from './Prompt';\nimport { TutorialManager } from './TutorialManager';\n\nconst logger = createLogger({\n  prefix: 'HandTermWrapper',\n  level: LogLevel.DEBUG\n});\n\ninterface TreeItem {\n  path: string;\n  type: 'file' | 'directory';\n}\n\ninterface IHandTermWrapperProps {\n  terminalWidth: number;\n  auth: IAuthProps;\n  onOutputUpdate: (output: OutputElement) => void;\n}\n\ninterface XtermMethods {\n  focusTerminal: () => void;\n  terminalWrite: (data: string) => void;\n  getCurrentCommand: () => string;\n  getTerminalSize: () => { width: number; height: number } | undefined;\n  prompt: () => void;\n  scrollBottom: () => void;\n}\n\ninterface IHandTermWrapperMethods {\n  writeOutput: (output: string) => void;\n  prompt: () => void;\n  saveCommandResponseHistory: (command: string, response: string, status: number) => string;\n  focusTerminal: () => void;\n  handleCharacter: (character: string) => void;\n  refreshComponent: () => void;\n  setHeroSummersaultAction: () => void;\n  setEditMode: (isEditMode: boolean) => void;\n  handleEditSave: (content: string) => void;\n}\n\nconst getTimestamp = (date: Date): string => date.toTimeString().split(' ')[0] ?? '';\n\nconst HandTermWrapper = forwardRef<IHandTermWrapperMethods, IHandTermWrapperProps>((props, forwardedRef) => {\n  const { xtermRef, writeToTerminal, resetPrompt } = useTerminal();\n  const targetWPM = 10;\n  const wpmCalculator = useWPMCalculator();\n  const gameHandleRef = useRef<IGameHandle>(null);\n  const nextCharsDisplayRef = useRef<NextCharsDisplayHandle>(null);\n  const activityMediator = useActivityMediator();\n\n  const [domain] = useState('handterm.com');\n  const initialCanvasHeight = localStorage.getItem('canvasHeight')?.trim() ?? '100';\n  const [canvasHeight] = useState<number>(() => parseInt(initialCanvasHeight, 10));\n  const [lastTypedCharacter] = useState<string | null>(null);\n  const [, setErrorCharIndex] = useState<number | undefined>(undefined);\n  const [githubUsername] = useState<string | null>(null);\n  const [userName] = useState<string | null>(null);\n  const commandTime = useComputed(() => commandTimeSignal.value);\n  const [treeItems, setTreeItems] = useState<TreeItem[]>([]);\n  const [, setCurrentFile] = useState<string | null>(null);\n\n  const [currentActivity, setCurrentActivity] = useState(parseLocation().activityKey);\n\n  // Update activity state when activitySignal changes\n  useEffect(() => {\n    const updateActivity = () => {\n      logger.debug('Activity signal changed:', {\n        from: ActivityType[currentActivity],\n        to: ActivityType[activitySignal.value],\n        tutorialState: tutorialSignal.value,\n        isTutorialComplete: tutorialSignal.value === null\n      });\n      setCurrentActivity(activitySignal.value);\n\n      // Log when transitioning from TUTORIAL to GAME\n      if (currentActivity === ActivityType.TUTORIAL && activitySignal.value === ActivityType.GAME) {\n        logger.debug('Transitioning from TUTORIAL to GAME', {\n          tutorialSignal: tutorialSignal.value,\n          activitySignal: activitySignal.value\n        });\n      }\n    };\n\n    // Initial sync\n    updateActivity();\n\n    // Subscribe to signal changes\n    const unsubscribe = activitySignal.subscribe(updateActivity);\n\n    return () => {\n      unsubscribe();\n    };\n  }, [currentActivity]);\n\n  useEffect(() => {\n    logger.debug('Current activity:', {\n      activity: ActivityType[currentActivity],\n      tutorialState: tutorialSignal.value,\n      isTutorialComplete: tutorialSignal.value === null\n    });\n  }, [currentActivity]);\n\n  useEffect(() => {\n    logger.debug('Tutorial signal:', {\n      current: tutorialSignal.value,\n      completed: localStorage.getItem('completed-tutorials'),\n      state: localStorage.getItem('tutorial-state')\n    });\n\n    // When tutorial signal changes to null, check if we should transition to GAME\n    if (tutorialSignal.value === null) {\n      logger.debug('Tutorial completed, checking for game transition', {\n        currentActivity,\n        activitySignal: activitySignal.value\n      });\n\n      // Only transition if we're currently in TUTORIAL mode\n      if (currentActivity === ActivityType.TUTORIAL) {\n        logger.debug('Transitioning from TUTORIAL to GAME');\n        activitySignal.value = ActivityType.GAME;\n      }\n    }\n  }, [tutorialSignal.value, currentActivity]);\n\n  // Declare handlePhraseComplete with all its dependencies\n  const handlePhraseComplete = useCallback(() => {\n    localStorage.setItem('currentCommand', '');\n    setGamePhrase(null);\n    const timer = nextCharsDisplayRef.current?.cancelTimer;\n    if (typeof timer === 'function') {\n      timer();\n    }\n    const game = gameHandleRef.current;\n    if (isGameHandle(game)) {\n      game.completeGame();\n    }\n\n    function isGameHandle(game: IGameHandle | null): game is IGameHandle {\n      return game !== null;\n    }\n    resetPrompt();\n  }, [nextCharsDisplayRef, gameHandleRef, resetPrompt]);\n\n  // Then use it in handlePhraseSuccess\n  const handlePhraseSuccess = useCallback((phrase: GamePhrase | null) => {\n    if (phrase === null) return;\n\n    const key = phrase.key?.trim() ?? '';\n    const value = phrase.value?.trim() ?? '';\n    if (key === '' || value === '') {\n      return;\n    }\n    logger.debug('handlePhraseSuccess called with phrase:', key, 'Activity:', ActivityType[activitySignal.value]);\n    const wpms = wpmCalculator.getWPMs();\n    const wpmAverage = wpms.wpmAverage;\n\n    if (wpmAverage > targetWPM) {\n      activityMediator.checkGameProgress(phrase);\n    }\n\n    const game = gameHandleRef.current;\n    if (isGameHandle(game)) {\n      game.completeGame();\n      game.levelUp();\n    }\n\n    function isGameHandle(game: IGameHandle | null): game is IGameHandle {\n      return game !== null;\n    }\n    handlePhraseComplete();\n  }, [wpmCalculator, activityMediator, handlePhraseComplete, gameHandleRef, targetWPM]);\n\n  // Load tree items when entering tree view mode\n  useEffect(() => {\n    if (currentActivity === ActivityType.TREE) {\n      logger.info('Loading tree items in TREE mode');\n      const storedItems = localStorage.getItem('github_tree_items')?.trim() ?? '';\n      if (storedItems === '') {\n        logger.error('No tree items found in localStorage');\n        return;\n      }\n\n      logger.debug('Stored items:', storedItems);\n      try {\n        const items = JSON.parse(storedItems) as TreeItem[];\n        logger.debug('Parsed items:', items);\n        if (Array.isArray(items) && items.length > 0) {\n          setTreeItems(items);\n        } else {\n          logger.error('Tree items array is empty or invalid');\n        }\n      } catch (error) {\n        logger.error('Error parsing tree items:', error);\n      }\n    }\n  }, [currentActivity]);\n\n  // Reset terminal when returning to normal mode\n  useEffect(() => {\n    if (currentActivity === ActivityType.NORMAL) {\n      logger.info('Resetting terminal in NORMAL mode');\n      const term = xtermRef.current;\n      if (term !== null && typeof term.focus === 'function') {\n        term.focus();\n      }\n      resetPrompt();\n    }\n  }, [currentActivity, xtermRef, resetPrompt]);\n\n  const handleFileSelect = useCallback(async (path: string) => {\n    try {\n      // Get the current repository from localStorage (set by GitHubCommand)\n      const currentRepo = localStorage.getItem('current_github_repo')?.trim() ?? '';\n      if (currentRepo === '') {\n        logger.error('No repository selected');\n        return;\n      }\n\n      logger.info('Fetching file content:', { repo: currentRepo, path });\n      const response = await getFileContent(props.auth, currentRepo, path);\n      logger.debug('File content response:', response);\n\n      if (response !== null && response.status === 200 && response.data !== undefined) {\n        // Store content and file path\n        localStorage.setItem('edit-content', response.data.content);\n        setCurrentFile(path);\n\n        // Update location with file path\n        navigate({\n          activityKey: ActivityType.EDIT,\n          contentKey: `${currentRepo}/${path}`,\n          groupKey: null\n        });\n      } else {\n        logger.error('Failed to fetch file content:', response?.error);\n      }\n    } catch (error) {\n      logger.error('Failed to fetch file content:', error);\n      // Stay in tree view mode on error\n      return;\n    }\n  }, [props.auth]);\n\n  const handleEditorClose = useCallback((): void => {\n    logger.info('Closing editor, returning to NORMAL mode');\n    // Clear stored content and file path\n    localStorage.removeItem('edit-content');\n    setCurrentFile(null);\n    // Return to normal mode\n    navigate({\n      activityKey: ActivityType.NORMAL,\n      contentKey: null,\n      groupKey: null\n    });\n  }, []);\n\n  const handleTreeClose = useCallback((): void => {\n    logger.info('Closing tree view, returning to NORMAL mode');\n    // Clear tree items\n    setTreeItems([]);\n    localStorage.removeItem('github_tree_items');\n    // Return to normal mode\n    navigate({\n      activityKey: ActivityType.NORMAL,\n      contentKey: null,\n      groupKey: null\n    });\n  }, []);\n\n  const handlePhraseErrorState = useCallback((errorIndex: number | undefined) => {\n    setErrorCharIndex(errorIndex);\n  }, []);\n\n  // Initialize component methods\n  useImperativeHandle(forwardedRef, () => ({\n    writeOutput: writeToTerminal,\n    prompt: () => { },\n    saveCommandResponseHistory: () => '',\n    focusTerminal: () => {\n      const term = xtermRef.current;\n      if (term !== null && term !== undefined && typeof term.focus === 'function') {\n        term.focus();\n      }\n    },\n    handleCharacter: () => { },\n    refreshComponent: () => { },\n    setHeroSummersaultAction: () => { },\n    setEditMode: () => { },\n    handleEditSave: () => { },\n  }), [writeToTerminal, xtermRef]);\n\n  // Initialize window methods\n  useEffect(() => {\n    window.setActivity = (activity: ActivityType) => {\n      logger.debug('Setting activity:', ActivityType[activity]);\n      activitySignal.value = activity;\n    };\n    window.setNextTutorial = (tutorial: GamePhrase | null) => {\n      logger.debug('Setting tutorial:', tutorial);\n      tutorialSignal.value = tutorial;\n    };\n    window.ActivityType = ActivityType;\n  }, []);\n\n  const handleFileSelectWrapper = useCallback((path: string) => {\n    void handleFileSelect(path);\n  }, [handleFileSelect]);\n\n  const getStoredContent = useCallback((): string => {\n    const content = localStorage.getItem('edit-content');\n    return content !== null ? content : '';\n  }, []);\n\n  return (\n    <div id='handterm-wrapper'>\n      {currentActivity === ActivityType.GAME && (\n        <Game\n          ref={gameHandleRef}\n          canvasHeight={canvasHeight}\n          canvasWidth={props.terminalWidth}\n        />\n      )}\n      {currentActivity === ActivityType.GAME && (\n        <NextCharsDisplay\n          ref={nextCharsDisplayRef}\n          isInPhraseMode={true}\n          onPhraseSuccess={handlePhraseSuccess}\n          onError={handlePhraseErrorState}\n        />\n      )}\n      {lastTypedCharacter !== null && (\n        <Chord displayChar={lastTypedCharacter} />\n      )}\n      {currentActivity === ActivityType.TUTORIAL && tutorialSignal.value != null && (\n        <TutorialManager\n          tutorial={tutorialSignal.value}\n        />\n      )}\n\n      {/* Always show terminal unless in EDIT or TREE mode */}\n      {currentActivity !== ActivityType.EDIT && currentActivity !== ActivityType.TREE && (\n        <div id=\"prompt-and-terminal\">\n          <Prompt\n            username={userName ?? 'guest'}\n            domain={domain ?? 'handterm.com'}\n            githubUsername={githubUsername}\n            timestamp={getTimestamp(commandTime.value)}\n          />\n          <div\n            ref={xtermRef}\n            id=\"xtermRef\"\n          />\n        </div>\n      )}\n\n      {currentActivity === ActivityType.EDIT && (\n        <MonacoEditor\n          initialValue={getStoredContent()}\n          language=\"markdown\"\n          onClose={handleEditorClose}\n        />\n      )}\n      {currentActivity === ActivityType.TREE && treeItems.length > 0 && (\n        <MonacoEditor\n          initialValue=\"\"\n          language=\"plaintext\"\n          isTreeView={true}\n          treeItems={treeItems}\n          onFileSelect={handleFileSelectWrapper}\n          onClose={handleTreeClose}\n        />\n      )}\n      {isShowVideoSignal.value !== null && (\n        <WebCam\n          setOn={isShowVideoSignal.value}\n        />\n      )}\n    </div>\n  );\n});\n\nHandTermWrapper.displayName = 'HandTermWrapper';\n\nexport type { IHandTermWrapperMethods, IHandTermWrapperProps, XtermMethods };\nexport { HandTermWrapper };\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/MonacoEditor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/Nav.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/NextCharsDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/Output.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/Prompt.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":23,"column":14,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":23,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[746,760],"text":"(githubUsername != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[746,760],"text":"(githubUsername ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[746,760],"text":"(Boolean(githubUsername))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useComputed } from '@preact/signals-react';\nimport type React from 'react';\n\nimport { promptInfoSignal } from 'src/signals/commandLineSignals';\n\nimport { TerminalCssClasses } from \"../types/TerminalTypes\"\n\ninterface PromptProps {\n    domain: string;\n    username: string;\n    timestamp: string;\n    githubUsername: string | null;\n}\n\nexport const Prompt: React.FC<PromptProps> = ({ domain, username, timestamp, githubUsername }) => {\n    const promptInfo = useComputed(() => promptInfoSignal.value);\n\n    return (\n        <pre id={TerminalCssClasses.Prompt}>\n            <span className=\"timestamp\">{timestamp}</span>\n            <span className=\"user\">{username}</span>\n            <span className=\"domain\">@{domain}</span>\n            {githubUsername &&\n                <span className=\"github\">\n                    <i className=\"fa fa-github\" aria-hidden=\"true\"></i>\n                    {githubUsername}\n                </span>\n            }\n            <span>{promptInfo.value}</span>\n        </pre>\n    )\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/SlowestCharactersDisplay.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":18,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":18,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[452,474],"text":"charGroups[character] == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type React from 'react';\n\ntype CharWPM = {\n    character: string;\n    wpm: number;\n    durationMilliseconds: number;\n};\n\ninterface SlowestCharactersDisplayProps {\n    charWpms: CharWPM[];\n}\n\nconst averageWpmByCharacter = (charWpms: CharWPM[]) => {\n    const charGroups: Record<string, { totalWpm: number, count: number }> = {};\n\n    // Sum WPMs for each character and count occurrences\n    charWpms.forEach(({ character, wpm }) => {\n        if (!charGroups[character]) {\n            charGroups[character] = { totalWpm: 0, count: 0 };\n        }\n        charGroups[character].totalWpm += wpm;\n        charGroups[character].count++;\n    });\n\n    // Calculate average WPM for each character\n    return Object.entries(charGroups).map(([character, { totalWpm, count }]) => ({\n        character,\n        wpm: totalWpm / count,\n        durationMilliseconds: 0, // You may want to handle duration aggregation differently\n    }));\n}\n\nexport const SlowestCharactersDisplay: React.FC<SlowestCharactersDisplayProps> = ({ charWpms }) => {\n    // that calculates the average WPM for each character.\n    const characterAverages = averageWpmByCharacter(charWpms.filter(wpm => wpm.durationMilliseconds > 1));\n    const slowestCharacters = characterAverages\n        .sort((a, b) => a.wpm - b.wpm)\n        .slice(0, 3);\n\n    return (\n        <div className=\"slow-chars\">\n            {slowestCharacters.map((char, index) => (\n                <div key={index}>\n                    <span>Character: {char.character}</span>\n                    <span>WPM: {char.wpm.toFixed(2)}</span>\n                </div>\n            ))}\n        </div>\n    );\n};\n\n// If you need to use ReactDOMServer.renderToStaticMarkup in the functional component context,\n// you would typically do it outside the component, wherever you're intending to use the HTML string.\n// For example:\n// const slowestCharactersHtml = ReactDOMServer.renderToStaticMarkup(<SlowestCharactersDisplay charWpms={charWpms} />);","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/TimeDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/Timer.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullish value in conditional. The condition is always false.","line":27,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullish","endLine":27,"endColumn":21},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":31,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":31,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[951,961],"text":"intervalId != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[951,961],"text":"intervalId ?? 0"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[951,961],"text":"Boolean(intervalId)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useImperativeHandle, forwardRef, type ForwardRefRenderFunction } from 'react';\n\nexport interface TimerProps {}\n\nexport interface TimerHandle {\n  start: () => void;\n  stop: () => void;\n  reset: () => number;\n  success: () => void;\n}\n\nconst Timer: ForwardRefRenderFunction<TimerHandle, TimerProps> = (_props, ref) => {\n  const [centiSecond, setCentiSecond] = useState(0);\n  const [isActive, setIsActive] = useState(false);\n  const [svgStatus, setSvgStatus] = useState<'start' | 'stop' | 'pause'>('start');\n\n  useEffect(() => {\n    let intervalId: number | null = null;\n\n    if (isActive) {\n      setSvgStatus('pause');\n      intervalId = window.setInterval(() => {\n        setCentiSecond((prevCentiSecond: number) => prevCentiSecond + 1);\n      }, 10);\n    } else if (!isActive && centiSecond !== 0) {\n      setSvgStatus('start');\n      if (intervalId) clearInterval(intervalId);\n    }\n\n    return () => {\n      if (intervalId) clearInterval(intervalId);\n    };\n  }, [isActive, centiSecond]);\n\n  const start = () => {\n    setIsActive(true);\n  };\n\n  const stop = () => {\n    setIsActive(false);\n  };\n\n  const reset = (): number => {\n    setIsActive(false);\n    const finalCentiSecond = centiSecond;\n    setCentiSecond(0);\n    return finalCentiSecond;\n  };\n\n  const success = () => {\n    setCentiSecond(0);\n    setIsActive(false);\n  };\n\n  useImperativeHandle(ref, () => ({\n    start,\n    stop,\n    reset,\n    success\n  }));\n\n  const renderSvg = () => {\n    switch (svgStatus) {\n      case 'start':\n        return <use href=\"#start\" transform=\"scale(2,2)\" />;\n      case 'stop':\n        return <use href=\"#stop\" transform=\"scale(2,2)\" />;\n      case 'pause':\n        return <use href=\"#pause\" transform=\"scale(2,2)\" />;\n      default:\n        return <use href=\"#stop\" transform=\"scale(2,2)\" />;\n    }\n  };\n\n  return (\n    <React.Fragment>\n      <span id=\"timer\">{(centiSecond / 100).toFixed(1)}</span>\n      <svg width=\"15\" height=\"20\" style={{ float: 'left' }}>\n        {renderSvg()}\n      </svg>\n    </React.Fragment>\n  );\n};\n\nexport default forwardRef(Timer);\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/TutorialManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/WpmTable.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":17,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":17,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[549,559],"text":"acc[char] == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/components/WpmTable.tsx\r\nimport type React from 'react';\r\nimport { useMemo } from 'react';\r\n\r\nimport { type CharWPM } from '../types/TerminalTypes';\r\n\r\ninterface WpmTableProps {\r\n  wpms: ReadonlyArray<CharWPM>;\r\n  name?: string;\r\n}\r\n\r\nexport const WpmTable: React.FC<WpmTableProps> = ({ wpms, name = \"slowest-characters\" }) => {\r\n  const groupedAndSortedWpms = useMemo(() => {\r\n    // Group by character\r\n    const grouped = wpms.reduce((acc, curr) => {\r\n      const char = curr.character.replace(\"\\r\", \"\\\\r\").replace(\" \", \"\\\\s\");\r\n      if (!acc[char]) {\r\n        acc[char] = { character: char, wpm: curr.wpm, count: 1 };\r\n      } else {\r\n        acc[char].wpm += curr.wpm;\r\n        acc[char].count += 1;\r\n      }\r\n      return acc;\r\n    }, {} as Record<string, { character: string, wpm: number, count: number }>);\r\n\r\n    // Calculate average WPM for each character\r\n    const averages = Object.values(grouped).map(item => ({\r\n      character: item.character,\r\n      wpm: item.wpm / item.count\r\n    }));\r\n\r\n    // Sort by slowest (lowest WPM) first\r\n    averages.sort((a, b) => a.wpm - b.wpm);\r\n\r\n    // Take top 5\r\n    return averages.slice(0, 5);\r\n  }, [wpms]);\r\n\r\n  return (\r\n    <table className=\"wpm-table\">\r\n      <thead>\r\n        <tr><th colSpan={2}>{name}</th></tr>\r\n        <tr>\r\n          <th>Character</th>\r\n          <th>Avg WPM</th>\r\n        </tr>\r\n      </thead>\r\n      <tbody>\r\n        {groupedAndSortedWpms.map((wpm, index) => (\r\n          <tr key={index} className=\"wpm-table-row\">\r\n            <td>{wpm.character}</td>\r\n            <td className=\"number\">{wpm.wpm.toFixed(0)}</td>\r\n          </tr>\r\n        ))}\r\n      </tbody>\r\n    </table>\r\n  );\r\n};\r\n\r\nexport default WpmTable;","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/XtermAdapterConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/constants/terminal.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/contexts/ActivityMediatorContext.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":16,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":16,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[572,580],"text":"context == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/contexts/ActivityMediatorContext.tsx\nimport type React from 'react';\nimport { createContext, useContext, useState } from 'react';\n\nimport { ActivityType } from '../types/Types';\n\nexport interface IActivityMediatorContext {\n    currentActivity: ActivityType;\n    setCurrentActivity: React.Dispatch<React.SetStateAction<ActivityType>>;\n}\n\nconst ActivityMediatorContext = createContext<IActivityMediatorContext | null>(null);\n\nexport const useActivityMediatorContext = (): IActivityMediatorContext => {\n    const context = useContext(ActivityMediatorContext);\n    if (!context) {\n        throw new Error('useActivityMediatorContext must be used within an ActivityMediatorProvider');\n    }\n    return context;\n};\n\nexport const ActivityMediatorProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n\n    const [currentActivity, setCurrentActivity] = useState<ActivityType>(ActivityType.NORMAL);\n\n    const value: IActivityMediatorContext = {\n        currentActivity,\n        setCurrentActivity\n    };\n\n    return (\n        <ActivityMediatorContext.Provider value={value}>\n            {children}\n        </ActivityMediatorContext.Provider>\n    );\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/contexts/AppContext.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":22,"column":8,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":22,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[682,690],"text":"context == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/contexts/AppContext.tsx\nimport type React from 'react';\nimport { createContext, useContext, useState } from 'react';\n\nimport { type ActivityType, type OutputElement } from '../types/Types';\n\nimport { useActivityMediatorContext } from './ActivityMediatorContext';\n\ninterface AppContextType {\n  currentActivity: ActivityType;\n  isLoggedIn: boolean;\n  setIsLoggedIn: (isLoggedIn: boolean) => void;\n  userName: string | null;\n  setUserName: (userName: string | null) => void;\n  outputElements: OutputElement[];\n}\n\nconst AppContext = createContext<AppContextType | null>(null);\n\nexport const useAppContext = (): AppContextType => {\n  const context = useContext(AppContext);\n  if (!context) {\n    throw new Error('useAppContext must be used within an AppProvider');\n  }\n  return context;\n};\n\nexport const AppProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  const [userName, setUserName] = useState<string | null>(null);\n  const [outputElements] = useState<OutputElement[]>([]);\n\n  const { currentActivity } = useActivityMediatorContext();\n\n  const value: AppContextType = {\n    currentActivity,\n    isLoggedIn,\n    setIsLoggedIn,\n    userName,\n    setUserName,\n    outputElements,\n  };\n\n  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/contexts/CommandContext.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":41,"column":8,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":41,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1317,1325],"text":"context == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/contexts/CommandContext.tsx\nimport type React from 'react';\nimport { createContext, useContext } from 'react';\n\nimport { type IHandTermWrapperMethods } from '../components/HandTermWrapper';\nimport { type IAuthProps } from '../hooks/useAuth';\nimport { type OutputElement, type ParsedCommand, type ParsedLocation } from '../types/Types';\n\nexport interface ICommandResponse {\n  status: number;\n  message: string;\n  body?: string | null;\n  sensitive?: boolean; // Flag to indicate if the command response contains sensitive data\n}\n\nexport interface ICommand {\n  name: string;\n  description: string;\n  switches?: Record<string, string>;\n  execute: (\n    context: ICommandContext,\n    parsedCommand: ParsedCommand,\n  ) => Promise<ICommandResponse>;\n}\n\nexport interface ICommandContext {\n  executeCommand: (command: string) => Promise<void>;\n  commandHistory: string[];\n  addToCommandHistory: (command: string) => void;\n  output: OutputElement[];\n  appendToOutput: (output: OutputElement) => void;\n  handTermRef: React.RefObject<IHandTermWrapperMethods>;\n  auth: IAuthProps;\n  updateLocation: (options: ParsedLocation) => void;\n}\n\nexport const CommandContext = createContext<ICommandContext | null>(null);\n\nexport const useCommandContext = (): ICommandContext => {\n  const context = useContext(CommandContext);\n  if (!context) {\n    throw new Error('useCommandContext must be used within a CommandProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/contexts/CommandProvider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/e2e/config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/e2e/helpers/exposeSignals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/e2e/page-objects/TerminalPage.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":57,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":57,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2241,2257],"text":"tutorialContent == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2242,2257],"text":"(tutorialContent ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2241,2257],"text":"!Boolean(tutorialContent)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type Page, type Locator, expect } from '@playwright/test';\n\nimport { TERMINAL_CONSTANTS } from 'src/constants/terminal';\nimport type { Signal } from '@preact/signals-react';\nimport type { ActivityType, GamePhrase } from 'src/types/Types';\nimport { TEST_CONFIG } from '../config';\n\n// Extend Window interface for our signals\ndeclare global {\n  interface Window {\n    tutorialSignal: Signal<GamePhrase | null>;\n    activitySignal: Signal<ActivityType>;\n  }\n}\n\nexport class TerminalPage {\n  readonly page: Page;\n  readonly terminal: Locator;\n  readonly output: Locator;\n  readonly tutorialMode: Locator;\n  readonly gameMode: Locator;\n  readonly nextChars: Locator;\n  private readonly prompt = TERMINAL_CONSTANTS.PROMPT;\n\n  async waitForActivityTransition(timeout = 10000): Promise<void> {\n    try {\n      await this.page.waitForSelector('#terminal-game', { state: 'visible', timeout });\n      await this.page.waitForSelector('.tutorial-component', { state: 'hidden', timeout });\n    } catch (error) {\n      const gameVisible = await this.gameMode.isVisible();\n      const tutorialVisible = await this.tutorialMode.isVisible();\n      console.log('Activity transition failed. Current state:', { gameVisible, tutorialVisible });\n      throw error;\n    }\n  }\n\n  async waitForTutorialMode(timeout = 10000): Promise<void> {\n    try {\n      // Wait for tutorial component to be attached\n      await this.page.waitForSelector('.tutorial-component', { state: 'attached', timeout });\n\n      // Wait for tutorial content to be loaded (tutorial-prompt only appears when content is set)\n      await this.page.waitForSelector('.tutorial-prompt', { state: 'visible', timeout });\n\n      // Get current tutorial state for debugging\n      const tutorialState = await this.page.evaluate(() => ({\n        tutorialSignal: window.tutorialSignal?.value,\n        activitySignal: window.activitySignal?.value,\n        completedTutorials: localStorage.getItem('completed-tutorials'),\n        tutorialState: localStorage.getItem('tutorial-state')\n      }));\n\n      console.log('[Tutorial State]', tutorialState);\n\n      // Verify tutorial content is actually set\n      const tutorialContent = await this.page.locator('.tutorial-prompt').textContent();\n      if (!tutorialContent) {\n        throw new Error('Tutorial content is empty');\n      }\n    } catch (error) {\n      // Log the current page state for debugging\n      const html = await this.page.content();\n      console.log('[Page Content]', html);\n      throw error;\n    }\n  }\n\n  constructor(page: Page) {\n    this.page = page;\n    this.terminal = page.locator('#xtermRef');\n    this.output = page.locator('#output-container');\n    this.tutorialMode = page.locator('.tutorial-component');\n    this.gameMode = page.locator('#terminal-game');\n    this.nextChars = page.locator('pre#next-chars');\n    return this;\n  }\n\n  public async goto(): Promise<void> {\n    await this.page.goto(`${TEST_CONFIG.baseUrl}/`);\n    // Wait for the signal to be exposed\n    await this.page.waitForFunction(() => 'commandLineSignal' in window, { timeout: TEST_CONFIG.timeout.medium });\n    await this.waitForTerminal();\n    await this.waitForPrompt();\n  }\n\n  /**\n   * Types a command into the terminal\n   * @param command The command to type\n   */\n  public async typeCommand(command: string): Promise<void> {\n    await this.waitForTerminal();\n    await this.terminal.click();\n    await this.page.keyboard.type(command);\n  }\n\n  /**\n   * Types a sequence of keys without executing a command\n   * @param keys The keys to type\n   */\n  public async typeKeys(keys: string): Promise<void> {\n    await this.waitForTerminal();\n    await this.terminal.click();\n    await this.page.keyboard.type(keys);\n  }\n\n  /**\n   * Presses the Enter key\n   */\n  public async pressEnter(): Promise<void> {\n    await this.waitForTerminal();\n    await this.page.keyboard.press('Enter');\n  }\n\n  /**\n   * Executes a command by typing it and pressing Enter\n   * @param command The command to execute\n   */\n  public async executeCommand(command: string): Promise<void> {\n    await this.waitForTerminal();\n    await this.typeCommand(command);\n    await this.pressEnter();\n  }\n\n  /**\n   * Gets the current terminal output\n   * @returns The text content of the output container\n   */\n  public async getOutput(): Promise<string> {\n    return await this.output.textContent() ?? '';\n  }\n\n  /**\n   * Gets the current command line text (without the prompt)\n   * @returns The current command line text\n   */\n  public async getCurrentCommand(): Promise<string> {\n    // Wait for the signal to be available\n    await this.page.waitForFunction(() => 'commandLineSignal' in window);\n\n    // Get the value from commandLineSignal\n    const commandLine = await this.page.evaluate(() => {\n      return (window as unknown as { commandLineSignal: { value: string } }).commandLineSignal.value;\n    });\n\n    return commandLine ?? '';\n  }\n\n  /**\n   * Waits for specific text to appear in the output\n   * @param text The text to wait for\n   */\n  public async waitForOutput(text: string): Promise<void> {\n    await this.output.getByText(text, { exact: false }).waitFor();\n  }\n\n  /**\n   * Waits for specific text to appear in the next chars display\n   * @param text The text to wait for\n   */\n  public async waitForNextChars(text: string): Promise<void> {\n    // First wait for the element to exist\n    await this.nextChars.waitFor({ state: 'attached' });\n\n    // Then wait for the specific text\n    await this.nextChars.waitFor({ state: 'visible' });\n    await expect(this.nextChars).toHaveText(text, { timeout: 10000 });\n  }\n\n  /**\n   * Waits for the prompt to appear, indicating the terminal is ready\n   */\n  public async waitForPrompt(): Promise<void> {\n    await this.terminal.getByText(this.prompt).last().waitFor();\n  }\n\n  /**\n   * Waits for the terminal to be ready\n   */\n  public async waitForTerminal(): Promise<void> {\n    // Wait for application to load\n    await this.page.waitForSelector('#handterm-wrapper', { state: 'attached', timeout: TEST_CONFIG.timeout.long });\n\n    // Wait for terminal element\n    await this.page.waitForSelector('#xtermRef', { state: 'attached', timeout: TEST_CONFIG.timeout.medium });\n\n    // Wait for xterm.js to be loaded and initialized\n    await this.page.waitForFunction(() => {\n      const term = document.querySelector('#xtermRef');\n      if (term == null) return false;\n      const screen = term.querySelector('.xterm-screen');\n      return term.querySelector('.xterm-viewport') !== null &&\n        screen !== null &&\n        screen.childElementCount > 0;\n    }, { timeout: TEST_CONFIG.timeout.medium });\n\n    // Wait for terminal to be visible and interactive\n    await this.terminal.waitFor({ state: 'visible', timeout: TEST_CONFIG.timeout.medium });\n\n    // Wait for terminal to be ready for interaction and focused\n    await this.page.waitForFunction(() => {\n      const term = document.querySelector('#xtermRef');\n      if (term == null) return false;\n      const screen = term.querySelector('.xterm-screen');\n      if (screen == null) return false;\n      const viewport = term.querySelector('.xterm-viewport');\n      if (viewport == null) return false;\n      return screen.childElementCount > 0;\n    }, { timeout: TEST_CONFIG.timeout.medium });\n\n    // Focus the terminal\n    await this.terminal.click();\n  }\n\n  /**\n   * Focuses the terminal\n   */\n  public async focus(): Promise<void> {\n    await this.terminal.click();\n  }\n\n  /**\n   * Clears the current command line using Ctrl+C\n   */\n  public async clearLine(): Promise<void> {\n    await this.terminal.click();\n    await this.page.keyboard.press('Control+C');\n    await this.waitForPrompt();\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/e2e/scenarios/activitySwitchingScenarios.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/e2e/setup.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":19,"column":37,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":19,"endColumn":47,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[672,682],"text":"(store[key] != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[672,682],"text":"(store[key] ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[672,682],"text":"(Boolean(store[key]))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":24,"column":35,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":24,"endColumn":60,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1007,1032],"text":"(Object.keys(store)[index] != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1007,1032],"text":"(Object.keys(store)[index] ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1007,1032],"text":"(Boolean(Object.keys(store)[index]))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test as playwrightTest } from '@playwright/test';\nimport type { GamePhrase, ActivityType } from '../types/Types';\n\ndeclare global {\n  interface Window {\n    testName: string;\n  }\n}\n\n// Initialize localStorage and window methods for all e2e tests\nexport const setupPlaywrightTests = (): void => {\n  playwrightTest.beforeEach(async ({ context }, _testInfo) => {\n    await context.addInitScript((title: string) => {\n      window.testName = title;\n      // Initialize localStorage\n      if (typeof window.localStorage === 'undefined') {\n        const store: Record<string, string | undefined> = {};\n        window.localStorage = {\n          getItem: (key: string) => store[key] || null,\n          setItem: (key: string, value: string) => { store[key] = value; },\n          removeItem: (key: string) => { store[key] = undefined; },\n          clear: () => { Object.keys(store).forEach(key => { store[key] = undefined; }); },\n          length: Object.keys(store).length,\n          key: (index: number) => Object.keys(store)[index] || null\n        };\n      }\n\n      // Initialize tutorial state based on test name\n      const testName = window.testName;\n      if (testName.includes('should handle \\\\r')) {\n        window.localStorage.setItem('completed-tutorials', JSON.stringify([]));\n      } else if (testName.includes('should handle fdsa\\\\r')) {\n        window.localStorage.setItem('completed-tutorials', JSON.stringify(['\\\\r']));\n      } else if (testName.includes('should handle jkl;\\\\r')) {\n        window.localStorage.setItem('completed-tutorials', JSON.stringify(['\\\\r', 'fdsa']));\n      }\n      window.localStorage.setItem('tutorial-state', JSON.stringify({ currentStep: 0 }));\n\n      // Initialize window methods\n      if (typeof window.setActivity === 'undefined') {\n        window.setActivity = (_activity: ActivityType) => {};\n      }\n      if (typeof window.setNextTutorial === 'undefined') {\n        window.setNextTutorial = (_tutorial: GamePhrase | null) => {};\n      }\n    });\n  });\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/e2e/testDescriptionParser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/e2e/tests/tutorial.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/Game.tsx","messages":[{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":104,"column":5,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":107,"endColumn":6},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":126,"column":5,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":128,"endColumn":6},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":131,"column":5,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":137,"endColumn":6},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":139,"column":5,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":151,"endColumn":6},{"ruleId":"no-param-reassign","severity":1,"message":"Assignment to function parameter 'show'.","line":175,"column":24,"nodeType":"Identifier","messageId":"assignmentToFunctionParam","endLine":175,"endColumn":28},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":212,"column":5,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":215,"endColumn":6},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":229,"column":5,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":231,"endColumn":6},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":236,"column":5,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":240,"endColumn":6},{"ruleId":"no-param-reassign","severity":1,"message":"Assignment to function parameter 'setLevelValue'.","line":253,"column":7,"nodeType":"Identifier","messageId":"assignmentToFunctionParam","endLine":253,"endColumn":20},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":262,"column":5,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":264,"endColumn":6},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":276,"column":5,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":278,"endColumn":6},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":283,"column":7,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":285,"endColumn":8},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":290,"column":5,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":292,"endColumn":6}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// TerminalGame.ts\nimport { useState, useEffect, useRef, useImperativeHandle, useCallback, useMemo, forwardRef } from 'react';\n\nimport confetti from 'canvas-confetti';\n\nimport { useComputed, useSignalEffect } from \"@preact/signals-react\";\n\nimport { commandLineSignal } from \"../signals/commandLineSignals\";\nimport { isInGameModeSignal } from '../signals/gameSignals';\nimport { createLogger, LogLevel } from '../utils/Logger';\n\nimport { Hero } from './Hero';\nimport { layers, getLevelCount } from './Level';\nimport { type IParallaxLayer, ParallaxLayer } from './ParallaxLayer';\nimport ScrollingTextLayer from './ScrollingTextLayer';\nimport { type Sprite } from './sprites/Sprite';\nimport { type Action, type ActionType } from './types/ActionTypes';\nimport { type SpritePosition } from './types/Position';\nimport { Zombie4 } from './Zombie4';\n\nconst logger = createLogger({\n  prefix: 'Game',\n  level: LogLevel.DEBUG\n});\n\ninterface ICharacterRefMethods {\n  getCurrentSprite: () => Sprite | null;\n  getActions: () => Record<ActionType, Action>;\n  positionRef: SpritePosition;\n  draw: (context: CanvasRenderingContext2D, position: SpritePosition) => number;\n}\n\ninterface IGameProps {\n  canvasHeight: number;\n  canvasWidth: number;\n}\n\ninterface IGameHandle {\n  startGame: (tutorialGroup?: string) => void;\n  completeGame: () => void;\n  resetGame: () => void;\n  levelUp: (setLevelValue?: number | null) => void;\n}\n\nfunction GameFunction(props: IGameProps, ref: React.ForwardedRef<IGameHandle>): JSX.Element {\n  const {\n    canvasHeight,\n    canvasWidth,\n  } = props;\n\n  // Use useMemo to memoize static objects\n  const zombie4StartPosition = useMemo(() => ({ leftX: 0, topY: 0 }), []);\n  const heroStartPosition = useMemo(() => ({ leftX: 165, topY: 29 }), []);\n  const heroXPercent = 0.23;\n\n  const zombie4PositionRef = useRef<SpritePosition>(zombie4StartPosition);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const heroRef = useRef<ICharacterRefMethods>(null);\n  const zombie4Ref = useRef<ICharacterRefMethods>(null);\n  const animationFrameIndex = useRef<number | undefined>(undefined);\n  const zombie4DeathTimeout = useRef<NodeJS.Timeout | null>(null);\n  const heroRunTimeoutRef = useRef<number | null>(null);\n\n  const heroPositionRef = useRef<SpritePosition>(heroStartPosition);\n  const [heroPosition, setHeroPosition] = useState<SpritePosition>({ leftX: canvasWidth * heroXPercent, topY: 30 });\n\n  const [currentLevel, setCurrentLevel] = useState(1);\n  const [context, setContext] = useState<CanvasRenderingContext2D | null>(null);\n  const [backgroundOffsetX, setBackgroundOffsetX] = useState(0);\n  const [isPhraseComplete, setIsPhraseComplete] = useState(false);\n  const [isTextScrolling, setIsTextScrolling] = useState(false);\n  const [heroAction, setHeroAction] = useState<ActionType>('Idle');\n  const [zombie4Action, setZombie4Action] = useState<ActionType>('Walk');\n  const textToScroll = \"TERMINAL VELOCITY!\";\n  const [layersState, setLayersState] = useState<IParallaxLayer[]>(layers[0] ?? []);\n\n  const commandLine = useComputed(() => commandLineSignal.value);\n  const isInGameMode = useComputed(() => isInGameModeSignal.value).value;\n\n  // Memoize getLevel to prevent unnecessary re-renders\n  const getLevel = useCallback(() => currentLevel, [currentLevel]);\n\n  const stopAnimationLoop = useCallback(() => {\n    const frameId = animationFrameIndex.current;\n    if (typeof frameId === 'number' && !Number.isNaN(frameId)) {\n      cancelAnimationFrame(frameId);\n      animationFrameIndex.current = undefined;\n    }\n  }, []);\n\n  const triggerConfettiCannon = useCallback(() => {\n    void confetti({\n      zIndex: 3,\n      angle: 160,\n      spread: 45,\n      startVelocity: 45,\n      particleCount: 150,\n      origin: { x: 0.99, y: 0.8 }\n    });\n  }, []);\n\n  const setZombie4ToDeathThenResetPosition = useCallback(() => {\n    const timeout = zombie4DeathTimeout.current;\n    if (timeout !== null) {\n      clearTimeout(timeout);\n      zombie4DeathTimeout.current = null;\n    }\n\n    setZombie4Action('Death');\n    zombie4DeathTimeout.current = setTimeout(() => {\n      setZombie4Action('Walk');\n      zombie4PositionRef.current = zombie4StartPosition;\n      setIsPhraseComplete(false);\n      zombie4DeathTimeout.current = null;\n    }, 3000);\n  }, [zombie4StartPosition]);\n\n  const updateCharacterAndBackgroundPostion = useCallback((context: CanvasRenderingContext2D): number => {\n    const canvasCenterX = canvasWidth * heroXPercent;\n    const characterReachThreshold = canvasCenterX;\n\n    context.clearRect(0, 0, canvasWidth, canvasHeight);\n\n    let heroDx = 0;\n    const hero = heroRef.current;\n    if (hero !== null) {\n      heroDx = hero.draw(context, heroPosition);\n    }\n\n    const zombie = zombie4Ref.current;\n    if (zombie !== null) {\n      const zombie4Dx = zombie.draw(context, zombie4PositionRef.current);\n      zombie4PositionRef.current = {\n        ...zombie4PositionRef.current,\n        leftX: zombie4PositionRef.current.leftX + zombie4Dx - heroDx\n      };\n    }\n\n    if (heroDx !== 0) {\n      setBackgroundOffsetX(prev => prev + heroDx);\n\n      if (heroPosition.leftX >= characterReachThreshold) {\n        setHeroPosition(prev => ({ ...prev, leftX: characterReachThreshold }));\n      }\n\n      const newZombie4PositionX = zombie4PositionRef.current.leftX - heroDx;\n      zombie4PositionRef.current = {\n        ...zombie4PositionRef.current,\n        leftX: newZombie4PositionX\n      };\n    }\n    return heroDx;\n  }, [canvasWidth, canvasHeight, heroPosition]);\n\n  const checkProximityAndSetAction = useCallback(() => {\n    const ATTACK_THRESHOLD = 100;\n    const distance = heroPosition.leftX - zombie4PositionRef.current.leftX;\n\n    if (-20 < distance && distance < ATTACK_THRESHOLD) {\n      setZombie4Action('Attack');\n      if (distance < 50) {\n        setHeroAction('Hurt');\n      }\n      if (distance < 30) {\n        setHeroAction('Death');\n      }\n    } else {\n      if (zombie4Action === 'Attack') {\n        setZombie4Action('Walk');\n      }\n    }\n  }, [heroPosition, zombie4Action, setHeroAction]);\n\n  const toggleScrollingText = useCallback((show: boolean | null = null) => {\n    if (show === null) show = !isTextScrolling;\n    setIsTextScrolling(show);\n  }, [isTextScrolling]);\n\n  const drawScrollingText = useCallback(() => {\n    toggleScrollingText(true);\n    setTimeout(() => {\n      toggleScrollingText(false);\n    }, 3000);\n  }, [toggleScrollingText]);\n\n  const startAnimationLoop = useCallback((context: CanvasRenderingContext2D) => {\n    const frameDelay = 150;\n    let lastFrameTime = performance.now();\n\n    const loop = () => {\n      const now = performance.now();\n      const deltaTime = now - lastFrameTime;\n\n      if (typeof deltaTime === 'number' && !Number.isNaN(deltaTime) && deltaTime >= frameDelay) {\n        lastFrameTime = now - (deltaTime % frameDelay);\n\n        if (isPhraseComplete) {\n          drawScrollingText();\n        }\n\n        updateCharacterAndBackgroundPostion(context);\n        checkProximityAndSetAction();\n      }\n      animationFrameIndex.current = requestAnimationFrame(loop);\n    };\n\n    animationFrameIndex.current = requestAnimationFrame(loop);\n  }, [isPhraseComplete, drawScrollingText, updateCharacterAndBackgroundPostion, checkProximityAndSetAction]);\n\n  const setHeroRunAction = useCallback(() => {\n    const timeout = heroRunTimeoutRef.current;\n    if (timeout !== null) {\n      clearTimeout(timeout);\n      heroRunTimeoutRef.current = null;\n    }\n\n    setHeroAction('Run');\n    heroRunTimeoutRef.current = window.setTimeout(() => {\n      setHeroAction('Idle');\n      heroRunTimeoutRef.current = null;\n    }, 800);\n  }, [setHeroAction]);\n\n  const handleCommandLineChange = useCallback(() => {\n    setHeroRunAction();\n  }, [setHeroRunAction]);\n\n  useSignalEffect(() => {\n    if (commandLine.value?.trim() !== '') {\n      handleCommandLineChange();\n    }\n  });\n\n  const setupCanvas = useCallback((canvas: HTMLCanvasElement) => {\n    const canvasContext = canvas.getContext('2d');\n    if (canvasContext !== null) {\n      setContext(canvasContext);\n    } else {\n      logger.error(\"Failed to get canvas context.\");\n    }\n  }, []);\n\n  const setLevel = useCallback((newLevel: number) => {\n    const levelIndex = Math.max(0, Math.min(newLevel - 1, layers.length - 1));\n    const newLayers = layers[levelIndex] ?? [];\n    setCurrentLevel(newLevel);\n    setLayersState(newLayers);\n  }, []);\n\n  const levelUp = useCallback((setLevelValue: number | null = null) => {\n    const levelCount = getLevelCount();\n    if (setLevelValue !== null && setLevelValue > levelCount) {\n      setLevelValue = levelCount;\n    }\n    let nextLevel = setLevelValue !== null ? setLevelValue : getLevel() + 1;\n    if (nextLevel > levelCount) nextLevel = 0;\n    if (nextLevel < 1) nextLevel = 1;\n    setLevel(nextLevel);\n  }, [setLevel, getLevel]);\n\n  const startGame = useCallback(() => {\n    if (context !== null) {\n      startAnimationLoop(context);\n    }\n    setIsPhraseComplete(false);\n  }, [context, startAnimationLoop]);\n\n  const completeGame = useCallback(() => {\n    setZombie4ToDeathThenResetPosition();\n    triggerConfettiCannon();\n    setIsPhraseComplete(true);\n  }, [setZombie4ToDeathThenResetPosition, triggerConfettiCannon]);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (canvas !== null) {\n      setupCanvas(canvas);\n    }\n\n    return () => {\n      stopAnimationLoop();\n      const timeout = zombie4DeathTimeout.current;\n      if (timeout !== null) {\n        clearTimeout(timeout);\n      }\n    };\n  }, [setupCanvas, stopAnimationLoop]);\n\n  useEffect(() => {\n    if (context !== null) {\n      startAnimationLoop(context);\n    }\n  }, [context, startAnimationLoop]);\n\n  useImperativeHandle(ref, () => ({\n    startGame,\n    completeGame,\n    resetGame: () => {\n      zombie4PositionRef.current = zombie4StartPosition;\n      setIsPhraseComplete(false);\n    },\n    levelUp,\n  }), [startGame, completeGame, levelUp, zombie4StartPosition]);\n\n  if (!isInGameMode) {\n    return <div />;\n  }\n\n  return (\n    <div\n      id=\"terminal-game\"\n      style={{ position: \"relative\", height: canvasHeight }}\n    >\n      <div className=\"parallax-background\">\n        {isTextScrolling && (\n          <ScrollingTextLayer\n            text={textToScroll}\n            canvasHeight={canvasHeight}\n          />\n        )}\n        {layersState.map((layer, index) => (\n          <ParallaxLayer\n            key={index}\n            layer={layer}\n            offset={backgroundOffsetX}\n            canvasHeight={canvasHeight}\n          />\n        ))}\n      </div>\n      <canvas\n        data-testid=\"game-canvas\"\n        style={{ position: \"absolute\", top: 0, left: 0, zIndex: 2 }}\n        ref={canvasRef}\n        width={canvasWidth}\n        height={canvasHeight}\n      />\n      <Hero\n        ref={heroRef}\n        positionRef={heroPositionRef}\n        currentActionType={heroAction}\n        scale={1.95}\n      />\n      <Zombie4\n        ref={zombie4Ref}\n        positionRef={zombie4PositionRef}\n        currentActionType={zombie4Action}\n        scale={1.90}\n      />\n    </div>\n  );\n}\n\nexport type { IGameHandle, IGameProps };\nexport const Game = forwardRef(GameFunction);\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/GameClock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/Hero.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/ICharacterProps.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/Level.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/ParallaxLayer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/ScrollingTextLayer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/SpriteManagerContext.tsx","messages":[{"ruleId":"import/no-named-as-default-member","severity":1,"message":"Caution: `React` also has a named export `createContext`. Check if you meant to write `import {createContext} from 'react'` instead.","line":7,"column":30,"nodeType":"MemberExpression","endLine":7,"endColumn":49}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// SpriteManagerContext.tsx\nimport React from 'react';\n\nimport { type SpriteManager } from './sprites/SpriteManager';\n\n// Create a context with a default undefined value\nconst SpriteManagerContext = React.createContext<SpriteManager | undefined>(undefined);\n\nexport default SpriteManagerContext;","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/TypeScriptStateMachine.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/Zombie4.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/__tests__/Game.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/characters/hero/HeroAnimations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/characters/zombie4/Zombie4Animations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/sprites/Sprite.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/sprites/SpriteManager.tsx","messages":[{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":18,"column":13,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":20,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createLogger, LogLevel } from 'src/utils/Logger';\n\nimport { type SpriteAnimation } from '../types/SpriteTypes';\n\nimport { Sprite } from './Sprite';\n\nconst logger = createLogger({\n  prefix: 'SpriteManager',\n  level: LogLevel.ERROR\n});\n\nexport class SpriteManager {\n    private spriteCache = new Map<string, Sprite>();\n\n    public async loadSprite(animationData: SpriteAnimation): Promise<Sprite> {\n        if (this.spriteCache.has(animationData.imagePath)) {\n            const cachedSprite = this.spriteCache.get(animationData.imagePath);\n            if (cachedSprite !== undefined) {\n                return cachedSprite;\n            }\n        }\n\n        const sprite = new Sprite(animationData.imagePath, animationData.frameCount, animationData.frameWidth, animationData.frameHeight, animationData.framePositions);\n        await this.waitForManagerImageLoad(sprite.image);\n\n        this.spriteCache.set(animationData.imagePath, sprite);\n        return sprite;\n    }\n\n    private waitForManagerImageLoad(image: HTMLImageElement): Promise<void> {\n        return new Promise((resolve, reject) => {\n            const onLoad = () => {\n                // Cleanup: Remove both event listeners\n                image.removeEventListener('load', onLoad);\n                image.removeEventListener('error', onError);\n                resolve();\n            };\n\n            const onError = () => {\n                // Cleanup: Remove both event listeners\n                image.removeEventListener('load', onLoad);\n                image.removeEventListener('error', onError);\n                logger.error('Image failed to load: ' + image.src);\n                reject(new Error(`Image failed to load: ${image.src}`)); // Reject the promise on error\n            };\n\n            // Attach the event listeners\n            image.addEventListener('load', onLoad);\n            image.addEventListener('error', onError);\n        });\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/types/ActionTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/types/Position.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/types/SpriteTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/useBaseCharacter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/activityMachine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useAPI.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":76,"column":34,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":76,"endColumn":66,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2188,2220],"text":"((apiError.response?.data?.message) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2188,2220],"text":"((apiError.response?.data?.message) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2188,2220],"text":"(Boolean((apiError.response?.data?.message)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":77,"column":34,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":77,"endColumn":50,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[2257,2273],"text":"(apiError.message.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[2257,2273],"text":"(apiError.message !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2257,2273],"text":"(Boolean(apiError.message))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":80,"column":50,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":80,"endColumn":64},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":80,"column":68,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":80,"endColumn":88},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":85,"column":25,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":85,"endColumn":50,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2555,2580],"text":"((apiError.response?.status) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[2555,2580],"text":"((apiError.response?.status) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2555,2580],"text":"(Boolean((apiError.response?.status)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'auth'. Either include it or remove the dependency array.","line":89,"column":8,"nodeType":"ArrayExpression","endLine":89,"endColumn":38,"suggestions":[{"desc":"Update the dependencies array to be: [auth]","fix":{"range":[2657,2687],"text":"[auth]"}}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":94,"column":17,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":94,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2905,2909],"text":"(path != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2905,2909],"text":"(path ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2905,2909],"text":"(Boolean(path))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":95,"column":17,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":95,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2940,2943],"text":"(sha != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2940,2943],"text":"(sha ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2940,2943],"text":"(Boolean(sha))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback } from 'react';\nimport axios, { type AxiosError } from 'axios';\n\nimport ENDPOINTS from '../shared/endpoints.json';\nimport { type IAuthProps } from './useAuth';\n\ninterface APIResponse<T> {\n    status: number;\n    data?: T;\n    error?: string;\n}\n\ninterface FileContentResponse {\n    content: string;\n    encoding?: string;\n    sha?: string;\n}\n\ninterface TreeItemResponse {\n    path: string;\n    type: string;\n    sha?: string;\n    size?: number;\n}\n\ninterface RepoResponse {\n    name: string;\n    description?: string;\n    private: boolean;\n    default_branch: string;\n}\n\ninterface APIError {\n    status: number;\n    message: string;\n}\n\nexport function useAPI(auth: IAuthProps): {\n    getRepoTree: (repo: string, path?: string, sha?: string) => Promise<APIResponse<TreeItemResponse[]>>,\n    getFileContent: (repo: string, path: string) => Promise<APIResponse<FileContentResponse>>,\n    listRecentRepos: () => Promise<APIResponse<RepoResponse[]>>\n} {\n    const makeAuthenticatedRequest = useCallback(async <T,>(\n        endpoint: string,\n        params?: Record<string, string>,\n        method: 'GET' | 'POST' = 'GET'\n    ): Promise<APIResponse<T>> => {\n        try {\n            const authResponse = await auth.validateAndRefreshToken();\n            if (authResponse == null || authResponse.status !== 200 || authResponse.data == null) {\n                return {\n                    status: 401,\n                    error: 'Authentication failed'\n                };\n            }\n\n            const response = await axios({\n                method,\n                url: `${ENDPOINTS.api.BaseUrl}${endpoint}`,\n                headers: {\n                    'Authorization': `Bearer ${authResponse.data.accessToken}`,\n                    'Content-Type': 'application/json',\n                    'Accept': 'application/json'\n                },\n                params\n            });\n\n            return {\n                status: response.status,\n                data: response.data as T\n            };\n        } catch (error) {\n            const apiError = error as AxiosError<APIError>;\n\n            // Log error without using console.error\n            const errorMessage = apiError.response?.data?.message ||\n                                 apiError.message ||\n                                 'Request failed';\n\n            if (typeof window !== 'undefined' && window.console && window.console.error) {\n                window.console.error('API request failed:', errorMessage);\n            }\n\n            return {\n                status: apiError.response?.status || 500,\n                error: errorMessage\n            };\n        }\n    }, [auth.validateAndRefreshToken]);\n\n    const getRepoTree = useCallback(async (repo: string, path?: string, sha?: string) => {\n        return makeAuthenticatedRequest<TreeItemResponse[]>(ENDPOINTS.api.GetRepoTree, {\n            repo,\n            ...(path && { path }),\n            ...(sha && { sha })\n        });\n    }, [makeAuthenticatedRequest]);\n\n    const getFileContent = useCallback(async (repo: string, path: string) => {\n        return makeAuthenticatedRequest<FileContentResponse>('/github/file', {\n            repo,\n            path\n        });\n    }, [makeAuthenticatedRequest]);\n\n    const listRecentRepos = useCallback(async () => {\n        return makeAuthenticatedRequest<RepoResponse[]>(ENDPOINTS.api.ListRecentRepos);\n    }, [makeAuthenticatedRequest]);\n\n    return {\n        getRepoTree,\n        getFileContent,\n        listRecentRepos\n    };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useActivityMediator.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useActivityMediator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useAuth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useCharacterHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useCommand.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":55,"column":13,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":55,"endColumn":25},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":88,"column":17,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":88,"endColumn":55,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[3772,3810],"text":"(key?.startsWith(LogKeys.Command + '_')) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[3772,3810],"text":"(key?.startsWith(LogKeys.Command + '_')) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":95,"column":17,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":95,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4000,4011],"text":"historyJSON != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[4000,4011],"text":"historyJSON ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4000,4011],"text":"Boolean(historyJSON)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":192,"column":13,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":195,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/hooks/useCommand.ts\nimport { useComputed } from '@preact/signals-react';\nimport type React from 'react';\nimport { useContext, useState, useCallback, useEffect } from 'react';\n\nimport { activitySignal, appendToOutput } from 'src/signals/appSignals';\nimport { setCommandTime } from 'src/signals/commandLineSignals';\nimport { createLogger } from 'src/utils/Logger';\n\nimport { commandRegistry } from '../commands/commandRegistry';\nimport { CommandContext, type ICommandResponse } from '../contexts/CommandContext';\nimport { LogKeys } from '../types/TerminalTypes';\nimport { ActivityType, type OutputElement, type ParsedCommand } from '../types/Types';\nimport { parsedCommandToString, loadCommandHistory, saveCommandHistory } from '../utils/commandUtils';\n\nimport { useActivityMediator } from './useActivityMediator';\nimport { useWPMCalculator } from './useWPMCaculator';\n\n\nconst logger: ReturnType<typeof createLogger> = createLogger({ prefix: 'useCommand' });\n\nexport const useCommand = (): {\n    output: OutputElement[];\n    resetOutput: () => void;\n    commandHistory: string[];\n    addToCommandHistory: (command: ParsedCommand | string) => void;\n    getCommandResponseHistory: () => string[];\n    handleCommand: (parsedCommand: ParsedCommand) => Promise<void>;\n    commandHistoryIndex: number;\n    setCommandHistoryIndex: React.Dispatch<React.SetStateAction<number>>;\n    commandHistoryFilter: string | null;\n    setCommandHistoryFilter: React.Dispatch<React.SetStateAction<string | null>>;\n    appendToOutput: (outputElement: OutputElement) => void;\n    executeCommand: (parsedCommand: ParsedCommand) => Promise<void>;\n} => {\n    const [output, setOutput] = useState<OutputElement[]>([]);\n    const [commandHistory, setCommandHistory] = useState<string[]>([]);\n    const [commandHistoryIndex, setCommandHistoryIndex] = useState(-1);\n    const [commandHistoryFilter, setCommandHistoryFilter] = useState<string | null>(null);\n    const currentActivity = useComputed(() => activitySignal.value);\n    const {\n        handleCommandExecuted,\n        checkTutorialProgress\n    } = useActivityMediator();\n    const wpmCalculator = useWPMCalculator();\n    const context = useContext(CommandContext);\n\n    if (context === undefined) {\n        throw new Error('useCommand must be used within a CommandProvider');\n    }\n\n    // Load command history from localStorage on mount\n    useEffect(() => {\n        const savedHistory = loadCommandHistory();\n        if (savedHistory && savedHistory.length > 0) {\n            logger.debug('Loaded command history:', savedHistory);\n            setCommandHistory(savedHistory);\n        }\n    }, []);\n\n    const resetOutput = useCallback((): void => {\n        logger.debug('Resetting output');\n        setOutput([]);\n    }, []);\n\n    const addToCommandHistory = useCallback((command: ParsedCommand | string): void => {\n        const commandString = typeof command === 'string'\n            ? command\n            : parsedCommandToString(command);\n\n        logger.debug('Adding to command history:', commandString);\n        setCommandHistory(prev => {\n            // Don't add if it's identical to the previous command\n            if (prev.length > 0 && prev[prev.length - 1] === commandString) {\n                return prev;\n            }\n            const newHistory = [...prev, commandString].slice(-120); // Keep last 120 commands\n            saveCommandHistory(newHistory); // Save to localStorage whenever history changes\n            return newHistory;\n        });\n    }, []);\n\n    const getCommandResponseHistory = useCallback((): string[] => {\n        const keys: string[] = [];\n        const history: string[] = [];\n        for (let i = 0; i < localStorage.length; i++) {\n            const key = localStorage.key(i);\n            if (key?.startsWith(LogKeys.Command + '_')) {\n                keys.push(key);\n            }\n        }\n        keys.sort();\n        for (const key of keys) {\n            const historyJSON = localStorage.getItem(key);\n            if (historyJSON) {\n                history.push(historyJSON);\n            }\n        }\n        logger.debug('Retrieved command response history:', history);\n        return history;\n    }, []);\n\n    const createCommandRecord = useCallback((\n        command: ParsedCommand,\n        response: React.ReactNode,\n        status: number,\n        commandTime: Date,\n        sensitive: boolean\n    ): OutputElement => {\n        const wpms = wpmCalculator.getWPMs();\n        logger.debug('Creating command record:', { command, response, status });\n        return {\n            command,\n            response,\n            status,\n            wpmAverage: wpms.wpmAverage,\n            characterAverages: wpms.charWpms,\n            commandTime,\n            sensitive: sensitive ?? false\n        };\n    }, [wpmCalculator]);\n\n    const processCommandOutput = useCallback((\n        command: ParsedCommand,\n        response: ICommandResponse,\n    ): void => {\n        logger.debug('Processing command output:', { command, response });\n        const commandTime = new Date();\n        const outputElement = createCommandRecord(\n            command,\n            response.message,\n            response.status,\n            commandTime,\n            response.sensitive ?? false\n        );\n        appendToOutput(outputElement);\n        addToCommandHistory(command);\n    }, [createCommandRecord, addToCommandHistory]);\n\n    const executeCommand = useCallback(async (parsedCommand: ParsedCommand) => {\n        // Breakpoint 5: Start of command execution\n        logger.debug('Executing command:', parsedCommand);\n        const command = commandRegistry.getCommand(parsedCommand.command);\n        if (command != null && context != null) {\n            try {\n                const response = await command.execute(context, parsedCommand);\n                logger.debug('Command executed successfully:', response);\n                processCommandOutput(parsedCommand, response);\n                handleCommandExecuted(parsedCommand);\n            } catch (error) {\n                const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n                logger.error('Command execution failed:', error);\n                processCommandOutput(parsedCommand, {\n                    status: 500,\n                    message: errorMessage\n                });\n                handleCommandExecuted(parsedCommand);\n            }\n        } else {\n            // Breakpoint 6: Tutorial command handling\n            const response = currentActivity.value === ActivityType.TUTORIAL ? `Tutorial attempt: ${parsedCommand.command}` : `Command not found: ${parsedCommand.command}`;\n            logger.debug('Command not found:', { command: parsedCommand.command, activity: currentActivity.value });\n            processCommandOutput(parsedCommand, {\n                status: 404,\n                message: response\n            });\n            handleCommandExecuted(parsedCommand);\n        }\n    }, [context, processCommandOutput, handleCommandExecuted, currentActivity]);\n\n    const handleCommand = useCallback(async (parsedCommand: ParsedCommand) => {\n        // Breakpoint 7: Start of command handling\n        const initialActivity = currentActivity.value;\n        logger.debug('Handling command:', {\n            parsedCommand,\n            activity: initialActivity,\n            timestamp: new Date().toISOString()\n        });\n\n        setCommandTime(new Date());\n\n        // Only check tutorial progress if we're explicitly in tutorial mode\n        if (initialActivity === ActivityType.TUTORIAL) {\n            // Breakpoint 8: Tutorial progress check\n            logger.debug('Processing tutorial command:', {\n                command: parsedCommand.command,\n                activity: initialActivity\n            });\n            checkTutorialProgress(parsedCommand.command);\n\n            // If activity changed during tutorial progress check, skip command execution\n            if (currentActivity.value !== initialActivity) {\n                logger.debug('Activity changed during tutorial progress - skipping command execution');\n                return;\n            }\n        } else {\n            logger.debug('Processing non-tutorial command:', {\n                command: parsedCommand.command,\n                activity: initialActivity\n            });\n        }\n\n        await executeCommand(parsedCommand);\n\n        logger.debug('Command handling complete:', {\n            parsedCommand,\n            activity: currentActivity.value,\n            timestamp: new Date().toISOString()\n        });\n    }, [currentActivity.value, executeCommand, checkTutorialProgress]);\n\n    return {\n        output,\n        resetOutput,\n        commandHistory,\n        addToCommandHistory,\n        getCommandResponseHistory,\n        handleCommand,\n        commandHistoryIndex,\n        setCommandHistoryIndex,\n        commandHistoryFilter,\n        setCommandHistoryFilter,\n        appendToOutput,\n        executeCommand\n    };\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useReactiveLocation.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'isInitialized', 'pathSignal', and 'searchSignal'. Either include them or remove the dependency array.","line":31,"column":6,"nodeType":"ArrayExpression","endLine":31,"endColumn":16,"suggestions":[{"desc":"Update the dependencies array to be: [isInitialized, location, pathSignal, searchSignal]","fix":{"range":[1062,1072],"text":"[isInitialized, location, pathSignal, searchSignal]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useSignal, useComputed } from '@preact/signals-react';\nimport { useEffect } from 'react';\nimport { useLocation, useSearchParams } from 'react-router-dom';\n\ninterface ReactiveLocation {\n  pathname: ReturnType<typeof useSignal<string>>;\n  search: ReturnType<typeof useSignal<string>>;\n  isInitialized: ReturnType<typeof useComputed<boolean>>;\n}\n\nexport function useReactiveLocation(): ReactiveLocation {\n  const location = useLocation();\n  useSearchParams();\n\n  const pathSignal = useSignal(location.pathname);\n  const searchSignal = useSignal(location.search);\n  const isInitialized = useSignal(false);\n\n  useEffect(() => {\n    if (!isInitialized.value) {\n      pathSignal.value = location.pathname;\n      searchSignal.value = location.search;\n      isInitialized.value = true;\n    } else {\n      // Only update if the location has actually changed\n      if (pathSignal.value !== location.pathname || searchSignal.value !== location.search) {\n        pathSignal.value = location.pathname;\n        searchSignal.value = location.search;\n      }\n    }\n  }, [location]);\n\n\n  return {\n    pathname: pathSignal,\n    search: searchSignal,\n    isInitialized: useComputed(() => isInitialized.value)\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useResizeCanvasAndFont.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":23,"column":17,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":23,"endColumn":45,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[989,1017],"text":"(lastTouchDistanceRef.current != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[989,1017],"text":"(lastTouchDistanceRef.current ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[989,1017],"text":"(Boolean(lastTouchDistanceRef.current))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":27,"column":21,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":27,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// useResizeCanvasAndFont.ts\nimport { useState, useCallback, type TouchEventHandler, useRef } from 'react';\n\nexport function useResizeCanvasAndFont(): {\n    fontSize: number;\n    canvasHeight: number;\n    handleTouchMove: (event: TouchEvent) => void;\n    handleTouchStart: TouchEventHandler<HTMLElement>;\n    handleTouchEnd: TouchEventHandler<HTMLDivElement>;\n} {\n    const initialFontSize = parseInt(localStorage.getItem(\"fontSize\") ?? '17');\n    const initialCanvasHeight = parseInt(localStorage.getItem('canvas-height') ?? '100');\n    const [fontSize, setFontSize] = useState(initialFontSize);\n    const [canvasHeight, setCanvasHeight] = useState(initialCanvasHeight);\n    const lastTouchDistanceRef = useRef<number | null>(null);\n\n    const handleTouchMove = useCallback((event: TouchEvent) => {\n        if (event.touches.length === 2) {\n            event.preventDefault();\n\n            const currentDistance =\n                getDistanceBetweenTouches(event.touches);\n            if (lastTouchDistanceRef.current && lastTouchDistanceRef.current > 0) {\n                const eventTarget = event.target as HTMLElement;\n                const scaleFactor = currentDistance /\n                    lastTouchDistanceRef.current;\n                if (eventTarget && eventTarget.nodeName ===\n                    'CANVAS') {\n                    setCanvasHeight(prevCanvasHeight => prevCanvasHeight * scaleFactor);\n                } else {\n                    setFontSize(prevFontSize => prevFontSize *\n                        scaleFactor);\n                    document.documentElement.style.setProperty('--rminal-font-size', `${fontSize}px`);\n                }\n                lastTouchDistanceRef.current = currentDistance;\n            }\n        }\n    }, [fontSize]);\n\n    const handleTouchStart: TouchEventHandler<HTMLElement> = (event: React.TouchEvent<HTMLElement>) => {\n        setTimeout(() => {\n            // this.terminalElement.focus();\n        }, 500)\n        if (event.touches.length === 2) {\n            // event.preventDefault();\n            lastTouchDistanceRef.current = getDistanceBetweenTouches(event.touches as unknown as TouchList);\n        }\n    }\n\n    const handleTouchEnd: TouchEventHandler<HTMLDivElement> = () => {\n        localStorage.setItem('terminalFontSize', `${fontSize}`);\n        lastTouchDistanceRef.current = null;\n    }\n\n    const getDistanceBetweenTouches = (touches: TouchList): number => {\n        const touch1 = touches[0];\n        const touch2 = touches[1];\n        return Math.sqrt(\n            Math.pow(touch2.pageX - touch1.pageX, 2) +\n            Math.pow(touch2.pageY - touch1.pageY, 2),\n        );\n    }\n\n    // Return the state and handlers\n    return {\n        fontSize,\n        canvasHeight,\n        handleTouchMove,\n        handleTouchStart,\n        handleTouchEnd,\n    };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useStateLogger.ts","messages":[{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":10,"column":7,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":24,"endColumn":8},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":11,"column":27,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":11,"endColumn":47,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[321,341],"text":"(prevStateRef.current != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[321,341],"text":"(prevStateRef.current ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[321,341],"text":"(Boolean(prevStateRef.current))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":19,"column":46,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":19,"endColumn":60},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":19,"column":64,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":19,"endColumn":82},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":28,"column":44,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":28,"endColumn":58},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":28,"column":62,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":28,"endColumn":82}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useRef, useEffect } from 'react';\n\nexport function useStateLogger<T>(state: T, name: string): void {\n  const prevStateRef = useRef<string | null>(null);\n\n  useEffect(() => {\n    try {\n      const currentState = JSON.stringify(state);\n\n      if (prevStateRef.current !== currentState) {\n        const prevState = prevStateRef.current ? JSON.parse(prevStateRef.current) as T : {} as T;\n        const stateChangeLog = {\n          from: prevState,\n          to: state\n        };\n\n        // Log error without using console.log\n        const logMessage = `[${name}] State changed: ${JSON.stringify(stateChangeLog, null, 2)}`;\n        if (typeof window !== 'undefined' && window.console && window.console.log) {\n          window.console.log(logMessage);\n        }\n\n        prevStateRef.current = currentState;\n      }\n    } catch (error) {\n      // Silent error handling to prevent breaking the application\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error in state logging';\n      if (typeof window !== 'undefined' && window.console && window.console.error) {\n        window.console.error(`[${name}] State logging error:`, errorMessage);\n      }\n    }\n  }, [state, name]);\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useTerminal.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useTutorials.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useWPMCaculator.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":29,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":29,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[843,851],"text":"(current == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":29,"column":24,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":29,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[855,864],"text":"(previous == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/hooks/useWPMCalculator.ts\n\nimport { useComputed } from '@preact/signals-react';\nimport { useCallback } from 'react';\n\nimport { keystrokesSignal, addKeystroke, clearKeystrokes } from 'src/signals/commandLineSignals';\n\nimport { type WPM, type WPMs } from '../types/Types';\n\n\nexport const useWPMCalculator = (): {\n  addKeystroke: (char: string) => void;\n  getWPMs: () => WPMs;\n  clearKeystrokes: () => void;\n  keystrokeCount: number;\n} => {\n  const keystrokes = useComputed(() => keystrokesSignal.value);\n\n\n  const getWPMs = useCallback((): WPMs => {\n    if (keystrokes.value.length < 2) return { wpmAverage: 0, charWpms: [] };\n\n    const charWpms: WPM[] = [];\n    let totalWPM = 0;\n\n    for (let i = 1; i < keystrokes.value.length; i++) {\n      const current = keystrokes.value[i];\n      const previous = keystrokes.value[i-1];\n      if (!current || !previous) continue;\n\n      const duration = current.timestamp - previous.timestamp;\n      const minutes = duration / 60000; // Convert to minutes\n      const cpm = 1 / minutes; // 1 character per minute.\n      const wpm = cpm / 5; // five character words per minute.\n\n      charWpms.push({\n        character: current.char,\n        wpm,\n        durationMilliseconds: duration\n      });\n\n      totalWPM += wpm;\n    }\n\n    const wpmAverage = totalWPM / (keystrokes.value.length - 1);\n\n    return {\n      wpmAverage,\n      charWpms: Object.freeze(charWpms) // Make charWpms immutable\n    };\n  }, [keystrokes]);\n\n  return {\n    addKeystroke,\n    getWPMs, // Return the memoized value\n    clearKeystrokes,\n    keystrokeCount: keystrokes.value.length // Add this for debugging\n  };\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/providers/QueryProvider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/signals/appSignals.ts","messages":[{"ruleId":"no-param-reassign","severity":1,"message":"Assignment to function parameter 'element'.","line":104,"column":13,"nodeType":"Identifier","messageId":"assignmentToFunctionParam","endLine":104,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/signals/appSignals.ts\ndeclare global {\n  interface Window {\n    setActivity: typeof setActivity;\n    ActivityType: typeof ActivityType;\n  }\n}\n\nimport { computed, signal } from '@preact/signals-react';\n\nimport { ActivityType, type OutputElement } from 'src/types/Types';\nimport { createLogger, LogLevel } from 'src/utils/Logger';\nimport { createPersistentSignal } from 'src/utils/signalPersistence';\n\nconst logger = createLogger({\n  prefix: 'AppSignals',\n  level: LogLevel.DEBUG\n});\n\nconst currentOutputKey = 'current-output';\nexport const activitySignal = signal<ActivityType>(ActivityType.NORMAL);\nexport const notificationSignal = signal<string | null>(null);\nexport const isEditModeSignal = signal<boolean>(false);\nexport const isShowVideoSignal = signal<boolean>(false);\nexport const isInLoginProcessSignal = signal<boolean>(false);\nexport const isInSignUpProcessSignal = signal<boolean>(false);\nexport const tempUserNameSignal = signal<string>('');\nexport const tempPasswordSignal = signal<string>('');\nexport const tempEmailSignal = signal<string>('');\n\nexport const setIsInSignUpProcess = (value: boolean): void => {\n    isInSignUpProcessSignal.value = value;\n};\n\nexport const setTempEmail = (value: string): void => {\n    tempEmailSignal.value = value;\n};\n\nexport const toggleVideo = (): boolean => {\n    isShowVideoSignal.value = !isShowVideoSignal.value;\n    return isShowVideoSignal.value;\n};\n\nexport const setIsInLoginProcess = (value: boolean): void => {\n    isInLoginProcessSignal.value = value;\n};\n\nexport const setTempUserName = (value: string): void => {\n    tempUserNameSignal.value = value;\n};\n\nexport const setTempPassword = (value: string): void => {\n    tempPasswordSignal.value = value;\n};\n\n// Create a persistent signal for bypassTutorial\nexport const {\n    signal: bypassTutorialSignal,\n    update: setBypassTutorial\n} = createPersistentSignal<boolean>({\n    key: 'bypassTutorialKey', // Unique key for localStorage\n    signal: signal<boolean>(false),\n    serialize: (value: boolean) => JSON.stringify(value),\n    deserialize: (value: string) => JSON.parse(value) as boolean\n});\n\nconst {\n    signal: outputElementsSignal,\n    update: updateOutput\n} = createPersistentSignal<OutputElement[]>({\n    key: currentOutputKey,\n    signal: signal<OutputElement[]>([]),\n    serialize: (value: OutputElement[]) => JSON.stringify(value),\n    deserialize: (value: string) => JSON.parse(value) as OutputElement[]\n});\n\nexport { outputElementsSignal };\n\nexport const isInGameModeSignal = computed(() => activitySignal.value === ActivityType.GAME);\nexport const isInTutorialModeSignal = computed(() => activitySignal.value === ActivityType.TUTORIAL);\n\nimport { navigate } from 'src/utils/navigationUtils';\n\nexport const setActivity = (activity: ActivityType): void => {\n    activitySignal.value = activity;\n    logger.debug(ActivityType[activitySignal.value]);\n    navigate({\n        activityKey: activity,\n        contentKey: null,\n        groupKey: null\n    });\n};\n\nexport const appendToOutput = (element: OutputElement): void => {\n    updateOutput(prevOutput => {\n        // If the command is sensitive, mask the args except the first one (username)\n        if (element.sensitive != null && element.command != null) {\n            const maskedCommand = {\n                ...element.command,\n                args: element.command.args.map((arg, index) =>\n                    index === 0 ? arg : '*'.repeat(arg.length)\n                )\n            };\n            element = { ...element, command: maskedCommand };\n        }\n        const newOutput = [...prevOutput, element].slice(-3);\n        return newOutput;\n    });\n};\n\nexport const setNotification = (notification: string): void => {\n    notificationSignal.value = notification;\n};\n\nexport const isLoggedInSignal = signal<boolean>(false);\nexport const userNameSignal = signal<string | null>(null);\n\nexport const setIsLoggedIn = (value: boolean): void => {\n    isLoggedInSignal.value = value;\n};\n\nexport const setUserName = (name: string | null): void => {\n    userNameSignal.value = name;\n};\n\n// Expose activity functions on window for testing\nif (typeof window != 'undefined') {\n    window.setActivity = setActivity;\n    window.ActivityType = ActivityType;\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/signals/commandLineSignals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/signals/gameSignals.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":80,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":80,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2985,3000],"text":"storedTutorials != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2985,3000],"text":"storedTutorials ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2985,3000],"text":"Boolean(storedTutorials)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\n// gameSignals.ts\nimport { signal } from \"@preact/signals-react\";\n\nimport { type ActionType } from \"src/game/types/ActionTypes\";\nimport { type GamePhrase, Phrases } from \"src/types/Types\";\nimport { createPersistentSignal } from \"src/utils/signalPersistence\";\n\nexport const startGameSignal = signal<string | undefined>(undefined);\nexport const gamePhraseSignal = signal<GamePhrase | null>(null);\nexport const gameInitSignal = signal<boolean>(false);\nexport const isInGameModeSignal = signal<boolean>(false);\nexport const currentGamePhraseSignal = signal<GamePhrase | null>(null);\nexport const gameLevelSignal = signal<number | null>(null);\nexport const heroActionSignal = signal<ActionType>('Idle');\nexport const zombie4ActionSignal = signal<ActionType>('Walk');\n\nconst completedGamePhrasesKey = 'completed-game-phrases';\n\nexport const setHeroAction = (action: ActionType): void => {\n  heroActionSignal.value = action;\n};\n\nexport const setZombie4Action = (action: ActionType): void => {\n  zombie4ActionSignal.value = action;\n};\n\nexport const setGameLevel = (level: number): void => {\n  gameLevelSignal.value = level;\n};\n\nconst { signal: completedGamePhrasesSignal, update: updateCompletedGamePhrases } = createPersistentSignal<Set<string>>({\n  key: completedGamePhrasesKey,\n  signal: signal<Set<string>>(new Set()),\n  serialize: (value: Set<string>) => JSON.stringify([...value]),\n  deserialize: (value: string) => new Set(JSON.parse(value) as string[]),\n});\n\nexport { completedGamePhrasesSignal };\n\nexport const setCompletedGamePhrase = (gamePhraseId: string): void => {\n  updateCompletedGamePhrases(prev => prev.add(gamePhraseId));\n}\n\nexport const getIncompletePhrasesByTutorialGroup = (tutorialGroup: string): GamePhrase[] => {\n  const gamePhrasesInGroup = Phrases.filter(p => p.tutorialGroup === tutorialGroup && p.displayAs === 'Game');\n  const incompletePhrasesInGroup = gamePhrasesInGroup\n    .filter(pig => !Array.from(completedGamePhrasesSignal.value).includes(pig.key))\n  return incompletePhrasesInGroup;\n}\n\nexport const getNextGamePhrase = (): GamePhrase | null => {\n  const nextGamePhrase = Phrases\n    .find(t => !completedGamePhrasesSignal.value.has(t.key));\n  if (nextGamePhrase === undefined) {\n    return null;\n  }\n  return nextGamePhrase;\n};\n\nexport const initializeGame = (tutorialGroup?: string, contentKey?: string | null): void => {\n  gameInitSignal.value = true;\n  isInGameModeSignal.value = true;\n  if (tutorialGroup != null) {\n    const tutorialGroupGamePhrase = contentKey != null ? Phrases.filter(p => p.key === contentKey) :\n      getIncompletePhrasesByTutorialGroup(tutorialGroup);\n    if (tutorialGroupGamePhrase.length > 0) {\n      gamePhraseSignal.value = tutorialGroupGamePhrase[0] ?? null;\n    }\n  }\n};\n\nexport const setGamePhrase = (phrase: GamePhrase | null): void => {\n  gamePhraseSignal.value = phrase;\n};\n\n// Load initial state\nconst loadInitialState = (): void => {\n  const storedTutorials = localStorage.getItem(completedGamePhrasesKey);\n  if (storedTutorials) {\n    try {\n      const parsedTutorials = JSON.parse(storedTutorials) as string[];\n      completedGamePhrasesSignal.value = new Set(parsedTutorials);\n    } catch (error) {\n      console.error('Failed to parse stored tutorials:', error);\n      completedGamePhrasesSignal.value = new Set();\n    }\n  }\n  setGamePhrase(getNextGamePhrase());\n};\n\nloadInitialState();\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/signals/treeViewSignals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/signals/tutorialSignals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/terminal-data.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/test-utils/canvasMock.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/test-utils/canvasMock.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":27,"column":9,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":27,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { vi, type Mock } from 'vitest';\n\ninterface MockCanvasContext {\n  fillRect: Mock<any, any>;\n  clearRect: Mock<any, any>;\n  drawImage: Mock<any, any>;\n  beginPath: Mock<any, any>;\n  closePath: Mock<any, any>;\n  stroke: Mock<any, any>;\n  fill: Mock<any, any>;\n}\n\nexport const createMockCanvasContext = (): MockCanvasContext => {\n  return {\n    fillRect: vi.fn(),\n    clearRect: vi.fn(),\n    drawImage: vi.fn(),\n    beginPath: vi.fn(),\n    closePath: vi.fn(),\n    stroke: vi.fn(),\n    fill: vi.fn(),\n  };\n};\n\nconst createRestoreOriginalGetContext = (originalGetContext: typeof HTMLCanvasElement.prototype.getContext): (() => void) => {\n  const restoreOriginalGetContext = (): void => {\n    if (originalGetContext) {\n      Object.defineProperty(HTMLCanvasElement.prototype, 'getContext', {\n        value: originalGetContext,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      const canvasProto = HTMLCanvasElement.prototype as { getContext?: unknown };\n      delete canvasProto.getContext;\n    }\n  };\n  return restoreOriginalGetContext;\n}\n\nexport const setupCanvasMock = (): {\n  mockGetContext: Mock<any, any>;\n  restoreOriginalGetContext: () => void;\n} => {\n  const originalGetContext = HTMLCanvasElement.prototype.getContext.bind(HTMLCanvasElement.prototype);\n  const mockGetContext = vi.fn(() => createMockCanvasContext());\n\n  Object.defineProperty(HTMLCanvasElement.prototype, 'getContext', {\n    value: mockGetContext,\n    configurable: true,\n    writable: true\n  });\n\n  return {\n    mockGetContext,\n    restoreOriginalGetContext: createRestoreOriginalGetContext(originalGetContext)\n  };\n};\n\nexport type CanvasMock = ReturnType<typeof setupCanvasMock>;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/test-utils/setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/test-utils/test-utils.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/types/HandTerm.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/types/Signals.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/types/TerminalTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/types/Types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/types/elements.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/types/importMeta.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/types/monaco-vim.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/types/testing-library__jest-dom.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/types/window.d.ts","messages":[{"ruleId":"@typescript-eslint/no-redundant-type-constituents","severity":2,"message":"'any' overrides all other types in this union type.","line":7,"column":33,"nodeType":"TSTypeReference","messageId":"overrides","endLine":7,"endColumn":41}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { ActivityType } from '../constants/ActivityType';\nimport type { Tutorial } from './Types';\n\ndeclare global {\n  interface Window {\n    setActivity: (activity: ActivityType) => void;\n    setNextTutorial: (tutorial: Tutorial | null) => void;\n  }\n}\n\nexport {};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/GamePhrases.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":124,"column":50,"nodeType":"ChainExpression","messageId":"conditionErrorObject","endLine":124,"endColumn":71}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type GamePhrase, type MyResponse, Phrases } from \"../types/Types\";\n\ninterface PhraseAchievement {\n    wpm: string;\n    phraseName: string;\n}\n\nconst standardChars = /^[a-zA-Z0-9\\s'\";:.!,?]+$/;\n\nexport default class GamePhrases {\n    /**\n     * Gets a game phrase by its key\n     * @param key - The phrase key to search for\n     * @returns The matching GamePhrase or null if not found\n     */\n    public static getGamePhraseByKey(key: string): GamePhrase | null {\n        const phrase = Phrases.find(x => x.key == key);\n        if (phrase != null) {\n            // Return specified phrase, if it exists.\n            return phrase;\n        }\n        // Else, return first phrase.\n        return this.getGamePhraseByIndex(0);\n    }\n\n    /**\n     * Gets game phrases by tutorial group\n     * @param tutorialGroup - The tutorial group to filter by\n     * @returns Array of matching GamePhrases\n     */\n    public static getGamePhrasesByTutorialGroup(tutorialGroup: string): GamePhrase[] {\n        const phrases = Phrases.filter(p => tutorialGroup.includes(p.tutorialGroup ?? 'exclude'))\n        return phrases;\n    }\n\n    /**\n     * Validates all game phrases for standard characters\n     * @returns MyResponse containing validation results\n     */\n    public checkGamePhrases(): MyResponse<string[]> {\n        const response: MyResponse<string[]> = {\n            status: 200,\n            message: '',\n            data: [],\n            error: []\n        };\n        Phrases.forEach((phrase, index) => {\n            if (!standardChars.test(phrase.value)) {\n                response.error.push(`Phrase at index ${index} contains non-standard characters: ${phrase.value}`);\n                response.status = 400;\n            }\n        });\n        return response;\n    }\n\n    /**\n     * Gets a game phrase by its index\n     * @param index - The index of the phrase to retrieve\n     * @returns The GamePhrase at the specified index or null if invalid\n     */\n    public static getGamePhraseByIndex(index: number): GamePhrase | null {\n        if (index >= 0 && index < Phrases.length && Phrases[index] != null) {\n            return Phrases[index];\n        }\n        if (index < 0 && Phrases[0] != null) return Phrases[0];\n        if (index >= Phrases.length && Phrases[Phrases.length - 1] != null){\n             return Phrases[Phrases.length - 1] ?? null;\n        }\n        if (Phrases[0] != null) return Phrases[0];\n        throw new Error('No phrases available');\n    }\n\n    /**\n     * Gets a game phrase by its value\n     * @param phrase - The phrase text to search for\n     * @returns The matching GamePhrase or null if not found\n     */\n    public static getGamePhraseByValue(phrase: string): GamePhrase | null {\n        const result = Phrases.find(p => p.value === phrase)\n        return result ?? null;\n    }\n\n    /**\n     * Gets all game phrase names\n     * @returns Array of phrase names\n     */\n    public static getGamePhraseNames(): string[] {\n        return Phrases.map(x => x.key);\n    }\n\n    /**\n     * Gets a random game phrase\n     * @returns A random phrase value\n     * @throws Error if no phrases are available\n     */\n    public static getRandomGamePhrase(): string {\n        const phrasesLength = Phrases.length;\n        if (phrasesLength === 0) throw new Error('No phrases available');\n        const randomKey = Math.floor(Math.random() * phrasesLength);\n        const phrase = Phrases[randomKey];\n        if (phrase == null) throw new Error('Invalid phrase index');\n        return phrase.value;\n    }\n\n    /**\n     * Gets achieved phrases from localStorage\n     * @returns Array of PhraseAchievement objects\n     */\n    public static getGamePhrasesAchieved(): PhraseAchievement[] {\n        const storedPhrasesAchieved = localStorage.getItem('phrasesAchieved');\n\n        try {\n            const parsedPhrases: string[] = JSON.parse(storedPhrasesAchieved ?? '[]') as string[];\n            return parsedPhrases.map((phrase: string) => {\n                const [wpm, phraseName] = phrase.split(':');\n                return {\n                    wpm: wpm ?? '',\n                    phraseName: phraseName ?? ''\n                };\n            });\n        } catch (error: unknown) {\n            // Log error without using console.error\n            const errorMessage = error instanceof Error ? error.message : 'Unknown parsing error';\n            if (typeof window !== 'undefined' && window.console?.error) {\n                window.console.error('Error parsing phrases achieved:', errorMessage);\n            }\n            return [];\n        }\n    }\n\n    /**\n     * Resets achieved phrases in localStorage\n     */\n    public static resetGamePhrasesAchieved(): void {\n        localStorage.removeItem('phrasesAchieved');\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/Logger.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":44,"column":42,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":44,"endColumn":56}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3,\n  SILENT = 4\n}\n\ninterface LoggerConfig {\n  level?: LogLevel;\n  prefix?: string;\n  logToConsole?: boolean;\n  logToFile?: boolean;\n}\n\nclass Logger {\n  private config: LoggerConfig;\n\n  constructor(config: Partial<LoggerConfig> = {}) {\n    this.config = {\n      level: config.level ?? LogLevel.INFO,\n      prefix: config.prefix ?? 'HandTerm',\n      logToConsole: config.logToConsole ?? true,\n      logToFile: config.logToFile ?? false\n    };\n  }\n\n  private log<T extends unknown[]>(level: LogLevel, message: string, ...args: T): void {\n    if (this.config.level !== undefined && level < this.config.level) return;\n\n    const timestamp = new Date().toISOString();\n    const formattedMessage = `[${timestamp}] [${this.config.prefix}] [${LogLevel[level]}] ${message}`;\n\n    if (this.config.logToConsole === true) {\n      this.safeConsoleLog(level, formattedMessage, ...args);\n    }\n\n    if (this.config.logToFile === true) {\n      this.writeToLogFile(formattedMessage, ...args);\n    }\n  }\n\n  private safeConsoleLog<T extends unknown[]>(level: LogLevel, formattedMessage: string, ...args: T): void {\n    if (typeof window !== 'undefined' && window.console) {\n      switch (level) {\n        case LogLevel.DEBUG:\n          window.console.log(formattedMessage, ...args);\n          break;\n        case LogLevel.INFO:\n          window.console.info(formattedMessage, ...args);\n          break;\n        case LogLevel.WARN:\n          window.console.warn(formattedMessage, ...args);\n          break;\n        case LogLevel.ERROR:\n          window.console.error(formattedMessage, ...args);\n          break;\n      }\n    }\n  }\n\n  private writeToLogFile<T extends unknown[]>(_message: string, ..._args: T): void {\n    // Implement file logging logic if needed\n    // This could write to a log file in the application's data directory\n    // Placeholder for future implementation\n  }\n\n  public debug(message: string, ...args: unknown[]): void {\n    this.log(LogLevel.DEBUG, message, ...args);\n  }\n\n  public info(message: string, ...args: unknown[]): void {\n    this.log(LogLevel.INFO, message, ...args);\n  }\n\n  public warn(message: string, ...args: unknown[]): void {\n    this.log(LogLevel.WARN, message, ...args);\n  }\n\n  public error(message: string, ...args: unknown[]): void {\n    this.log(LogLevel.ERROR, message, ...args);\n  }\n}\n\nfunction createLogger(config?: Partial<LoggerConfig>): Logger {\n  return new Logger(config);\n}\n\nexport { Logger, LogLevel, createLogger };\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/Phrase.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":12,"column":13,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":12,"endColumn":18},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":16,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":16,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[540,549],"text":"value[0] == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[541,549],"text":"(value[0] ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[540,549],"text":"!Boolean(value[0])"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":37,"column":17,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":37,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1029,1043],"text":"foundChordHTML != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":41,"column":17,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":41,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1200,1205],"text":"chord != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":48,"column":14,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":48,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1389,1400],"text":"foundChord == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":72,"column":17,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":72,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2459,2471],"text":"(chordElement != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":72,"column":33,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":72,"endColumn":43,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2475,2485],"text":"(foundChord != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { allChords } from \"../allChords\";\nimport { type Chord } from \"../types/Types\";\n\nimport { createHTMLElementFromHTML } from \"./dom\";\n\nexport class Phrase {\n    private internalValue: string[];\n    private internalChords: Chord[] = [];\n    private internalChordsHTML: HTMLElement[] = [];\n\n    constructor(value: string[]) {\n        if(!value || !Array.isArray(value) || value.length == 0){\n            throw new Error('Phrase value must be an array with at least one element');\n        }\n        this.internalValue = value;\n        if(!value[0]) return;\n        if (Array.isArray(value)) {\n            this.setChords(value);\n        }\n    }\n\n    get value(): string[] {\n        return this.internalValue;\n    }\n\n    get chordsHTML(): HTMLElement[] {\n        return this.internalChordsHTML;\n    }\n\n    get chords(): Chord[] {\n        return this.internalChords;\n    }\n\n    private setChords(keys: string[]): void {\n        keys.forEach((key) => {\n            const foundChordHTML = Phrase.findChordHTML(key);\n            if (foundChordHTML) {\n                this.internalChordsHTML.push(foundChordHTML);\n            }\n            const chord = allChords.find(x => x.key == key);\n            if (chord) {\n                this.internalChords.push(chord);\n            }\n        })\n    }\n\n    public static createChordHTML(foundChord: Chord | undefined): HTMLElement | null {\n        if (!foundChord) return null;\n        return createHTMLElementFromHTML(\n            `<div class=\"col-sm-2 row generated\" id=\"chord2\">\n                <span id=\"char${foundChord.index}\">${foundChord.key}</span>\n                <img loading=\"lazy\" alt=\"2\" src=\"/images/svgs/${foundChord.chordCode}.svg\" width=\"100\" class=\"hand\">\n            </div>`\n        )\n    }\n\n    public static findChordHTML(chordChar: string): HTMLElement | null {\n        let inChord: HTMLElement | null = null;\n        const foundChords\n            = Array.from(allChords)\n                .filter(x => {\n                    return x.key\n                        .replace('&#x2581;', ' ')\n                        .replace('(underscore)', '_')\n                        // .replace('Return (ENTER)', '\\r')\n                        == chordChar;\n                });\n        // Load the clone in Chord order into the wholePhraseChords div.\n        if (foundChords.length > 0) {\n            const foundChord = foundChords[0];\n            const chordElement = this.createChordHTML(foundChord);\n            if (chordElement && foundChord) {\n                chordElement.setAttribute(\"name\", foundChord.key.replace('(', '').replace(')', '').replace(' ', '-'));\n                inChord = chordElement;\n            }\n        }\n        // Removed console.error statement\n        return inChord;\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/WebCam.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":13,"column":14,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":13,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[352,365],"text":"videoElement == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":30,"column":25,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":30,"endColumn":37},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":38,"column":17,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":38,"endColumn":39,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1258,1280],"text":"videoElement.srcObject != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":48,"column":17,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":48,"endColumn":29},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":48,"column":33,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":48,"endColumn":55,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1599,1621],"text":"(videoElement.srcObject != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type React from 'react';\r\nimport { useRef, useEffect } from 'react';\r\n\r\nexport interface WebCamProps {\r\n    setOn: boolean;\r\n}\r\n\r\nconst WebCam: React.FC<WebCamProps> = ({ setOn }): JSX.Element => {\r\n    const videoRef = useRef<HTMLVideoElement | null>(null);\r\n\r\n    useEffect(() => {\r\n        const videoElement = videoRef.current;\r\n        if (!videoElement) return;\r\n\r\n        videoElement.autoplay = true;\r\n        videoElement.muted = true;\r\n        videoElement.id = 'terminal-video';\r\n        videoElement.setAttribute('playsinline', '');\r\n        videoElement.setAttribute('webkit-playsinline', '');\r\n        videoElement.setAttribute('x5-playsinline', '');\r\n\r\n        if (setOn) {\r\n            navigator.mediaDevices\r\n                .getUserMedia({\r\n                    video: {\r\n                        facingMode: 'environment'\r\n                    }\r\n                })\r\n                .then((stream: MediaStream) => {\r\n                    if (videoElement) {\r\n                        videoElement.srcObject = stream;\r\n                    }\r\n                })\r\n                .catch((error: Error) => {\r\n                    console.error('Error accessing media devices:', error);\r\n                });\r\n        } else {\r\n            if (videoElement.srcObject) {\r\n                const tracks = (videoElement.srcObject as MediaStream).getTracks();\r\n                tracks.forEach(track => track.stop());\r\n                videoElement.srcObject = null;\r\n            }\r\n        }\r\n\r\n        videoElement.hidden = !setOn;\r\n\r\n        return () => {\r\n            if (videoElement && videoElement.srcObject) {\r\n                const tracks = (videoElement.srcObject as MediaStream).getTracks();\r\n                tracks.forEach(track => {\r\n                    track.stop();\r\n                    track.enabled = false;\r\n                });\r\n                videoElement.srcObject = null;\r\n            }\r\n        };\r\n    }, [setOn]);\r\n\r\n    return (\r\n      <video ref={videoRef} style={{ width: '100%', height: 'auto' }}>\r\n        <track kind=\"captions\" src=\"\" label=\"No captions available\" />\r\n      </video>\r\n    );\r\n};\r\n\r\nexport default WebCam;\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/apiClient.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":91,"column":14,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":91,"endColumn":26},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":91,"column":62,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":91,"endColumn":79,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1968,1986],"text":"(authResponse.data == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":100,"column":14,"nodeType":"Identifier","messageId":"conditionErrorString","endLine":100,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[2231,2243],"text":"accessToken.length === 0"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[2231,2243],"text":"accessToken === \"\""},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2231,2243],"text":"!Boolean(accessToken)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":127,"column":17,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":127,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2920,2934],"text":"error.response != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":153,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":153,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3899,3903],"text":"(path != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3899,3903],"text":"(path ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3899,3903],"text":"(Boolean(path))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":154,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":154,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3930,3933],"text":"(sha != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3930,3933],"text":"(sha ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3930,3933],"text":"(Boolean(sha))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios from 'axios';\n\nimport { type IAuthProps } from '../hooks/useAuth';\nimport ENDPOINTS from '../shared/endpoints.json';\n\nimport { createLogger } from './Logger';\n\nconst logger = createLogger();\n\nexport interface APIResponse<T> {\n    status: number;\n    data?: T;\n    error?: string;\n}\n\nexport interface FileContentResponse {\n    content: string;\n    encoding?: string;\n    sha?: string;\n    size?: number;\n}\n\nexport interface TreeItemResponse {\n    path: string;\n    type: string;\n    sha?: string;\n    size?: number;\n}\n\nexport interface RepoResponse {\n    name: string;\n    description?: string;\n    private: boolean;\n    default_branch: string;\n}\n\nexport interface SaveRepoFileResponse {\n    commit: {\n        sha: string;\n        url: string;\n    };\n    content: {\n        sha: string;\n    };\n}\n\nexport interface DeviceCodeResponse {\n    device_code: string;\n    user_code: string;\n    verification_uri: string;\n    expires_in: number;\n    interval: number;\n}\n\nexport interface DevicePollResponse {\n    status: 'pending' | 'complete' | 'error';\n    access_token?: string;\n    token_type?: string;\n    scope?: string;\n    message?: string;\n    error?: string;\n    error_description?: string;\n}\n\ninterface ErrorResponse {\n    message?: string;\n}\n\nfunction isErrorResponse(obj: unknown): obj is ErrorResponse {\n    return typeof obj === 'object' && obj !== null && 'message' in obj;\n}\n\n// Create axios instance with base configuration\nconst api = axios.create({\n    baseURL: ENDPOINTS.api.BaseUrl,\n    headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n    }\n});\n\nexport async function makeAuthenticatedRequest<T>(\n    auth: IAuthProps,\n    endpoint: string,\n    params?: Record<string, string>,\n    method: 'GET' | 'POST' = 'GET',\n    data?: unknown\n): Promise<APIResponse<T>> {\n    try {\n        const authResponse = await auth.validateAndRefreshToken();\n        if (!authResponse || authResponse.status !== 200 || !authResponse.data) {\n            return {\n                status: 401,\n                error: 'Authentication failed'\n            };\n        }\n\n        // Get access token from auth response\n        const accessToken = authResponse.data.accessToken;\n        if (!accessToken) {\n            return {\n                status: 401,\n                error: 'Access token not found'\n            };\n        }\n\n        const response = await api({\n            method,\n            url: endpoint,\n            headers: {\n                'Authorization': `Bearer ${accessToken}`\n            },\n            params,\n            data\n        });\n\n        return {\n            status: response.status,\n            data: response.data as T\n        };\n    } catch (error: unknown) {\n        if (error instanceof Error) {\n            logger.error(`API request failed: ${error.message}`);\n        }\n\n        if (axios.isAxiosError<ErrorResponse>(error)) {\n            if (error.response) {\n                const responseData = error.response.data;\n                const message = isErrorResponse(responseData) && typeof responseData.message === 'string'\n                    ? responseData.message\n                    : `Request failed with status ${error.response.status}`;\n                return {\n                    status: error.response.status,\n                    error: message\n                };\n            }\n            return {\n                status: 500,\n                error: typeof error.message === 'string' ? error.message : 'Request failed'\n            };\n        }\n\n        return {\n            status: 500,\n            error: 'An unknown error occurred'\n        };\n    }\n}\n\nexport async function getRepoTree(auth: IAuthProps, repo: string, path?: string, sha?: string): Promise<APIResponse<TreeItemResponse[]>> {\n    return makeAuthenticatedRequest<TreeItemResponse[]>(auth, ENDPOINTS.api.GetRepoTree, {\n        repo,\n        ...(path && { path }),\n        ...(sha && { sha })\n    });\n}\n\nexport async function getFileContent(auth: IAuthProps, repo: string, path: string): Promise<APIResponse<FileContentResponse>> {\n    // Use the same getRepoTree endpoint - it handles both tree and file content\n    return makeAuthenticatedRequest<FileContentResponse>(auth, ENDPOINTS.api.GetRepoTree, {\n        repo,\n        path\n    });\n}\n\nexport async function saveRepoFile(\n    auth: IAuthProps,\n    repo: string,\n    path: string,\n    content: string,\n    message: string\n): Promise<APIResponse<SaveRepoFileResponse>> {\n    return makeAuthenticatedRequest<SaveRepoFileResponse>(\n        auth,\n        ENDPOINTS.api.SaveRepoFile,\n        { repo, path, message },\n        'POST',\n        content\n    );\n}\n\nexport async function listRecentRepos(auth: IAuthProps): Promise<APIResponse<RepoResponse[]>> {\n    return makeAuthenticatedRequest<RepoResponse[]>(auth, ENDPOINTS.api.ListRecentRepos);\n}\n\nexport async function unlinkGitHub(auth: IAuthProps): Promise<APIResponse<{ message: string }>> {\n    return makeAuthenticatedRequest<{ message: string }>(\n        auth,\n        ENDPOINTS.api.UnlinkGitHub,\n        undefined,\n        'POST'\n    );\n}\n\nexport async function getGitHubDeviceCode(\n    auth: IAuthProps\n): Promise<APIResponse<DeviceCodeResponse>> {\n    return makeAuthenticatedRequest<DeviceCodeResponse>(\n        auth,\n        ENDPOINTS.api.GitHubDeviceCode,\n        undefined,\n        'POST'\n    );\n}\n\nexport async function pollGitHubDeviceAuth(\n    auth: IAuthProps,\n    deviceCode: string\n): Promise<APIResponse<DevicePollResponse>> {\n    return makeAuthenticatedRequest<DevicePollResponse>(\n        auth,\n        ENDPOINTS.api.GitHubDevicePoll,\n        undefined,\n        'POST',\n        { device_code: deviceCode }\n    );\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/commandUtils.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":79,"column":15,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":79,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3105,3113],"text":"(nextPart != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3105,3113],"text":"(nextPart ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3105,3113],"text":"(Boolean(nextPart))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { LogKeys } from \"../types/TerminalTypes\";\nimport { type ParsedCommand } from \"../types/Types\";\n\nexport const commandTextToHTML = (text: string): string => {\n  return text.replace(/\\n/g, '<br/>');\n};\n\nexport const loadCommandHistory = (): string[] => {\n  const storedHistory = localStorage.getItem(LogKeys.commandHistory ?? '') ?? '[]';\n  try {\n    const parsedHistory = JSON.parse(storedHistory) as unknown;\n    // If it's an array of strings, return it directly\n    if (Array.isArray(parsedHistory) && parsedHistory.every((item): item is string => typeof item === 'string')) {\n      return parsedHistory;\n    }\n    // If it's an array of ParsedCommand, convert to strings\n    if (Array.isArray(parsedHistory) && parsedHistory.every((item): item is ParsedCommand =>\n      typeof item === 'object' && item !== null && 'command' in item\n    )) {\n      return parsedHistory.map(parsedCommandToString);\n    }\n    // If parsing fails or is invalid, return an empty array\n    return [];\n  } catch {\n    return [];\n  }\n}\n\nexport const saveCommandHistory = (commandHistory: string[]): void => {\n  if (LogKeys.commandHistory != null)\n    localStorage.setItem(LogKeys.commandHistory ?? '', JSON.stringify(commandHistory));\n}\n\nexport function parsedCommandToString(cmd: ParsedCommand): string {\n  const argsStr = cmd.args != null ? cmd.args.join(' ') : '';\n  const switchesStr = cmd.switches == null ? '' : Object.entries(cmd.switches)\n    .map(([key, value]) => {\n      if (typeof value === 'boolean') {\n        return value ? `-${key}` : '';\n      }\n      return `-${key} ${value}`;\n    })\n    .filter(s => s)\n    .join(' ');\n\n  return [cmd.command, argsStr, switchesStr]\n    .filter(s => s)\n    .join(' ')\n    .trim();\n}\n\nfunction isSwitch(part: string): boolean {\n  return part.substring(0, 1) === '--'  || (part.startsWith('-') && part.length === 2);\n}\n\nexport const parseCommand = (input: string): ParsedCommand => {\n  const parts = input.split(/\\s+/).filter(Boolean); // Split by whitespace and remove empty strings\n  const command = parts.shift() ?? ''; // The first element is the command\n  const args: string[] = [];\n  const switches: Record<string, boolean | string> = {};\n\n  for (let i = 0; i < parts.length; i++) {\n    const part: string | undefined = parts[i];\n    if (part === undefined) continue;\n    if (part == null) continue; // Skip if undefined (shouldn't happen due to filter)\n    if (isSwitch(part)) {\n      const switchAssignmentIndex = part.indexOf('=');\n      if (switchAssignmentIndex > -1) {\n        // It's a switch with an explicit value\n        const switchName = part.substring(2, switchAssignmentIndex);\n        const switchValue = part.substring(switchAssignmentIndex + 1);\n        switches[switchName] = switchValue;\n      } else {\n        // It's a boolean switch or a switch with a value that's the next part\n        const switchName = part.substring(0, 2) === '--' ? part.substring(2) : part.substring(1);\n        // Look ahead to see if the next part is a value for this switch\n        if (i + 1 < parts.length) {\n          const nextPart = parts[i + 1];\n          if (nextPart && !nextPart.startsWith('-')) {\n            switches[switchName] = nextPart;\n            i++; // Increment i to skip the value\n          } else {\n            switches[switchName] = true; // No value provided, treat it as a boolean switch\n          }\n        } else {\n          switches[switchName] = true; // No value provided, treat it as a boolean switch\n        }\n      }\n    } else {\n      // It's an argument\n      args.push(part);\n    }\n  }\n\n  return {\n    command,\n    args,\n    switches\n  } as const;\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/defaultUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/dom.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":4,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":4,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[183,192],"text":"className != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[183,192],"text":"className ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[183,192],"text":"Boolean(className)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nexport function createElement<T extends HTMLElement>(tagName: keyof HTMLElementTagNameMap, className?: string): T {\n    const element = document.createElement(tagName) as T;\n    if (className) {\n        element.id = className;\n        element.classList.add(className);\n    }\n    return element;\n}\n\nexport function createHTMLElementFromHTML(htmlString: string): HTMLElement {\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(htmlString, 'text/html');\n    return doc.body.firstChild as HTMLElement;\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/fileIcons.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/navigationUtils.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":10,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":10,"endColumn":13,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[385,391],"text":"pParam != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[385,391],"text":"pParam ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[385,391],"text":"Boolean(pParam)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/utils/navigationUtils.ts\nimport { ActivityType, type ParsedLocation } from 'src/types/Types';\n\n// Parse location from either pathname or ?p= parameter\nexport function parseLocation(location: string = window.location.toString()): ParsedLocation {\n  // First, check for ?p= parameter\n  const urlParams = new URL(location);\n  const pParam = urlParams.searchParams.get('p');\n\n  if (pParam) {\n    // Remove leading slash if present\n    const cleanPath = pParam.startsWith('/') ? pParam.slice(1) : pParam;\n    const [activityKey, phraseKey] = cleanPath.split('/');\n\n    return {\n      activityKey: activityKey == null ? ActivityType.NORMAL : parseActivityType(activityKey),\n      contentKey: decodeURIComponent(phraseKey ?? ''),\n      groupKey: urlParams.searchParams.get('group') ?? null\n    };\n  }\n\n  // Fallback to pathname parsing\n  const [, activityKey, phraseKey] = window.location.pathname.split('/');\n  return {\n    activityKey: activityKey == null ? ActivityType.NORMAL : parseActivityType(activityKey),\n    contentKey: decodeURIComponent(phraseKey ?? ''),\n    groupKey: urlParams.searchParams.get('group') ?? null\n  };\n}\n\n// Helper function to parse activity type\nexport function parseActivityType(activityString: string): ActivityType {\n  const normalizedActivity = (activityString ?? '').toUpperCase();\n  return ActivityType[normalizedActivity as keyof typeof ActivityType] ?? ActivityType.NORMAL;\n}\n\n// Global navigation function that can be used outside of React components\nexport function navigate(options: ParsedLocation): void {\n  const newActivity = options.activityKey ?? ActivityType.NORMAL;\n  const newPhraseKey = options.contentKey != null ? options.contentKey.replace('\\r', '_r') : null;\n  const newGroupKey = options.groupKey ?? null;\n\n  const encodedPhraseKey = newPhraseKey != null ? encodeURIComponent(newPhraseKey) : '';\n  const queryString = newGroupKey != null ? `?group=${encodeURIComponent(newGroupKey)}` : '';\n\n  const activityPath = newActivity === ActivityType.NORMAL ? '' : ActivityType[newActivity].toLowerCase();\n  const path = `/${activityPath}${newPhraseKey !== null ? `/${encodedPhraseKey}` : ''}${queryString}`;\n\n  // Use browser's history API directly\n  window.history.pushState(null, '', path);\n\n  // Dispatch a custom event to notify React router or other components about the navigation\n  window.dispatchEvent(new CustomEvent('locationchange', { detail: { path } }));\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/signalPersistence.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/timeUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/treeFormatter.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":27,"column":27,"nodeType":"Identifier","messageId":"conditionErrorString","endLine":27,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[837,848],"text":"(currentPath.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[837,848],"text":"(currentPath !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[837,848],"text":"(Boolean(currentPath))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":90,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":90,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3029,3034],"text":"(line == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3030,3034],"text":"(line ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3029,3034],"text":"(!Boolean(line))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":90,"column":19,"nodeType":"CallExpression","messageId":"conditionErrorNullableObject","endLine":90,"endColumn":48,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3038,3068],"text":"(line.match(/[▼▶]?\\s*[📁📄]/u) == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":96,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":96,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3206,3212],"text":"match == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":99,"column":20,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":99,"endColumn":50,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3274,3304],"text":"((line.match(/^\\s*/)?.[0].length) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[3274,3304],"text":"((line.match(/^\\s*/)?.[0].length) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3274,3304],"text":"(Boolean((line.match(/^\\s*/)?.[0].length)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":109,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":109,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3674,3683],"text":"prevMatch != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":110,"column":32,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":110,"endColumn":66,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3718,3752],"text":"((prevLine.match(/^\\s*/)?.[0].length) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[3718,3752],"text":"((prevLine.match(/^\\s*/)?.[0].length) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3718,3752],"text":"(Boolean((prevLine.match(/^\\s*/)?.[0].length)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"interface TreeItem {\n    path: string;\n    type: string;\n}\n\ninterface TreeState {\n    expandedFolders: Set<string>;\n}\n\nexport function formatTreeContent(items: TreeItem[], treeState: TreeState): string {\n    const sortedItems = [...items].sort((a, b) => {\n        // Directories come first\n        if (a.type === 'tree' && b.type !== 'tree') return -1;\n        if (a.type !== 'tree' && b.type === 'tree') return 1;\n        return a.path.localeCompare(b.path);\n    });\n\n    const lines: string[] = ['Repository Files', ''];\n\n    // First pass: collect all directories\n    const directories = new Set<string>();\n    sortedItems.forEach(item => {\n        const parts = item.path.split('/');\n        parts.pop(); // Remove the last part (file/dir name)\n        let currentPath = '';\n        parts.forEach(part => {\n            currentPath = currentPath ? `${currentPath}/${part}` : part;\n            directories.add(currentPath);\n        });\n    });\n\n    // Convert directories to array and sort\n    const sortedDirs = Array.from(directories).sort();\n\n    // Helper to check if path should be visible based on parent expansion state\n    const isVisible = (path: string): boolean => {\n        if (!path.includes('/')) return true;\n        const parentPath = path.split('/').slice(0, -1).join('/');\n        return treeState.expandedFolders.has(parentPath) &&\n               (parentPath.includes('/') ? isVisible(parentPath) : true);\n    };\n\n    // Build tree structure\n    sortedDirs.forEach(dir => {\n        if (isVisible(dir)) {\n            const depth = dir.split('/').length;\n            const indent = '  '.repeat(depth - 1);\n            const name = dir.split('/').pop() ?? '';\n            const isExpanded = treeState.expandedFolders.has(dir);\n            const arrow = isExpanded ? '▼' : '▶';\n            lines.push(`${indent}${arrow} 📁 ${name}/`);\n        }\n    });\n\n    // Add files under their directories\n    sortedItems.forEach(item => {\n        if (item.type !== 'tree' && isVisible(item.path)) {\n            const parts = item.path.split('/');\n            const fileName = parts.pop() ?? '';\n            const depth = parts.length;\n            const indent = '  '.repeat(depth);\n            const prefix = parts.length > 0 ? '  ' : '';\n            const icon = getFileIcon(fileName);\n            lines.push(`${indent}${prefix}${icon} ${fileName}`);\n        }\n    });\n\n    // Add navigation help\n    lines.push('');\n    lines.push('Navigation:');\n    lines.push('j: move down');\n    lines.push('k: move up');\n    lines.push('Enter: open file or toggle folder');\n    lines.push('e: close tree view');\n    lines.push('');\n\n    return lines.join('\\n');\n}\n\n// Helper function to get the item at a specific line\nexport function getItemAtLine(\n    items: TreeItem[],\n    treeState: TreeState,\n    lineNumber: number\n): { path: string; type: string; isDirectory: boolean } | null {\n    const content = formatTreeContent(items, treeState);\n    const lines = content.split('\\n');\n    const line = lines[lineNumber - 1];\n\n    if (!line || !line.match(/[▼▶]?\\s*[📁📄]/u)) {\n        return null;\n    }\n\n    // Extract path from the line\n    const match = line.match(/[▼▶]?\\s*[^\\s]+\\s+(.+?)\\/?\\s*$/u);\n    if (!match) return null;\n\n    const name = match[1];\n    const indent = line.match(/^\\s*/)?.[0].length || 0;\n    const depth = Math.floor(indent / 2);\n\n    // Reconstruct full path based on previous directory lines\n    const pathParts: string[] = [];\n    let currentDepth = 0;\n\n    for (let i = lineNumber - 2; i >= 0 && currentDepth < depth; i--) {\n        const prevLine = lines[i];\n        const prevMatch = prevLine.match(/[▼▶]?\\s*[^\\s]+\\s+(.+?)\\/\\s*$/u);\n        if (prevMatch) {\n            const prevIndent = prevLine.match(/^\\s*/)?.[0].length || 0;\n            const prevDepth = Math.floor(prevIndent / 2);\n            if (prevDepth === currentDepth) {\n                pathParts.unshift(prevMatch[1]);\n                currentDepth++;\n            }\n        }\n    }\n\n    pathParts.push(name);\n    const fullPath = pathParts.join('/');\n\n    const isDirectory = line.includes('📁');\n    return {\n        path: fullPath,\n        type: isDirectory ? 'tree' : 'blob',\n        isDirectory\n    };\n}\n\n// Helper function to get file icon based on extension\nfunction getFileIcon(fileName: string): string {\n    const ext = fileName.split('.').pop()?.toLowerCase();\n    switch (ext) {\n        case 'js':\n        case 'jsx':\n            return '📜';\n        case 'ts':\n        case 'tsx':\n            return '📘';\n        case 'json':\n            return '📋';\n        case 'md':\n            return '📝';\n        case 'html':\n            return '🌐';\n        case 'css':\n        case 'scss':\n        case 'sass':\n            return '🎨';\n        case 'py':\n            return '🐍';\n        case 'rb':\n            return '💎';\n        case 'java':\n            return '☕';\n        case 'go':\n            return '🐹';\n        case 'rs':\n            return '🦀';\n        case 'php':\n            return '🐘';\n        case 'sh':\n        case 'bash':\n            return '💻';\n        case 'yml':\n        case 'yaml':\n            return '⚙️';\n        case 'svg':\n        case 'png':\n        case 'jpg':\n        case 'jpeg':\n        case 'gif':\n            return '🖼️';\n        default:\n            return '📄';\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/typeSafetyUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/vitest-setup.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":18,"column":5,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":18,"endColumn":9,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[593,597],"text":"(data != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":62,"column":11,"nodeType":"Identifier","messageId":"conditionErrorOther","endLine":62,"endColumn":17},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":100,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":100,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3177,3183],"text":"other == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":174,"column":104,"nodeType":"Identifier","messageId":"conditionErrorNumber","endLine":174,"endColumn":109,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[5405,5410],"text":"(width !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[5405,5410],"text":"(!Number.isNaN(width))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5405,5410],"text":"(Boolean(width))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected number value in conditional. An explicit zero/NaN check is required.","line":174,"column":116,"nodeType":"Identifier","messageId":"conditionErrorNumber","endLine":174,"endColumn":122,"suggestions":[{"messageId":"conditionFixCompareZero","fix":{"range":[5417,5423],"text":"(height !== 0)"},"desc":"Change condition to check for 0 (`value !== 0`)"},{"messageId":"conditionFixCompareNaN","fix":{"range":[5417,5423],"text":"(!Number.isNaN(height))"},"desc":"Change condition to check for NaN (`!Number.isNaN(value)`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5417,5423],"text":"(Boolean(height))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import '@testing-library/jest-dom/vitest';\nimport { afterEach, vi } from 'vitest';\nimport { cleanup } from '@testing-library/react';\nimport { ImageData as CanvasImageData } from 'canvas';\n\n// Extend CanvasImageData to include colorSpace property\ninterface ExtendedImageData extends CanvasImageData {\n  colorSpace: PredefinedColorSpace;\n}\n\n// Create a type-safe ImageData constructor that matches both browser and Node.js environments\nconst createImageData = (\n  width: number,\n  height: number,\n  data?: Uint8ClampedArray\n): ExtendedImageData => {\n  const imageData = new CanvasImageData(\n    data || new Uint8ClampedArray(width * height * 4),\n    width,\n    height\n  );\n  return Object.assign(imageData, { colorSpace: 'srgb' as PredefinedColorSpace });\n};\n\n// Update ImageDataConstructor type to use ExtendedImageData\ntype ImageDataConstructorType = {\n  new(sw: number, sh: number, settings?: ImageDataSettings): ExtendedImageData;\n  new(data: Uint8ClampedArray, sw: number, sh?: number, settings?: ImageDataSettings): ExtendedImageData;\n  prototype: ExtendedImageData;\n};\n\n// Create a type-safe ImageData constructor that matches the browser API\nconst ImageDataConstructor = {\n  new: createImageData\n} as unknown as ImageDataConstructorType;\n\nglobal.ImageData = ImageDataConstructor;\n\n// Polyfill DOMMatrix if not available\nif (typeof DOMMatrix === 'undefined') {\n  class DOMMatrixPolyfill {\n    m11 = 1;\n    m12 = 0;\n    m13 = 0;\n    m14 = 0;\n    m21 = 0;\n    m22 = 1;\n    m23 = 0;\n    m24 = 0;\n    m31 = 0;\n    m32 = 0;\n    m33 = 1;\n    m34 = 0;\n    m41 = 0;\n    m42 = 0;\n    m43 = 0;\n    m44 = 1;\n    is2D = true;\n    isIdentity = true;\n\n    constructor(matrix?: string | number[]) {\n      if (matrix) {\n        const values = (typeof matrix === 'string'\n          ? matrix.split(',').map(Number)\n          : matrix).map(v => Number.isNaN(v) ? 0 : v);\n\n        this.m11 = values[0] ?? 1;\n        this.m12 = values[1] ?? 0;\n        this.m13 = values[2] ?? 0;\n        this.m14 = values[3] ?? 0;\n        this.m21 = values[4] ?? 0;\n        this.m22 = values[5] ?? 1;\n        this.m23 = values[6] ?? 0;\n        this.m24 = values[7] ?? 0;\n        this.m31 = values[8] ?? 0;\n        this.m32 = values[9] ?? 0;\n        this.m33 = values[10] ?? 1;\n        this.m34 = values[11] ?? 0;\n        this.m41 = values[12] ?? 0;\n        this.m42 = values[13] ?? 0;\n        this.m43 = values[14] ?? 0;\n        this.m44 = values[15] ?? 1;\n\n        this.isIdentity = this.m11 === 1 && this.m12 === 0 && this.m13 === 0 && this.m14 === 0 &&\n                         this.m21 === 0 && this.m22 === 1 && this.m23 === 0 && this.m24 === 0 &&\n                         this.m31 === 0 && this.m32 === 0 && this.m33 === 1 && this.m34 === 0 &&\n                         this.m41 === 0 && this.m42 === 0 && this.m43 === 0 && this.m44 === 1;\n      }\n    }\n\n    static fromFloat32Array(array: Float32Array): DOMMatrix {\n      return new DOMMatrixPolyfill([...array]) as unknown as DOMMatrix;\n    }\n\n    static fromFloat64Array(array: Float64Array): DOMMatrix {\n      return new DOMMatrixPolyfill([...array]) as unknown as DOMMatrix;\n    }\n\n    static fromMatrix(other?: DOMMatrixInit): DOMMatrix {\n      if (!other) {\n        return new DOMMatrixPolyfill() as unknown as DOMMatrix;\n      }\n\n      const values = [\n        other.m11 ?? 1, other.m12 ?? 0, other.m13 ?? 0, other.m14 ?? 0,\n        other.m21 ?? 0, other.m22 ?? 1, other.m23 ?? 0, other.m24 ?? 0,\n        other.m31 ?? 0, other.m32 ?? 0, other.m33 ?? 1, other.m34 ?? 0,\n        other.m41 ?? 0, other.m42 ?? 0, other.m43 ?? 0, other.m44 ?? 1\n      ];\n\n      return new DOMMatrixPolyfill(values) as unknown as DOMMatrix;\n    }\n  }\n\n  global.DOMMatrix = DOMMatrixPolyfill as unknown as typeof DOMMatrix;\n}\n\n// Automatically cleanup after each test\nafterEach(() => {\n  cleanup();\n});\n\ninterface MockCanvasContext extends Omit<CanvasRenderingContext2D, 'canvas' | 'getContextAttributes'> {\n  canvas: HTMLCanvasElement;\n  getContextAttributes(): CanvasRenderingContext2DSettings;\n}\n\n// Create a type-safe mock of CanvasRenderingContext2D\nconst createMockContext = (): MockCanvasContext => {\n  const baseContext = {\n    canvas: document.createElement('canvas'),\n    getContextAttributes: vi.fn().mockReturnValue({\n      alpha: true,\n      desynchronized: false,\n      colorSpace: 'srgb'\n    }),\n    globalAlpha: 1,\n    globalCompositeOperation: 'source-over',\n    fillStyle: '#000',\n    strokeStyle: '#000',\n    filter: 'none',\n    imageSmoothingEnabled: true,\n    imageSmoothingQuality: 'low' as const,\n    lineCap: 'butt' as const,\n    lineDashOffset: 0,\n    lineJoin: 'miter' as const,\n    lineWidth: 1,\n    miterLimit: 10,\n    shadowBlur: 0,\n    shadowColor: 'rgba(0, 0, 0, 0)',\n    shadowOffsetX: 0,\n    shadowOffsetY: 0,\n    direction: 'ltr' as const,\n    font: '10px sans-serif',\n    textAlign: 'start' as const,\n    textBaseline: 'alphabetic' as const,\n    fontKerning: 'auto',\n    fontStretch: 'normal',\n    fontVariantCaps: 'normal',\n    textRendering: 'auto',\n    letterSpacing: '0px',\n    wordSpacing: '0px',\n  };\n\n  const methodMocks = {\n    arc: vi.fn(),\n    arcTo: vi.fn(),\n    beginPath: vi.fn(),\n    bezierCurveTo: vi.fn(),\n    clearRect: vi.fn(),\n    clip: vi.fn(),\n    closePath: vi.fn(),\n    createConicGradient: vi.fn().mockReturnValue({} as CanvasGradient),\n    createImageData: vi.fn().mockImplementation((width: number, height: number) => new CanvasImageData(width || 1, height || 1)),\n    createLinearGradient: vi.fn().mockReturnValue({} as CanvasGradient),\n    createPattern: vi.fn().mockReturnValue(null),\n    createRadialGradient: vi.fn().mockReturnValue({} as CanvasGradient),\n    drawFocusIfNeeded: vi.fn(),\n    drawImage: vi.fn().mockImplementation(\n      (\n        _image: CanvasImageSource,\n        _dx: number,\n        _dy: number,\n        _dw?: number,\n        _dh?: number,\n        _sx?: number,\n        _sy?: number,\n        _sw?: number,\n        _sh?: number\n      ): void => {\n        const argCount = [_image, _dx, _dy, _dw, _dh, _sx, _sy, _sw, _sh].filter(\n          (arg) => arg !== undefined\n        ).length;\n\n        if (argCount === 3 || argCount === 5 || argCount === 9) {\n          return;\n        }\n        throw new Error('Invalid number of arguments for drawImage');\n      }\n    ),\n    ellipse: vi.fn(),\n    fill: vi.fn(),\n    fillRect: vi.fn(),\n    fillText: vi.fn(),\n    getImageData: vi.fn().mockReturnValue(new CanvasImageData(1, 1)),\n    getLineDash: vi.fn().mockReturnValue([]),\n    getTransform: vi.fn().mockReturnValue(new DOMMatrix()),\n    isContextLost: vi.fn().mockReturnValue(false),\n    isPointInPath: vi.fn().mockReturnValue(false),\n    isPointInStroke: vi.fn().mockReturnValue(false),\n    lineTo: vi.fn(),\n    measureText: vi.fn().mockReturnValue({\n      width: 0,\n      actualBoundingBoxAscent: 0,\n      actualBoundingBoxDescent: 0,\n      actualBoundingBoxLeft: 0,\n      actualBoundingBoxRight: 0,\n      fontBoundingBoxAscent: 0,\n      fontBoundingBoxDescent: 0,\n      alphabeticBaseline: 0,\n      emHeightAscent: 0,\n      emHeightDescent: 0,\n      hangingBaseline: 0,\n      ideographicBaseline: 0\n    }),\n    moveTo: vi.fn(),\n    putImageData: vi.fn(),\n    quadraticCurveTo: vi.fn(),\n    rect: vi.fn(),\n    reset: vi.fn(),\n    resetTransform: vi.fn(),\n    restore: vi.fn(),\n    rotate: vi.fn(),\n    roundRect: vi.fn(),\n    save: vi.fn(),\n    scale: vi.fn(),\n    setLineDash: vi.fn(),\n    setTransform: vi.fn(),\n    stroke: vi.fn(),\n    strokeRect: vi.fn(),\n    strokeText: vi.fn(),\n    transform: vi.fn(),\n    translate: vi.fn()\n  };\n\n  return { ...baseContext, ...methodMocks } as unknown as MockCanvasContext;\n};\n\n// Type-safe mock canvas\nconst mockCanvasContext = createMockContext();\nconst getContextMock = vi.fn().mockImplementation((contextId: string): CanvasRenderingContext2D | null => {\n  return contextId === '2d' ? mockCanvasContext : null;\n});\n\n// Mock ResizeObserver\nclass ResizeObserverMock implements ResizeObserver {\n  constructor(private callback: ResizeObserverCallback) {}\n  observe = vi.fn();\n  unobserve = vi.fn();\n  disconnect = vi.fn();\n}\n\n// Setup global mocks\nglobal.ResizeObserver = ResizeObserverMock;\nglobal.HTMLCanvasElement.prototype.getContext = getContextMock;\nglobal.HTMLCanvasElement.prototype.toDataURL = vi.fn().mockReturnValue('');\n\n// Mock window properties commonly used in React components\nObject.defineProperty(window, 'matchMedia', {\n  writable: true,\n  value: vi.fn().mockImplementation((query: string) => ({\n    matches: false,\n    media: query,\n    onchange: null,\n    addListener: vi.fn(),\n    removeListener: vi.fn(),\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn(),\n    dispatchEvent: vi.fn()\n  }))\n});\n\n// Mock IntersectionObserver\nclass IntersectionObserverMock implements IntersectionObserver {\n  readonly root: Element | null = null;\n  readonly rootMargin = '0px';\n  readonly thresholds: ReadonlyArray<number> = [0];\n\n  constructor(private callback: IntersectionObserverCallback) {}\n\n  observe = vi.fn();\n  unobserve = vi.fn();\n  disconnect = vi.fn();\n  takeRecords = vi.fn().mockReturnValue([]);\n}\n\nglobal.IntersectionObserver = IntersectionObserverMock;\n\n// Suppress console errors during tests but keep them available for inspection\nconst originalConsoleError = console.error;\nconsole.error = vi.fn((...args: unknown[]) => {\n  if (process.env.NODE_ENV === 'test') {\n    return;\n  }\n  originalConsoleError(...args);\n});\n\n// Cleanup function to restore console.error\nafterEach(() => {\n  vi.mocked(console.error).mockClear();\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]
