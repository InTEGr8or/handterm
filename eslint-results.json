[{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/e2e/example.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/eslint-plugin-custom-rules/index.js","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":2,"column":33,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":2,"endColumn":75,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/playwright.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/setupTests.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/App.tsx","messages":[{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":46,"column":7,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":60,"endColumn":8},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":55,"column":13,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":57,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useRef, useState } from 'react';\n\nimport { useComputed } from '@preact/signals-react';\n\nimport { HandTermWrapper, type IHandTermWrapperMethods } from './components/HandTermWrapper';\nimport { ActivityMediatorProvider } from './contexts/ActivityMediatorContext';\nimport { AppProvider } from './contexts/AppContext';\nimport { CommandProvider } from './contexts/CommandProvider';\nimport { useAuth } from './hooks/useAuth';\nimport { bypassTutorialSignal } from './signals/appSignals';\nimport { TerminalCssClasses } from './types/TerminalTypes';\nimport { ActivityType } from './types/Types';\nimport { parseLocation } from './utils/navigationUtils';\n\nexport function App(): JSX.Element {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [containerWidth, setContainerWidth] = useState<number>(0);\n\n  const auth = useAuth();\n  const handexTermWrapperRef = useRef<IHandTermWrapperMethods>(null);\n  const isBypassActive = useComputed(() => bypassTutorialSignal.value);\n\n  const getContainerWidth = useCallback(() => {\n    return containerRef.current?.clientWidth ?? 0\n  }, [containerRef]);\n\n  useEffect(() => {\n    const handleResize = () => {\n      const w = getContainerWidth();\n      setContainerWidth(w);\n    };\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, [getContainerWidth]);\n\n  useEffect(() => {\n    const w = getContainerWidth();\n    setContainerWidth(w);\n\n    const handleOutsideTerminalClick = (event: MouseEvent | TouchEvent) => {\n      const currentRef = handexTermWrapperRef.current;\n      if (currentRef === null) return;\n\n      // Check if the click is outside of the terminal area\n      if ((event.target as HTMLElement).id !== TerminalCssClasses.Terminal) {\n        event.stopPropagation();\n        currentRef.focusTerminal();\n\n        if (\n          event instanceof MouseEvent ||\n          (event instanceof TouchEvent && event.touches.length === 1)\n        ) {\n          setTimeout(() => {\n            if (handexTermWrapperRef.current !== null) {\n              handexTermWrapperRef.current.focusTerminal();\n            }\n          }, 1000);\n        }\n      }\n    };\n\n    // Attach the event listener to the document body\n    document.body.addEventListener('click', handleOutsideTerminalClick);\n    document.body.addEventListener('touchstart', handleOutsideTerminalClick);\n\n    // Clean up the event listener\n    return () => {\n      document.body.removeEventListener('click', handleOutsideTerminalClick);\n      document.body.removeEventListener('touchstart', handleOutsideTerminalClick);\n    };\n  }, [getContainerWidth]);\n\n  return (\n    <ActivityMediatorProvider>\n      <div className='app' ref={containerRef}>\n        <AppProvider>\n          <CommandProvider\n            auth={auth}\n            handTermRef={handexTermWrapperRef}\n          >\n            {parseLocation().activityKey !== ActivityType.EDIT\n              && <div key=\"edit-activity-placeholder\" />\n            }\n            {isBypassActive.value && (\n              <div style={{ position: 'fixed', top: 0, right: 0, color: 'black', background: '#222', padding: '5px' }}>\n                Bypass Mode Active\n              </div>\n            )}\n            <HandTermWrapper\n              ref={handexTermWrapperRef}\n              auth={auth}\n              terminalWidth={containerWidth}\n              onOutputUpdate={() => {}}\n            />\n          </CommandProvider>\n        </AppProvider>\n      </div>\n    </ActivityMediatorProvider>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/Persistence.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__mocks__/@octokit/app.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__mocks__/@octokit/core.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__mocks__/@octokit/rest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__mocks__/@preact/signals-react.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__mocks__/canvasMock.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__mocks__/signals/appSignals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__mocks__/signals/commandLineSignals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__mocks__/signals/tutorialSignals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__tests__/activitySwitching.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__tests__/basic.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__tests__/hooks/useActivityMediator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/__tests__/useActivityMediator.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/allChords.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/BypassCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/GitHubCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/HelpCommand.tsx","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'execute' has no 'await' expression.","line":10,"column":3,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":10,"endColumn":18},{"ruleId":"import/no-named-as-default-member","severity":1,"message":"Caution: `ReactDOMServer` also has a named export `renderToStaticMarkup`. Check if you meant to write `import {renderToStaticMarkup} from 'react-dom/server'` instead.","line":30,"column":16,"nodeType":"MemberExpression","endLine":30,"endColumn":51}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import ReactDOMServer from 'react-dom/server';\n\nimport { Chord } from '../components/Chord';\nimport { type ICommand, type ICommandResponse , type ICommandContext } from '../contexts/CommandContext';\nimport { type ParsedCommand } from '../types/Types';\n\nexport const HelpCommand: ICommand = {\n  name: 'help',\n  description: 'Display help information',\n  execute: async (\n    context: ICommandContext,\n    parsedCommand: ParsedCommand,\n  ): Promise<ICommandResponse> => {\n    if (\n      parsedCommand.command === 'help'\n      || parsedCommand.command === '411'\n    ) {\n      const commandChords = [\n        'DELETE (Backspace)',\n        'Return (ENTER)',\n        'UpArrow',\n        'LeftArrow',\n        'DownArrow',\n        'RightArrow',\n        'ESCAPE',\n      ].map(c => {\n        return <Chord key={c} displayChar={c} />;\n      });\n      const commandChordsHtml = commandChords.map(element => {\n        return ReactDOMServer.renderToStaticMarkup(element);\n      }).join('');\n      const response = \"<div class='chord-display-container'>\" + commandChordsHtml + \"</div>\";\n      return { status: 200, message: response };\n    }\n    return { status: 404, message: \"Help command not recognized\" };\n  }\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/ListPhrasesCommand.tsx","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'execute' has no 'await' expression.","line":12,"column":3,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":12,"endColumn":18},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":16,"column":10,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":16,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type ICommand, type ICommandContext, type ICommandResponse } from '../contexts/CommandContext';\nimport { Phrases, type GamePhrase, type ParsedCommand } from '../types/Types';\n\nexport const ListPhrasesCommand: ICommand = {\n  name: 'ls',\n  description: 'List files',\n  switches: {\n    'all': 'List all phrases',\n    'random': 'List a random phrase',\n    'easy': 'List only easy phrases',\n  },\n  execute: async (\n    context: ICommandContext,\n    _parsedCommand: ParsedCommand\n  ): Promise<ICommandResponse> => {\n    if (!context) {\n      return { status: 404, message: 'No command context available.' };\n    }\n\n    const phrases: string = Phrases\n      .map((phrase: GamePhrase) => phrase.key)\n      .join('\\n');\n\n    return {\n      status: 200,\n      message: phrases\n    };\n  }\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/LoginCommand.ts","messages":[{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":29,"column":13,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":31,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/commands/LoginCommand.ts\n\nimport { isInLoginProcessSignal, tempUserNameSignal, setTempUserName, setIsInLoginProcess } from 'src/signals/appSignals';\n\nimport { type ICommand, type ICommandContext, type ICommandResponse } from '../contexts/CommandContext';\nimport { type ParsedCommand } from '../types/Types';\nimport { createLogger } from '../utils/Logger';\n\nconst logger = createLogger();\n\ninterface LoginErrorResponse {\n    status: number;\n    message: string;\n}\n\nexport const LoginCommand: ICommand = {\n    name: 'login',\n    description: 'Log in to the system',\n    execute: async (context: ICommandContext, parsedCommand: ParsedCommand): Promise<ICommandResponse> => {\n        const { auth } = context;\n\n        if (parsedCommand.args.length === 1) {\n            // Start login process\n            setIsInLoginProcess(true);\n            const username = parsedCommand.args[0];\n            setTempUserName(username);\n\n            // Demonstrate usage of tempUserNameSignal\n            if (tempUserNameSignal.value !== username) {\n                logger.error('Username mismatch');\n            }\n\n            return { status: 200, message: 'Enter password:' };\n        } else if (parsedCommand.args.length === 2 && isInLoginProcessSignal.value) {\n            // Complete login process\n            const tempUsername = parsedCommand.args[0];\n            const password = parsedCommand.args[1];\n\n            try {\n                const result = await auth.login(tempUsername, password);\n                setIsInLoginProcess(false);\n\n                return {\n                    status: result.status,\n                    message: result.status === 200 ? 'Login successful!' : `Login failed: ${result.message}`,\n                    sensitive: true // Mark as sensitive to mask password\n                };\n            } catch (error) {\n                setIsInLoginProcess(false);\n\n                // Type narrowing for error\n                const errorResponse: LoginErrorResponse =\n                    error instanceof Error\n                    ? { status: 500, message: error.message }\n                    : { status: 500, message: 'An unknown error occurred' };\n\n                return {\n                    status: errorResponse.status,\n                    message: `Login error: ${errorResponse.message}`,\n                    sensitive: true // Mark as sensitive to mask password\n                };\n            }\n        } else {\n            return { status: 400, message: 'Usage: login <username>' };\n        }\n    }\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/SignUpCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/SpecialCommand.tsx","messages":[{"ruleId":"import/no-named-as-default-member","severity":1,"message":"Caution: `ReactDOMServer` also has a named export `renderToStaticMarkup`. Check if you meant to write `import {renderToStaticMarkup} from 'react-dom/server'` instead.","line":20,"column":7,"nodeType":"MemberExpression","endLine":20,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import ReactDOMServer from 'react-dom/server';\n\nimport { Chord } from '../components/Chord';\nimport { type ICommand, type ICommandContext, type ICommandResponse } from '../contexts/CommandContext';\nimport { type ParsedCommand } from '../types/Types';\n\nexport const SpecialCommand: ICommand = {\n  name: 'special',\n  description: 'Display special characters',\n  execute: async (\n    _context: ICommandContext,\n    _parsedCommand: ParsedCommand,\n  ): Promise<ICommandResponse> => {\n    await Promise.resolve();\n    const specialChars = ['~', '`', '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '-', '_', '+', '=', '{', '[', '}', ']', '|', '\\\\', ':', ';', '\"', \"'\", '<', '>', ',', '.', '?', '/'];\n    const chordElements = specialChars.map(char => (\n      <Chord key={char} displayChar={char} />\n    ));\n    const chordsHtml = chordElements.map(element =>\n      ReactDOMServer.renderToStaticMarkup(element)\n    ).join('');\n\n    return {\n      status: 200,\n      message: `<div class='chord-display-container'>${chordsHtml}</div>`\n    };\n  }\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/__tests__/LoginCommand.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/archiveCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/cleanCommand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/clearCommand.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":33,"column":10,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":33,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1078,1096],"text":"(handTerm?.current) == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":64,"column":9,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":64,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/commands/clearCommand.tsx\nimport { type IHandTermWrapperMethods } from \"../components/HandTermWrapper\";\nimport { type ICommand, type ICommandContext, type ICommandResponse } from '../contexts/CommandContext';\nimport { LogKeys } from '../types/TerminalTypes';\nimport { type ParsedCommand, type OutputElement } from '../types/Types';\n\ninterface HandTermState {\n  commandHistory?: unknown[];\n  outputElements?: unknown[];\n}\n\ninterface HandTermInstance extends IHandTermWrapperMethods {\n  setState: (state: Partial<HandTermState>) => void;\n  terminalReset: () => void;\n  prompt: () => void;\n}\n\n// Extend ICommandContext to include handTerm\ninterface ExtendedCommandContext extends ICommandContext {\n  handTerm?: React.RefObject<HandTermInstance>;\n  appendToOutput: (output: OutputElement) => void;\n}\n\nexport const clearCommand: ICommand = {\n  name: 'clear',\n  description: 'Clear the command history',\n  execute: async (\n    context: ExtendedCommandContext,\n    parsedCommand: ParsedCommand\n  ): Promise<ICommandResponse> => {\n    const handTerm = context.handTerm;\n\n    if (!handTerm?.current) {\n      const outputElement: OutputElement = {\n        command: parsedCommand,\n        response: 'No command context available.',\n        status: 404,\n        commandTime: new Date()\n      };\n      context.appendToOutput(outputElement);\n      return { status: 404, message: 'No command context available.' };\n    }\n\n    // Logic to clear the command history from localStorage\n    const removeKeys = Object.keys(localStorage).filter(key => {\n      const matchesDefaultKeys = key.includes(LogKeys.Command ?? '') ||\n        key.includes('terminalCommandHistory' ?? '') || // Remove after clearing legacy phone db.\n        key.includes(LogKeys.CharTime ?? '');\n\n      const matchesArg = parsedCommand.args.length > 0 &&\n        key.includes(parsedCommand.args[0] ?? '');\n\n      return matchesDefaultKeys ?? matchesArg;\n    });\n\n    await Promise.all(removeKeys.map(async (removeKey) => {\n      await new Promise<void>((resolve) => {\n        localStorage.removeItem(removeKey); // Clear localStorage.length\n        resolve();\n      });\n    }));\n\n    const handTermInstance = handTerm.current;\n    if (handTermInstance) {\n      handTermInstance.setState({ commandHistory: [] });\n      handTermInstance.setState({ outputElements: [] });\n      handTermInstance.terminalReset();\n      handTermInstance.prompt();\n    }\n\n    const outputElement: OutputElement = {\n      command: parsedCommand,\n      response: 'Command history cleared.',\n      status: 200,\n      commandTime: new Date()\n    };\n    context.appendToOutput(outputElement);\n\n    return { status: 200, message: 'Command history cleared.' };\n  }\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/commandRegistry.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":20,"column":29,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":20,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[529,536],"text":"(filter == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[530,536],"text":"(filter ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[529,536],"text":"(!Boolean(filter))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/commands/commandRegistry.ts\n\nimport { type ICommand } from '../contexts/CommandContext';\n\nexport type ICommandRegistryItems = Record<string, ICommand>;\n\nclass CommandRegistry {\n    private commands: ICommandRegistryItems = {};\n\n    register(command: ICommand) {\n        this.commands[command.name] = command;\n    }\n\n    getCommand(name: string): ICommand | undefined {\n        return this.commands[name];\n    }\n\n    getHelp(filter?: string): string {\n        return Object.values(this.commands)\n            .filter(cmd => !filter || cmd.name.includes(filter))\n            .map(cmd => `${cmd.name}: ${cmd.description}`)\n            .join('\\n\\n');\n    }\n\n}\n\nexport const commandRegistry = new CommandRegistry();\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/editCommand.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/index.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":31,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":31,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[906,927],"text":"(commandModule.default != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/commands/index.ts\nimport { type ICommand } from '../contexts/CommandContext';\n\nimport { commandRegistry } from './commandRegistry';\n\n// Interface for command modules\ninterface CommandModule {\n  default?: ICommand;\n  [key: string]: ICommand | undefined;\n}\n\n// Type guard to check if a value is a valid command\nfunction isValidCommand(command: unknown): command is ICommand {\n  return (\n    typeof command === 'object' &&\n    command !== null &&\n    'name' in command &&\n    'execute' in command &&\n    typeof (command as ICommand).name === 'string' &&\n    typeof (command as ICommand).execute === 'function'\n  );\n}\n\n// Dynamically import and register all command files\nconst commandModules = import.meta.glob('./*Command.ts*', { eager: true });\n\nObject.entries(commandModules).forEach(([_path, module]) => {\n  const commandModule = module as CommandModule;\n\n  // Check for default export first\n  if (commandModule.default && isValidCommand(commandModule.default)) {\n    commandRegistry.register(commandModule.default);\n    return;\n  }\n\n  // If no default, check other exports\n  const commands = Object.values(commandModule).filter(isValidCommand);\n  commands.forEach(command => {\n    commandRegistry.register(command);\n  });\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/toggleVideoCommand.ts","messages":[{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'execute' has no 'await' expression.","line":8,"column":5,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":8,"endColumn":20}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type ICommand, type ICommandContext, type ICommandResponse } from '../contexts/CommandContext';\nimport { isShowVideoSignal } from '../signals/appSignals';\nimport { type ParsedCommand } from '../types/Types';\n\nexport const toggleVideoCommand: ICommand = {\n    name: 'video',\n    description: 'Toggle webcam video on/off',\n    execute: async (\n        _context: ICommandContext,\n        _parsedCommand: ParsedCommand\n    ): Promise<ICommandResponse> => {\n        isShowVideoSignal.value = !isShowVideoSignal.value;\n        return {\n            status: 200,\n            message: `Video ${isShowVideoSignal.value ? 'enabled' : 'disabled'}`,\n        };\n    }\n};\n\nexport default toggleVideoCommand;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/commands/wrtCommand.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":54,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":54,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1765,1773],"text":"(fileName != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1765,1773],"text":"(fileName ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1765,1773],"text":"(Boolean(fileName))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":54,"column":25,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":54,"endColumn":45,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1777,1797],"text":"(context.auth.getFile != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":57,"column":44,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":57,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1934,1947],"text":"(response.data != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1934,1947],"text":"(response.data ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1934,1947],"text":"(Boolean(response.data))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":69,"column":18,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":69,"endColumn":34},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":71,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":71,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2622,2630],"text":"(fileName != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2622,2630],"text":"(fileName ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2622,2630],"text":"(Boolean(fileName))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":71,"column":25,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":71,"endColumn":44,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2634,2653],"text":"(context.setEditMode != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":71,"column":48,"nodeType":"ChainExpression","messageId":"conditionErrorNullableObject","endLine":71,"endColumn":96,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2657,2705],"text":"((context.activityMediator?.determineActivityState) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":77,"column":18,"nodeType":"MemberExpression","messageId":"conditionErrorOther","endLine":77,"endColumn":34},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":79,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":79,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3070,3078],"text":"(fileName != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3070,3078],"text":"(fileName ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3070,3078],"text":"(Boolean(fileName))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":79,"column":25,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":79,"endColumn":45,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3082,3102],"text":"(context.auth.getFile != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":79,"column":49,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":79,"endColumn":71,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3106,3128],"text":"(context.handleEditSave != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":82,"column":44,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":82,"endColumn":57,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3265,3278],"text":"(response.data != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3265,3278],"text":"(response.data ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3265,3278],"text":"(Boolean(response.data))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type React from 'react';\n\nimport { type ICommand, type ICommandResponse, type ICommandContext } from '../contexts/CommandContext';\nimport { type IAuthProps } from '../hooks/useAuth';\nimport { ActivityType, type OutputElement, type ParsedCommand } from '../types/Types';\nimport { isNotNullOrUndefined } from '../utils/typeSafetyUtils';\n\n// Extend the command context with optional methods\ninterface ExtendedCommandContext extends ICommandContext {\n  auth: IAuthProps & {\n    getFile?: (fileName: string, format: string) => Promise<{\n      status: number;\n      data?: string;\n      message?: string;\n    }>;\n  };\n  setEditMode?: (mode: boolean) => void;\n  activityMediator?: {\n    determineActivityState?: (activity: ActivityType) => void;\n  };\n  handleEditSave?: (content: string) => void;\n}\n\nexport const wrtCommand: ICommand = {\n  name: 'wrt',\n  description: 'Write to the terminal',\n  switches: {\n    'file': 'Write the contents of a file to the terminal',\n    'edit': 'Edit the contents of a file',\n    'save': 'Save the contents of a file',\n  },\n  execute: async (\n    context: ExtendedCommandContext,\n    parsedCommand: ParsedCommand\n  ): Promise<ICommandResponse> => {\n    const switches = parsedCommand.switches;\n    const args = parsedCommand.args;\n\n    const getFileName = (switchKey: string): string | null => {\n      const fileName = switches[switchKey];\n      return typeof fileName === 'string' ? fileName : null;\n    };\n\n    const createOutputElement = (message: string | React.ReactNode): OutputElement => ({\n      command: parsedCommand,\n      response: message,\n      status: 200,\n      commandTime: new Date()\n    });\n\n    try {\n      if (isNotNullOrUndefined(switches['file'])) {\n        const fileName = getFileName('file');\n        if (fileName && context.auth.getFile) {\n          try {\n            const response = await context.auth.getFile(fileName, 'txt');\n            if (response.status === 200 && response.data) {\n              context.appendToOutput(createOutputElement(response.data));\n            } else {\n              context.appendToOutput(createOutputElement(`Error reading file: ${fileName}`));\n            }\n          } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n            context.appendToOutput(createOutputElement(`Error reading file: ${errorMessage}`));\n          }\n        } else {\n          context.appendToOutput(createOutputElement('Please provide a file name or file reading is not supported.'));\n        }\n      } else if (switches['edit']) {\n        const fileName = getFileName('edit');\n        if (fileName && context.setEditMode && context.activityMediator?.determineActivityState) {\n          context.setEditMode(true);\n          context.activityMediator.determineActivityState(ActivityType.EDIT);\n        } else {\n          context.appendToOutput(createOutputElement('Please provide a file name to edit or edit mode is not supported.'));\n        }\n      } else if (switches['save']) {\n        const fileName = getFileName('save');\n        if (fileName && context.auth.getFile && context.handleEditSave) {\n          try {\n            const response = await context.auth.getFile(fileName, 'txt');\n            if (response.status === 200 && response.data) {\n              context.handleEditSave(response.data);\n            } else {\n              context.appendToOutput(createOutputElement(`Error reading file: ${fileName}`));\n            }\n          } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n            context.appendToOutput(createOutputElement(`Error reading file: ${errorMessage}`));\n          }\n        } else {\n          context.appendToOutput(createOutputElement('Please provide a file name to save or save functionality is not supported.'));\n        }\n      } else if (args.length > 0) {\n        // Write the provided arguments to the terminal\n        context.appendToOutput(createOutputElement(args.join(' ')));\n      } else {\n        return { status: 400, message: 'Please provide text to write or use a switch.' };\n      }\n\n      return { status: 200, message: 'Command executed successfully.' };\n    } catch (error) {\n      return {\n        status: 500,\n        message: error instanceof Error ? error.message : 'An unexpected error occurred'\n      };\n    }\n  }\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/Chord.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":14,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":14,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[347,358],"text":"foundChord == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export interface ChordProps {\r\n    displayChar: string;\r\n}\r\n\r\nimport type React from 'react';\n\r\nimport { allChords } from \"../allChords\";\r\n\r\nexport const Chord: React.FC<ChordProps> = ({ displayChar }) => {\r\n    let foundChord = Array.from(allChords).find(x => {\r\n        return x.key.replace('&#x2581;', ' ') === displayChar;\r\n    });\r\n\r\n    if (!foundChord) {\r\n        foundChord = Array.from(allChords).find(x => x.key === displayChar);\r\n    }\r\n\r\n    const foundChar = foundChord?.alias ?? foundChord?.key;\r\n\r\n    return (\r\n        <div className=\"chord-image-holder\" id=\"chord-image-holder\" data-source=\"ErrorDisplay.tsx\">\r\n            <div className=\"col-sm-2 row generated next\" id=\"chord2\">\r\n                <span id=\"char15\" className=\"char\">{foundChar}</span>\r\n                <img loading=\"lazy\" alt=\"2\" src={`${import.meta.env.BASE_URL}images/svgs/${foundChord?.chordCode}.svg`} height=\"59.516\" width=\"75\" className=\"hand\"></img>\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/CommandOutput.tsx","messages":[{"ruleId":"import/no-named-as-default","severity":1,"message":"Using exported name 'WpmTable' as identifier for default import.","line":11,"column":8,"nodeType":"ImportDefaultSpecifier","endLine":11,"endColumn":16},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":52,"column":14,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":52,"endColumn":18},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":52,"column":22,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":52,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/components/CommandOutput.tsx\n\nimport {type ReactNode} from 'react';\nimport type React from 'react';\n\nimport { parsedCommandToString } from 'src/utils/commandUtils';\n\nimport { type ParsedCommand, type WPMs } from '../types/Types';\n\nimport { TimeDisplay } from './TimeDisplay';\nimport WpmTable from './WpmTable';\n\ninterface CommandOutputProps {\n    command: ParsedCommand;\n    response: ReactNode;\n    status: number;\n    wpms: WPMs;\n    commandTime: Date;\n}\n\nexport const CommandOutput: React.FC<CommandOutputProps> = ({\n    command,\n    response,\n    status,\n    wpms,\n    commandTime\n}) => {\n    // Function to check if a string contains HTML tags\n    const containsHTML = (str: string) => {\n        return typeof str === 'string' && /<[a-z][\\s\\S]*>/i.test(str);\n    };\n\n    // Render response based on its type and content\n    const renderResponse = () => {\n        if (typeof response === 'string' && containsHTML(response)) {\n            return <div className=\"response\" dangerouslySetInnerHTML={{ __html: response }} />;\n        }\n        return <div className=\"response\">{response}</div>;\n    };\n\n    return (\n        <div data-status={status}>\n            <div className=\"log-line\">\n                <span className=\"log-time\">\n                    <TimeDisplay time={commandTime} />\n                </span>\n                <span className=\"wpm-label\">WPM:</span>\n                <span className=\"wpm\">{(wpms.wpmAverage ?? 0).toFixed(0)}</span>\n                <span className=\"content\">{parsedCommandToString(command)}</span>\n            </div>\n            {renderResponse()}\n            {wpms && wpms.charWpms && wpms.charWpms.length > 0 && (\n                <WpmTable wpms={wpms.charWpms} name=\"slow-char\" />\n            )}\n        </div>\n    );\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/ErrorDisplay.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":28,"column":8,"nodeType":"Identifier","messageId":"conditionErrorString","endLine":28,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[683,697],"text":"(mismatchedChar.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[683,697],"text":"(mismatchedChar !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[683,697],"text":"(Boolean(mismatchedChar))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useImperativeHandle, forwardRef } from 'react';\n\nimport { Chord } from './Chord';\n\ninterface ErrorDisplayProps {\n  mismatchedChar: string;\n  isVisible: boolean;\n}\n\nconst ErrorDisplay = forwardRef((props: ErrorDisplayProps, ref) => {\n  const [errorCount, setErrorCount] = useState(0);\n  const { mismatchedChar } = props;\n\n\n  const showError = () => {\n    setErrorCount(prevCount => prevCount + 1);\n  };\n\n\n  // Use useImperativeHandle to expose functions to the parent component\n  useImperativeHandle(ref, () => ({\n    showError,\n  }));\n\n  return (\n    <div style={{ display: props.isVisible ? 'block' : 'none' }} >\n      <div>Error Count: {errorCount}</div>\n      {mismatchedChar &&\n        <Chord displayChar={mismatchedChar} />\n      }\n    </div>\n  );\n});\n\nErrorDisplay.displayName = 'ErrorDisplay';\n\nexport default ErrorDisplay;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/HandTermWrapper.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/MonacoEditor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/Nav.tsx","messages":[{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":3,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":3,"endColumn":20}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Chord } from \"./Chord\";\n\nexport function Nav() {\n    return (\n        ['UpArrow', 'LeftArrow', 'DownArrow', 'RightArrow'].map(c => {\n            return <Chord key={c} displayChar={c} />\n        })\n    )\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/NextCharsDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/Output.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/Prompt.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":23,"column":14,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":23,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[746,760],"text":"(githubUsername != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[746,760],"text":"(githubUsername ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[746,760],"text":"(Boolean(githubUsername))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useComputed } from '@preact/signals-react';\nimport type React from 'react';\n\nimport { promptInfoSignal } from 'src/signals/commandLineSignals';\n\nimport { TerminalCssClasses } from \"../types/TerminalTypes\"\n\ninterface PromptProps {\n    domain: string;\n    username: string;\n    timestamp: string;\n    githubUsername: string | null;\n}\n\nexport const Prompt: React.FC<PromptProps> = ({ domain, username, timestamp, githubUsername }) => {\n    const promptInfo = useComputed(() => promptInfoSignal.value);\n\n    return (\n        <pre id={TerminalCssClasses.Prompt}>\n            <span className=\"timestamp\">{timestamp}</span>\n            <span className=\"user\">{username}</span>\n            <span className=\"domain\">@{domain}</span>\n            {githubUsername &&\n                <span className=\"github\">\n                    <i className=\"fa fa-github\" aria-hidden=\"true\"></i>\n                    {githubUsername}\n                </span>\n            }\n            <span>{promptInfo.value}</span>\n        </pre>\n    )\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/SlowestCharactersDisplay.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":18,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":18,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[452,474],"text":"charGroups[character] == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type React from 'react';\n\ntype CharWPM = {\n    character: string;\n    wpm: number;\n    durationMilliseconds: number;\n};\n\ninterface SlowestCharactersDisplayProps {\n    charWpms: CharWPM[];\n}\n\nconst averageWpmByCharacter = (charWpms: CharWPM[]) => {\n    const charGroups: Record<string, { totalWpm: number, count: number }> = {};\n\n    // Sum WPMs for each character and count occurrences\n    charWpms.forEach(({ character, wpm }) => {\n        if (!charGroups[character]) {\n            charGroups[character] = { totalWpm: 0, count: 0 };\n        }\n        charGroups[character].totalWpm += wpm;\n        charGroups[character].count++;\n    });\n\n    // Calculate average WPM for each character\n    return Object.entries(charGroups).map(([character, { totalWpm, count }]) => ({\n        character,\n        wpm: totalWpm / count,\n        durationMilliseconds: 0, // You may want to handle duration aggregation differently\n    }));\n}\n\nexport const SlowestCharactersDisplay: React.FC<SlowestCharactersDisplayProps> = ({ charWpms }) => {\n    // that calculates the average WPM for each character.\n    const characterAverages = averageWpmByCharacter(charWpms.filter(wpm => wpm.durationMilliseconds > 1));\n    const slowestCharacters = characterAverages\n        .sort((a, b) => a.wpm - b.wpm)\n        .slice(0, 3);\n\n    return (\n        <div className=\"slow-chars\">\n            {slowestCharacters.map((char, index) => (\n                <div key={index}>\n                    <span>Character: {char.character}</span>\n                    <span>WPM: {char.wpm.toFixed(2)}</span>\n                </div>\n            ))}\n        </div>\n    );\n};\n\n// If you need to use ReactDOMServer.renderToStaticMarkup in the functional component context,\n// you would typically do it outside the component, wherever you're intending to use the HTML string.\n// For example:\n// const slowestCharactersHtml = ReactDOMServer.renderToStaticMarkup(<SlowestCharactersDisplay charWpms={charWpms} />);","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/TimeDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/Timer.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullish value in conditional. The condition is always false.","line":27,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullish","endLine":27,"endColumn":21},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":31,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":31,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[951,961],"text":"intervalId != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[951,961],"text":"intervalId ?? 0"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[951,961],"text":"Boolean(intervalId)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useImperativeHandle, forwardRef, type ForwardRefRenderFunction } from 'react';\n\nexport interface TimerProps {}\n\nexport interface TimerHandle {\n  start: () => void;\n  stop: () => void;\n  reset: () => number;\n  success: () => void;\n}\n\nconst Timer: ForwardRefRenderFunction<TimerHandle, TimerProps> = (_props, ref) => {\n  const [centiSecond, setCentiSecond] = useState(0);\n  const [isActive, setIsActive] = useState(false);\n  const [svgStatus, setSvgStatus] = useState<'start' | 'stop' | 'pause'>('start');\n\n  useEffect(() => {\n    let intervalId: number | null = null;\n\n    if (isActive) {\n      setSvgStatus('pause');\n      intervalId = window.setInterval(() => {\n        setCentiSecond((prevCentiSecond: number) => prevCentiSecond + 1);\n      }, 10);\n    } else if (!isActive && centiSecond !== 0) {\n      setSvgStatus('start');\n      if (intervalId) clearInterval(intervalId);\n    }\n\n    return () => {\n      if (intervalId) clearInterval(intervalId);\n    };\n  }, [isActive, centiSecond]);\n\n  const start = () => {\n    setIsActive(true);\n  };\n\n  const stop = () => {\n    setIsActive(false);\n  };\n\n  const reset = (): number => {\n    setIsActive(false);\n    const finalCentiSecond = centiSecond;\n    setCentiSecond(0);\n    return finalCentiSecond;\n  };\n\n  const success = () => {\n    setCentiSecond(0);\n    setIsActive(false);\n  };\n\n  useImperativeHandle(ref, () => ({\n    start,\n    stop,\n    reset,\n    success\n  }));\n\n  const renderSvg = () => {\n    switch (svgStatus) {\n      case 'start':\n        return <use href=\"#start\" transform=\"scale(2,2)\" />;\n      case 'stop':\n        return <use href=\"#stop\" transform=\"scale(2,2)\" />;\n      case 'pause':\n        return <use href=\"#pause\" transform=\"scale(2,2)\" />;\n      default:\n        return <use href=\"#stop\" transform=\"scale(2,2)\" />;\n    }\n  };\n\n  return (\n    <React.Fragment>\n      <span id=\"timer\">{(centiSecond / 100).toFixed(1)}</span>\n      <svg width=\"15\" height=\"20\" style={{ float: 'left' }}>\n        {renderSvg()}\n      </svg>\n    </React.Fragment>\n  );\n};\n\nexport default forwardRef(Timer);\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/TutorialManager.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":13,"column":5,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":13,"endColumn":13},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":17,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":17,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[461,477],"text":"(tutorial.display != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[461,477],"text":"(tutorial.display ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[461,477],"text":"(Boolean(tutorial.display))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":20,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":20,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[582,599],"text":"(tutorial.display == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[583,599],"text":"(tutorial.display ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[582,599],"text":"(!Boolean(tutorial.display))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type Tutorial } from '../types/Types';\n\nimport { Chord } from './Chord';\n\ninterface TutorialManagerProps {\n  tutorial: Tutorial;\n}\n\nexport const TutorialManager = ({\n  tutorial,\n}: TutorialManagerProps): JSX.Element => {\n  return (\n    tutorial && (\n      <div className=\"tutorial-component\" data-testid=\"tutorial-component\">\n        <pre className=\"tutorial-prompt\">{tutorial.prompt}</pre>\n        <div className=\"chord-display-container\">\n          {tutorial.display && (\n            <Chord key={tutorial.phrase} displayChar={tutorial.display} />\n          )}\n          {!tutorial.display &&\n            tutorial.phrase.split('').map((character: string, index: number) => (\n              <Chord key={`${index}-${character}`} displayChar={character} />\n            ))}\n        </div>\n      </div>\n    )\n  );\n};\n\nTutorialManager.displayName = 'TutorialManager';\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/WpmTable.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":17,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":17,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[547,557],"text":"acc[char] == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/components/WpmTable.tsx\r\nimport type React from 'react';\nimport { useMemo } from 'react';\n\r\nimport { type CharWPM } from '../types/TerminalTypes';\r\n\r\ninterface WpmTableProps {\r\n  wpms: ReadonlyArray<CharWPM>;\r\n  name?: string;\r\n}\r\n\r\nexport const WpmTable: React.FC<WpmTableProps> = ({ wpms, name = \"slowest-characters\" }) => {\r\n  const groupedAndSortedWpms = useMemo(() => {\r\n    // Group by character\r\n    const grouped = wpms.reduce((acc, curr) => {\r\n      const char = curr.character.replace(\"\\r\", \"\\\\r\").replace(\" \", \"\\\\s\");\r\n      if (!acc[char]) {\r\n        acc[char] = { character: char, wpm: curr.wpm, count: 1 };\r\n      } else {\r\n        acc[char].wpm += curr.wpm;\r\n        acc[char].count += 1;\r\n      }\r\n      return acc;\r\n    }, {} as Record<string, { character: string, wpm: number, count: number }>);\r\n\r\n    // Calculate average WPM for each character\r\n    const averages = Object.values(grouped).map(item => ({\r\n      character: item.character,\r\n      wpm: item.wpm / item.count\r\n    }));\r\n\r\n    // Sort by slowest (lowest WPM) first\r\n    averages.sort((a, b) => a.wpm - b.wpm);\r\n\r\n    // Take top 5\r\n    return averages.slice(0, 5);\r\n  }, [wpms]);\r\n\r\n  return (\r\n    <table className=\"wpm-table\">\r\n      <thead>\r\n        <tr><th colSpan={2}>{name}</th></tr>\r\n        <tr>\r\n          <th>Character</th>\r\n          <th>Avg WPM</th>\r\n        </tr>\r\n      </thead>\r\n      <tbody>\r\n        {groupedAndSortedWpms.map((wpm, index) => (\r\n          <tr key={index} className=\"wpm-table-row\">\r\n            <td>{wpm.character}</td>\r\n            <td className=\"number\">{wpm.wpm.toFixed(0)}</td>\r\n          </tr>\r\n        ))}\r\n      </tbody>\r\n    </table>\r\n  );\r\n};\r\n\r\nexport default WpmTable;","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/components/XtermAdapterConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/constants/terminal.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/contexts/ActivityMediatorContext.tsx","messages":[{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":14,"column":46,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":14,"endColumn":48},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":16,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":16,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[546,554],"text":"context == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/contexts/ActivityMediatorContext.tsx\nimport type React from 'react';\nimport { createContext, useContext, useState } from 'react';\n\nimport { ActivityType } from '../types/Types';\n\nexport interface IActivityMediatorContext {\n    currentActivity: ActivityType;\n    setCurrentActivity: React.Dispatch<React.SetStateAction<ActivityType>>;\n}\n\nconst ActivityMediatorContext = createContext<IActivityMediatorContext | null>(null);\n\nexport const useActivityMediatorContext = () => {\n    const context = useContext(ActivityMediatorContext);\n    if (!context) {\n        throw new Error('useActivityMediatorContext must be used within an ActivityMediatorProvider');\n    }\n    return context;\n};\n\nexport const ActivityMediatorProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n\n    const [currentActivity, setCurrentActivity] = useState<ActivityType>(ActivityType.NORMAL);\n\n    const value: IActivityMediatorContext = {\n        currentActivity,\n        setCurrentActivity\n    };\n\n    return (\n        <ActivityMediatorContext.Provider value={value}>\n            {children}\n        </ActivityMediatorContext.Provider>\n    );\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/contexts/AppContext.tsx","messages":[{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":20,"column":33,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":20,"endColumn":35},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":22,"column":8,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":22,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[666,674],"text":"context == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/contexts/AppContext.tsx\nimport type React from 'react';\nimport { createContext, useContext, useState } from 'react';\n\nimport { type ActivityType, type OutputElement } from '../types/Types';\n\nimport { useActivityMediatorContext } from './ActivityMediatorContext';\n\ninterface AppContextType {\n  currentActivity: ActivityType;\n  isLoggedIn: boolean;\n  setIsLoggedIn: (isLoggedIn: boolean) => void;\n  userName: string | null;\n  setUserName: (userName: string | null) => void;\n  outputElements: OutputElement[];\n}\n\nconst AppContext = createContext<AppContextType | null>(null);\n\nexport const useAppContext = () => {\n  const context = useContext(AppContext);\n  if (!context) {\n    throw new Error('useAppContext must be used within an AppProvider');\n  }\n  return context;\n};\n\nexport const AppProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const [isLoggedIn, setIsLoggedIn] = useState(false);\n  const [userName, setUserName] = useState<string | null>(null);\n  const [outputElements] = useState<OutputElement[]>([]);\n\n  const { currentActivity } = useActivityMediatorContext();\n\n  const value: AppContextType = {\n    currentActivity,\n    isLoggedIn,\n    setIsLoggedIn,\n    userName,\n    setUserName,\n    outputElements,\n  };\n\n  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/contexts/CommandContext.tsx","messages":[{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":39,"column":37,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":39,"endColumn":39},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":41,"column":8,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":41,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1300,1308],"text":"context == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/contexts/CommandContext.tsx\nimport type React from 'react';\nimport { createContext, useContext } from 'react';\n\nimport { type IHandTermWrapperMethods } from '../components/HandTermWrapper';\nimport { type IAuthProps } from '../hooks/useAuth';\nimport { type OutputElement, type ParsedCommand, type ParsedLocation } from '../types/Types';\n\nexport interface ICommandResponse {\n  status: number;\n  message: string;\n  body?: string | null;\n  sensitive?: boolean; // Flag to indicate if the command response contains sensitive data\n}\n\nexport interface ICommand {\n  name: string;\n  description: string;\n  switches?: Record<string, string>;\n  execute: (\n    context: ICommandContext,\n    parsedCommand: ParsedCommand,\n  ) => Promise<ICommandResponse>;\n}\n\nexport interface ICommandContext {\n  executeCommand: (command: string) => Promise<void>;\n  commandHistory: string[];\n  addToCommandHistory: (command: string) => void;\n  output: OutputElement[];\n  appendToOutput: (output: OutputElement) => void;\n  handTermRef: React.RefObject<IHandTermWrapperMethods>;\n  auth: IAuthProps;\n  updateLocation: (options: ParsedLocation) => void;\n}\n\nexport const CommandContext = createContext<ICommandContext | null>(null);\n\nexport const useCommandContext = () => {\n  const context = useContext(CommandContext);\n  if (!context) {\n    throw new Error('useCommandContext must be used within a CommandProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/contexts/CommandProvider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/e2e/helpers/exposeSignals.ts","messages":[{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":6,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":6,"endColumn":30}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { commandLineSignal } from '../../signals/commandLineSignals';\n\n/**\n * Exposes signals to the window object for e2e testing\n */\nexport function exposeSignals() {\n    (window as { commandLineSignal: typeof commandLineSignal }).commandLineSignal = commandLineSignal;\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/e2e/page-objects/TerminalPage.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":74,"column":12,"nodeType":"AwaitExpression","messageId":"conditionErrorNullableString","endLine":74,"endColumn":43,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2118,2149],"text":"((await this.output.textContent()) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2118,2149],"text":"((await this.output.textContent()) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2118,2149],"text":"(Boolean((await this.output.textContent())))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":90,"column":12,"nodeType":"Identifier","messageId":"conditionErrorString","endLine":90,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[2674,2685],"text":"(commandLine.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[2674,2685],"text":"(commandLine !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2674,2685],"text":"(Boolean(commandLine))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":134,"column":14,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":134,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4076,4080],"text":"(term != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type Page, type Locator, expect } from '@playwright/test';\n\nimport { TERMINAL_CONSTANTS } from 'src/constants/terminal';\n\nexport class TerminalPage {\n  readonly page: Page;\n  readonly terminal: Locator;\n  readonly output: Locator;\n  readonly tutorialMode: Locator;\n  readonly gameMode: Locator;\n  readonly nextChars: Locator;\n  private readonly prompt = TERMINAL_CONSTANTS.PROMPT;\n\n  constructor(page: Page) {\n    this.page = page;\n    this.terminal = page.locator('#xtermRef');\n    this.output = page.locator('#output-container');\n    this.tutorialMode = page.locator('.tutorial-component');\n    this.gameMode = page.locator('#terminal-game');\n    this.nextChars = page.locator('pre#next-chars');\n  }\n\n  public async goto(): Promise<void> {\n    await this.page.goto('/');\n    // Wait for the signal to be exposed\n    await this.page.waitForFunction(() => 'commandLineSignal' in window);\n    await this.waitForTerminal();\n    await this.waitForPrompt();\n  }\n\n  /**\n   * Types a command into the terminal\n   * @param command The command to type\n   */\n  public async typeCommand(command: string): Promise<void> {\n    await this.waitForTerminal();\n    await this.terminal.click();\n    await this.page.keyboard.type(command);\n  }\n\n  /**\n   * Types a sequence of keys without executing a command\n   * @param keys The keys to type\n   */\n  public async typeKeys(keys: string): Promise<void> {\n    await this.waitForTerminal();\n    await this.terminal.click();\n    await this.page.keyboard.type(keys);\n  }\n\n  /**\n   * Presses the Enter key\n   */\n  public async pressEnter(): Promise<void> {\n    await this.waitForTerminal();\n    await this.page.keyboard.press('Enter');\n  }\n\n  /**\n   * Executes a command by typing it and pressing Enter\n   * @param command The command to execute\n   */\n  public async executeCommand(command: string): Promise<void> {\n    await this.waitForTerminal();\n    await this.typeCommand(command);\n    await this.pressEnter();\n  }\n\n  /**\n   * Gets the current terminal output\n   * @returns The text content of the output container\n   */\n  public async getOutput(): Promise<string> {\n    return await this.output.textContent() || '';\n  }\n\n  /**\n   * Gets the current command line text (without the prompt)\n   * @returns The current command line text\n   */\n  public async getCurrentCommand(): Promise<string> {\n    // Wait for the signal to be available\n    await this.page.waitForFunction(() => 'commandLineSignal' in window);\n\n    // Get the value from commandLineSignal\n    const commandLine = await this.page.evaluate(() => {\n      return (window as unknown as { commandLineSignal: { value: string } }).commandLineSignal.value;\n    });\n\n    return commandLine || '';\n  }\n\n  /**\n   * Waits for specific text to appear in the output\n   * @param text The text to wait for\n   */\n  public async waitForOutput(text: string): Promise<void> {\n    await this.output.getByText(text, { exact: false }).waitFor();\n  }\n\n  /**\n   * Waits for specific text to appear in the next chars display\n   * @param text The text to wait for\n   */\n  public async waitForNextChars(text: string): Promise<void> {\n    // First wait for the element to exist\n    await this.nextChars.waitFor({ state: 'attached' });\n\n    // Then wait for the specific text\n    await this.nextChars.waitFor({ state: 'visible' });\n    await expect(this.nextChars).toHaveText(text, { timeout: 10000 });\n  }\n\n  /**\n   * Waits for the prompt to appear, indicating the terminal is ready\n   */\n  public async waitForPrompt(): Promise<void> {\n    await this.terminal.getByText(this.prompt).last().waitFor();\n  }\n\n  /**\n   * Waits for the terminal to be ready\n   */\n  public async waitForTerminal(): Promise<void> {\n    // Wait for terminal element to exist\n    await this.terminal.waitFor({ state: 'attached', timeout: 60000 });\n\n    // Wait for terminal to be visible\n    await this.terminal.waitFor({ state: 'visible', timeout: 60000 });\n\n    // Additional check for terminal initialization\n    await this.page.waitForFunction(() => {\n      const term = document.querySelector('#xtermRef');\n      return term && term.childElementCount > 0;\n    }, { timeout: 60000 });\n  }\n\n  /**\n   * Focuses the terminal\n   */\n  public async focus(): Promise<void> {\n    await this.terminal.click();\n  }\n\n  /**\n   * Clears the current command line using Ctrl+C\n   */\n  public async clearLine(): Promise<void> {\n    await this.terminal.click();\n    await this.page.keyboard.press('Control+C');\n    await this.waitForPrompt();\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/e2e/scenarios/activitySwitchingScenarios.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/e2e/testDescriptionParser.ts","messages":[{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":5,"column":59,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":5,"endColumn":61}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createLogger } from 'src/utils/Logger';\n\nconst logger = createLogger({ prefix: 'TestDescriptionParser' });\n\nexport const parseTestDescription = (description: string) => {\n  logger.info('Parsing test description:', description);\n  return description;\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/e2e/tests/tutorial.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'page' is defined but never used. Allowed unused args must match /^_[a-zA-Z][a-zA-Z0-9]*$/u.","line":16,"column":92,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":96}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { test, expect } from '@playwright/test';\n\nimport { TerminalPage } from '../page-objects/TerminalPage';\n\nlet terminalPage: TerminalPage;\n\ntest.beforeEach(async ({ page }) => {\n  terminalPage = new TerminalPage(page);\n\n  // Clear localStorage using a command\n  await terminalPage.executeCommand('clear');\n\n  await terminalPage.goto();\n});\n\ntest('should progress from tutorial to game mode after completing initial steps', async ({ page }) => {\n  // Given the user is in tutorial mode\n  await expect(terminalPage.tutorialMode).toBeVisible();\n\n  // When the user types \"Enter\"\n  await terminalPage.pressEnter();\n  await terminalPage.waitForPrompt();\n\n  // Type \"fdsa\" first time\n  await terminalPage.typeKeys('fdsa');\n  await terminalPage.pressEnter();\n  await terminalPage.waitForPrompt();\n\n  // Type \"fdsa\" second time with spaces\n  await terminalPage.typeKeys('f d s a');\n  await terminalPage.pressEnter();\n  await terminalPage.waitForPrompt();\n\n  // And the user types \"jkl;\"\n  await terminalPage.typeKeys('jkl;');\n  await terminalPage.pressEnter();\n  await terminalPage.waitForPrompt();\n\n  // Then the Activity should change from Tutorial to Game\n  await expect(terminalPage.tutorialMode).not.toBeVisible({ timeout: 10000 });\n  await expect(terminalPage.gameMode).toBeVisible({ timeout: 10000 });\n\n  // Wait for and verify the game phrase\n  await terminalPage.waitForNextChars('all sad lads ask dad; alas fads fall');\n\n  // When the user types \"all sad lads ask dad; alas fads fall\"\n  await terminalPage.typeKeys('all sad lads ask dad; alas fads fall');\n  await terminalPage.pressEnter();\n  await terminalPage.waitForPrompt();\n\n  // Then the user is returned to the tutorial\n  await expect(terminalPage.gameMode).not.toBeVisible({ timeout: 10000 });\n  await expect(terminalPage.tutorialMode).toBeVisible({ timeout: 10000 });\n});\n\ntest('should start in tutorial mode with clean state', async () => {\n  // This test will start fresh because of new context\n  await expect(terminalPage.tutorialMode).toBeVisible();\n  await expect(terminalPage.gameMode).not.toBeVisible();\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/Game.tsx","messages":[{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":104,"column":5,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":107,"endColumn":6},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":126,"column":5,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":128,"endColumn":6},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":131,"column":5,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":137,"endColumn":6},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":139,"column":5,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":151,"endColumn":6},{"ruleId":"no-param-reassign","severity":1,"message":"Assignment to function parameter 'show'.","line":175,"column":24,"nodeType":"Identifier","messageId":"assignmentToFunctionParam","endLine":175,"endColumn":28},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":212,"column":5,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":215,"endColumn":6},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":229,"column":5,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":231,"endColumn":6},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":236,"column":5,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":240,"endColumn":6},{"ruleId":"no-param-reassign","severity":1,"message":"Assignment to function parameter 'setLevelValue'.","line":253,"column":7,"nodeType":"Identifier","messageId":"assignmentToFunctionParam","endLine":253,"endColumn":20},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":262,"column":5,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":264,"endColumn":6},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":276,"column":5,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":278,"endColumn":6},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":283,"column":7,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":285,"endColumn":8},{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":290,"column":5,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":292,"endColumn":6}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// TerminalGame.ts\nimport { useState, useEffect, useRef, useImperativeHandle, useCallback, useMemo, forwardRef } from 'react';\n\nimport confetti from 'canvas-confetti';\n\nimport { useComputed, useSignalEffect } from \"@preact/signals-react\";\n\nimport { commandLineSignal } from \"../signals/commandLineSignals\";\nimport { isInGameModeSignal } from '../signals/gameSignals';\nimport { createLogger, LogLevel } from '../utils/Logger';\n\nimport { Hero } from './Hero';\nimport { layers, getLevelCount } from './Level';\nimport { type IParallaxLayer, ParallaxLayer } from './ParallaxLayer';\nimport ScrollingTextLayer from './ScrollingTextLayer';\nimport { type Sprite } from './sprites/Sprite';\nimport { type Action, type ActionType } from './types/ActionTypes';\nimport { type SpritePosition } from './types/Position';\nimport { Zombie4 } from './Zombie4';\n\nconst logger = createLogger({\n  prefix: 'Game',\n  level: LogLevel.DEBUG\n});\n\ninterface ICharacterRefMethods {\n  getCurrentSprite: () => Sprite | null;\n  getActions: () => Record<ActionType, Action>;\n  positionRef: SpritePosition;\n  draw: (context: CanvasRenderingContext2D, position: SpritePosition) => number;\n}\n\ninterface IGameProps {\n  canvasHeight: number;\n  canvasWidth: number;\n}\n\ninterface IGameHandle {\n  startGame: (tutorialGroup?: string) => void;\n  completeGame: () => void;\n  resetGame: () => void;\n  levelUp: (setLevelValue?: number | null) => void;\n}\n\nfunction GameFunction(props: IGameProps, ref: React.ForwardedRef<IGameHandle>): JSX.Element {\n  const {\n    canvasHeight,\n    canvasWidth,\n  } = props;\n\n  // Use useMemo to memoize static objects\n  const zombie4StartPosition = useMemo(() => ({ leftX: 0, topY: 0 }), []);\n  const heroStartPosition = useMemo(() => ({ leftX: 165, topY: 29 }), []);\n  const heroXPercent = 0.23;\n\n  const zombie4PositionRef = useRef<SpritePosition>(zombie4StartPosition);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const heroRef = useRef<ICharacterRefMethods>(null);\n  const zombie4Ref = useRef<ICharacterRefMethods>(null);\n  const animationFrameIndex = useRef<number | undefined>(undefined);\n  const zombie4DeathTimeout = useRef<NodeJS.Timeout | null>(null);\n  const heroRunTimeoutRef = useRef<number | null>(null);\n\n  const heroPositionRef = useRef<SpritePosition>(heroStartPosition);\n  const [heroPosition, setHeroPosition] = useState<SpritePosition>({ leftX: canvasWidth * heroXPercent, topY: 30 });\n\n  const [currentLevel, setCurrentLevel] = useState(1);\n  const [context, setContext] = useState<CanvasRenderingContext2D | null>(null);\n  const [backgroundOffsetX, setBackgroundOffsetX] = useState(0);\n  const [isPhraseComplete, setIsPhraseComplete] = useState(false);\n  const [isTextScrolling, setIsTextScrolling] = useState(false);\n  const [heroAction, setHeroAction] = useState<ActionType>('Idle');\n  const [zombie4Action, setZombie4Action] = useState<ActionType>('Walk');\n  const textToScroll = \"TERMINAL VELOCITY!\";\n  const [layersState, setLayersState] = useState<IParallaxLayer[]>(layers[0] ?? []);\n\n  const commandLine = useComputed(() => commandLineSignal.value);\n  const isInGameMode = useComputed(() => isInGameModeSignal.value).value;\n\n  // Memoize getLevel to prevent unnecessary re-renders\n  const getLevel = useCallback(() => currentLevel, [currentLevel]);\n\n  const stopAnimationLoop = useCallback(() => {\n    const frameId = animationFrameIndex.current;\n    if (typeof frameId === 'number' && !Number.isNaN(frameId)) {\n      cancelAnimationFrame(frameId);\n      animationFrameIndex.current = undefined;\n    }\n  }, []);\n\n  const triggerConfettiCannon = useCallback(() => {\n    void confetti({\n      zIndex: 3,\n      angle: 160,\n      spread: 45,\n      startVelocity: 45,\n      particleCount: 150,\n      origin: { x: 0.99, y: 0.8 }\n    });\n  }, []);\n\n  const setZombie4ToDeathThenResetPosition = useCallback(() => {\n    const timeout = zombie4DeathTimeout.current;\n    if (timeout !== null) {\n      clearTimeout(timeout);\n      zombie4DeathTimeout.current = null;\n    }\n\n    setZombie4Action('Death');\n    zombie4DeathTimeout.current = setTimeout(() => {\n      setZombie4Action('Walk');\n      zombie4PositionRef.current = zombie4StartPosition;\n      setIsPhraseComplete(false);\n      zombie4DeathTimeout.current = null;\n    }, 3000);\n  }, [zombie4StartPosition]);\n\n  const updateCharacterAndBackgroundPostion = useCallback((context: CanvasRenderingContext2D): number => {\n    const canvasCenterX = canvasWidth * heroXPercent;\n    const characterReachThreshold = canvasCenterX;\n\n    context.clearRect(0, 0, canvasWidth, canvasHeight);\n\n    let heroDx = 0;\n    const hero = heroRef.current;\n    if (hero !== null) {\n      heroDx = hero.draw(context, heroPosition);\n    }\n\n    const zombie = zombie4Ref.current;\n    if (zombie !== null) {\n      const zombie4Dx = zombie.draw(context, zombie4PositionRef.current);\n      zombie4PositionRef.current = {\n        ...zombie4PositionRef.current,\n        leftX: zombie4PositionRef.current.leftX + zombie4Dx - heroDx\n      };\n    }\n\n    if (heroDx !== 0) {\n      setBackgroundOffsetX(prev => prev + heroDx);\n\n      if (heroPosition.leftX >= characterReachThreshold) {\n        setHeroPosition(prev => ({ ...prev, leftX: characterReachThreshold }));\n      }\n\n      const newZombie4PositionX = zombie4PositionRef.current.leftX - heroDx;\n      zombie4PositionRef.current = {\n        ...zombie4PositionRef.current,\n        leftX: newZombie4PositionX\n      };\n    }\n    return heroDx;\n  }, [canvasWidth, canvasHeight, heroPosition]);\n\n  const checkProximityAndSetAction = useCallback(() => {\n    const ATTACK_THRESHOLD = 100;\n    const distance = heroPosition.leftX - zombie4PositionRef.current.leftX;\n\n    if (-20 < distance && distance < ATTACK_THRESHOLD) {\n      setZombie4Action('Attack');\n      if (distance < 50) {\n        setHeroAction('Hurt');\n      }\n      if (distance < 30) {\n        setHeroAction('Death');\n      }\n    } else {\n      if (zombie4Action === 'Attack') {\n        setZombie4Action('Walk');\n      }\n    }\n  }, [heroPosition, zombie4Action, setHeroAction]);\n\n  const toggleScrollingText = useCallback((show: boolean | null = null) => {\n    if (show === null) show = !isTextScrolling;\n    setIsTextScrolling(show);\n  }, [isTextScrolling]);\n\n  const drawScrollingText = useCallback(() => {\n    toggleScrollingText(true);\n    setTimeout(() => {\n      toggleScrollingText(false);\n    }, 3000);\n  }, [toggleScrollingText]);\n\n  const startAnimationLoop = useCallback((context: CanvasRenderingContext2D) => {\n    const frameDelay = 150;\n    let lastFrameTime = performance.now();\n\n    const loop = () => {\n      const now = performance.now();\n      const deltaTime = now - lastFrameTime;\n\n      if (typeof deltaTime === 'number' && !Number.isNaN(deltaTime) && deltaTime >= frameDelay) {\n        lastFrameTime = now - (deltaTime % frameDelay);\n\n        if (isPhraseComplete) {\n          drawScrollingText();\n        }\n\n        updateCharacterAndBackgroundPostion(context);\n        checkProximityAndSetAction();\n      }\n      animationFrameIndex.current = requestAnimationFrame(loop);\n    };\n\n    animationFrameIndex.current = requestAnimationFrame(loop);\n  }, [isPhraseComplete, drawScrollingText, updateCharacterAndBackgroundPostion, checkProximityAndSetAction]);\n\n  const setHeroRunAction = useCallback(() => {\n    const timeout = heroRunTimeoutRef.current;\n    if (timeout !== null) {\n      clearTimeout(timeout);\n      heroRunTimeoutRef.current = null;\n    }\n\n    setHeroAction('Run');\n    heroRunTimeoutRef.current = window.setTimeout(() => {\n      setHeroAction('Idle');\n      heroRunTimeoutRef.current = null;\n    }, 800);\n  }, [setHeroAction]);\n\n  const handleCommandLineChange = useCallback(() => {\n    setHeroRunAction();\n  }, [setHeroRunAction]);\n\n  useSignalEffect(() => {\n    if (commandLine.value?.trim() !== '') {\n      handleCommandLineChange();\n    }\n  });\n\n  const setupCanvas = useCallback((canvas: HTMLCanvasElement) => {\n    const canvasContext = canvas.getContext('2d');\n    if (canvasContext !== null) {\n      setContext(canvasContext);\n    } else {\n      logger.error(\"Failed to get canvas context.\");\n    }\n  }, []);\n\n  const setLevel = useCallback((newLevel: number) => {\n    const levelIndex = Math.max(0, Math.min(newLevel - 1, layers.length - 1));\n    const newLayers = layers[levelIndex] ?? [];\n    setCurrentLevel(newLevel);\n    setLayersState(newLayers);\n  }, []);\n\n  const levelUp = useCallback((setLevelValue: number | null = null) => {\n    const levelCount = getLevelCount();\n    if (setLevelValue !== null && setLevelValue > levelCount) {\n      setLevelValue = levelCount;\n    }\n    let nextLevel = setLevelValue !== null ? setLevelValue : getLevel() + 1;\n    if (nextLevel > levelCount) nextLevel = 0;\n    if (nextLevel < 1) nextLevel = 1;\n    setLevel(nextLevel);\n  }, [setLevel, getLevel]);\n\n  const startGame = useCallback(() => {\n    if (context !== null) {\n      startAnimationLoop(context);\n    }\n    setIsPhraseComplete(false);\n  }, [context, startAnimationLoop]);\n\n  const completeGame = useCallback(() => {\n    setZombie4ToDeathThenResetPosition();\n    triggerConfettiCannon();\n    setIsPhraseComplete(true);\n  }, [setZombie4ToDeathThenResetPosition, triggerConfettiCannon]);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (canvas !== null) {\n      setupCanvas(canvas);\n    }\n\n    return () => {\n      stopAnimationLoop();\n      const timeout = zombie4DeathTimeout.current;\n      if (timeout !== null) {\n        clearTimeout(timeout);\n      }\n    };\n  }, [setupCanvas, stopAnimationLoop]);\n\n  useEffect(() => {\n    if (context !== null) {\n      startAnimationLoop(context);\n    }\n  }, [context, startAnimationLoop]);\n\n  useImperativeHandle(ref, () => ({\n    startGame,\n    completeGame,\n    resetGame: () => {\n      zombie4PositionRef.current = zombie4StartPosition;\n      setIsPhraseComplete(false);\n    },\n    levelUp,\n  }), [startGame, completeGame, levelUp, zombie4StartPosition]);\n\n  if (!isInGameMode) {\n    return <div />;\n  }\n\n  return (\n    <div\n      id=\"terminal-game\"\n      style={{ position: \"relative\", height: canvasHeight }}\n    >\n      <div className=\"parallax-background\">\n        {isTextScrolling && (\n          <ScrollingTextLayer\n            text={textToScroll}\n            canvasHeight={canvasHeight}\n          />\n        )}\n        {layersState.map((layer, index) => (\n          <ParallaxLayer\n            key={index}\n            layer={layer}\n            offset={backgroundOffsetX}\n            canvasHeight={canvasHeight}\n          />\n        ))}\n      </div>\n      <canvas\n        data-testid=\"game-canvas\"\n        style={{ position: \"absolute\", top: 0, left: 0, zIndex: 2 }}\n        ref={canvasRef}\n        width={canvasWidth}\n        height={canvasHeight}\n      />\n      <Hero\n        ref={heroRef}\n        positionRef={heroPositionRef}\n        currentActionType={heroAction}\n        scale={1.95}\n      />\n      <Zombie4\n        ref={zombie4Ref}\n        positionRef={zombie4PositionRef}\n        currentActionType={zombie4Action}\n        scale={1.90}\n      />\n    </div>\n  );\n}\n\nexport type { IGameHandle, IGameProps };\nexport const Game = forwardRef(GameFunction);\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/GameClock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/Hero.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/ICharacterProps.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/Level.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/ParallaxLayer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/ScrollingTextLayer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/SpriteManagerContext.tsx","messages":[{"ruleId":"import/no-named-as-default-member","severity":1,"message":"Caution: `React` also has a named export `createContext`. Check if you meant to write `import {createContext} from 'react'` instead.","line":7,"column":30,"nodeType":"MemberExpression","endLine":7,"endColumn":49}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// SpriteManagerContext.tsx\nimport React from 'react';\n\nimport { type SpriteManager } from './sprites/SpriteManager';\n\n// Create a context with a default undefined value\nconst SpriteManagerContext = React.createContext<SpriteManager | undefined>(undefined);\n\nexport default SpriteManagerContext;","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/TypeScriptStateMachine.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/Zombie4.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/__tests__/Game.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/characters/hero/HeroAnimations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/characters/zombie4/Zombie4Animations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/sprites/Sprite.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/sprites/SpriteManager.tsx","messages":[{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":18,"column":13,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":20,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createLogger, LogLevel } from 'src/utils/Logger';\n\nimport { type SpriteAnimation } from '../types/SpriteTypes';\n\nimport { Sprite } from './Sprite';\n\nconst logger = createLogger({\n  prefix: 'SpriteManager',\n  level: LogLevel.ERROR\n});\n\nexport class SpriteManager {\n    private spriteCache = new Map<string, Sprite>();\n\n    public async loadSprite(animationData: SpriteAnimation): Promise<Sprite> {\n        if (this.spriteCache.has(animationData.imagePath)) {\n            const cachedSprite = this.spriteCache.get(animationData.imagePath);\n            if (cachedSprite !== undefined) {\n                return cachedSprite;\n            }\n        }\n\n        const sprite = new Sprite(animationData.imagePath, animationData.frameCount, animationData.frameWidth, animationData.frameHeight, animationData.framePositions);\n        await this.waitForManagerImageLoad(sprite.image);\n\n        this.spriteCache.set(animationData.imagePath, sprite);\n        return sprite;\n    }\n\n    private waitForManagerImageLoad(image: HTMLImageElement): Promise<void> {\n        return new Promise((resolve, reject) => {\n            const onLoad = () => {\n                // Cleanup: Remove both event listeners\n                image.removeEventListener('load', onLoad);\n                image.removeEventListener('error', onError);\n                resolve();\n            };\n\n            const onError = () => {\n                // Cleanup: Remove both event listeners\n                image.removeEventListener('load', onLoad);\n                image.removeEventListener('error', onError);\n                logger.error('Image failed to load: ' + image.src);\n                reject(new Error(`Image failed to load: ${image.src}`)); // Reject the promise on error\n            };\n\n            // Attach the event listeners\n            image.addEventListener('load', onLoad);\n            image.addEventListener('error', onError);\n        });\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/types/ActionTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/types/Position.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/types/SpriteTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/game/useBaseCharacter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/activityMachine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useAPI.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":76,"column":34,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":76,"endColumn":66,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2188,2220],"text":"((apiError.response?.data?.message) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2188,2220],"text":"((apiError.response?.data?.message) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2188,2220],"text":"(Boolean((apiError.response?.data?.message)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":77,"column":34,"nodeType":"MemberExpression","messageId":"conditionErrorString","endLine":77,"endColumn":50,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[2257,2273],"text":"(apiError.message.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[2257,2273],"text":"(apiError.message !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2257,2273],"text":"(Boolean(apiError.message))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":80,"column":50,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":80,"endColumn":64},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":80,"column":68,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":80,"endColumn":88},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":85,"column":25,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":85,"endColumn":50,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2555,2580],"text":"((apiError.response?.status) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[2555,2580],"text":"((apiError.response?.status) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2555,2580],"text":"(Boolean((apiError.response?.status)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'auth'. Either include it or remove the dependency array.","line":89,"column":8,"nodeType":"ArrayExpression","endLine":89,"endColumn":38,"suggestions":[{"desc":"Update the dependencies array to be: [auth]","fix":{"range":[2657,2687],"text":"[auth]"}}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":94,"column":17,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":94,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2905,2909],"text":"(path != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2905,2909],"text":"(path ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2905,2909],"text":"(Boolean(path))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":95,"column":17,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":95,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2940,2943],"text":"(sha != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2940,2943],"text":"(sha ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2940,2943],"text":"(Boolean(sha))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback } from 'react';\nimport axios, { type AxiosError } from 'axios';\n\nimport ENDPOINTS from '../shared/endpoints.json';\nimport { type IAuthProps } from './useAuth';\n\ninterface APIResponse<T> {\n    status: number;\n    data?: T;\n    error?: string;\n}\n\ninterface FileContentResponse {\n    content: string;\n    encoding?: string;\n    sha?: string;\n}\n\ninterface TreeItemResponse {\n    path: string;\n    type: string;\n    sha?: string;\n    size?: number;\n}\n\ninterface RepoResponse {\n    name: string;\n    description?: string;\n    private: boolean;\n    default_branch: string;\n}\n\ninterface APIError {\n    status: number;\n    message: string;\n}\n\nexport function useAPI(auth: IAuthProps): {\n    getRepoTree: (repo: string, path?: string, sha?: string) => Promise<APIResponse<TreeItemResponse[]>>,\n    getFileContent: (repo: string, path: string) => Promise<APIResponse<FileContentResponse>>,\n    listRecentRepos: () => Promise<APIResponse<RepoResponse[]>>\n} {\n    const makeAuthenticatedRequest = useCallback(async <T,>(\n        endpoint: string,\n        params?: Record<string, string>,\n        method: 'GET' | 'POST' = 'GET'\n    ): Promise<APIResponse<T>> => {\n        try {\n            const authResponse = await auth.validateAndRefreshToken();\n            if (authResponse == null || authResponse.status !== 200 || authResponse.data == null) {\n                return {\n                    status: 401,\n                    error: 'Authentication failed'\n                };\n            }\n\n            const response = await axios({\n                method,\n                url: `${ENDPOINTS.api.BaseUrl}${endpoint}`,\n                headers: {\n                    'Authorization': `Bearer ${authResponse.data.accessToken}`,\n                    'Content-Type': 'application/json',\n                    'Accept': 'application/json'\n                },\n                params\n            });\n\n            return {\n                status: response.status,\n                data: response.data as T\n            };\n        } catch (error) {\n            const apiError = error as AxiosError<APIError>;\n\n            // Log error without using console.error\n            const errorMessage = apiError.response?.data?.message ||\n                                 apiError.message ||\n                                 'Request failed';\n\n            if (typeof window !== 'undefined' && window.console && window.console.error) {\n                window.console.error('API request failed:', errorMessage);\n            }\n\n            return {\n                status: apiError.response?.status || 500,\n                error: errorMessage\n            };\n        }\n    }, [auth.validateAndRefreshToken]);\n\n    const getRepoTree = useCallback(async (repo: string, path?: string, sha?: string) => {\n        return makeAuthenticatedRequest<TreeItemResponse[]>(ENDPOINTS.api.GetRepoTree, {\n            repo,\n            ...(path && { path }),\n            ...(sha && { sha })\n        });\n    }, [makeAuthenticatedRequest]);\n\n    const getFileContent = useCallback(async (repo: string, path: string) => {\n        return makeAuthenticatedRequest<FileContentResponse>('/github/file', {\n            repo,\n            path\n        });\n    }, [makeAuthenticatedRequest]);\n\n    const listRecentRepos = useCallback(async () => {\n        return makeAuthenticatedRequest<RepoResponse[]>(ENDPOINTS.api.ListRecentRepos);\n    }, [makeAuthenticatedRequest]);\n\n    return {\n        getRepoTree,\n        getFileContent,\n        listRecentRepos\n    };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useActivityMediator.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useActivityMediator.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":52,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":52,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2141,2149],"text":"groupKey != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2141,2149],"text":"groupKey ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2141,2149],"text":"Boolean(groupKey)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":78,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":78,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3012,3032],"text":"(tutorialSignal.value != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":78,"column":38,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":78,"endColumn":73,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3036,3072],"text":"((tutorialSignal.value?.tutorialGroup) == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3037,3072],"text":"((tutorialSignal.value?.tutorialGroup) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3036,3072],"text":"(!Boolean((tutorialSignal.value?.tutorialGroup)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":82,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":82,"endColumn":39,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3175,3201],"text":"(currentTutorialRef.current != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":82,"column":43,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":82,"endColumn":84,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3205,3246],"text":"((currentTutorialRef.current?.tutorialGroup) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3205,3246],"text":"((currentTutorialRef.current?.tutorialGroup) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3205,3246],"text":"(Boolean((currentTutorialRef.current?.tutorialGroup)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":85,"column":13,"nodeType":"CallExpression","messageId":"conditionErrorNullableObject","endLine":85,"endColumn":30,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3344,3361],"text":"getNextTutorial() != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-param-reassign","severity":1,"message":"Assignment to function parameter 'commandActivity'.","line":85,"column":32,"nodeType":"Identifier","messageId":"assignmentToFunctionParam","endLine":85,"endColumn":47},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":94,"column":13,"nodeType":"Identifier","messageId":"conditionErrorString","endLine":94,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[3762,3770],"text":"groupKey.length > 0"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[3762,3770],"text":"groupKey !== \"\""},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3762,3770],"text":"Boolean(groupKey)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":96,"column":17,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":96,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3878,3895],"text":"nextPhraseInGroup != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":106,"column":17,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":106,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4357,4369],"text":"nextTutorial != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":118,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":118,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4787,4801],"text":"nextGamePhrase != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'decideActivityChange'. Either include it or remove the dependency array.","line":125,"column":8,"nodeType":"ArrayExpression","endLine":125,"endColumn":57,"suggestions":[{"desc":"Update the dependencies array to be: [decideActivityChange, getIncompleteTutorialsInGroup, transitionToGame]","fix":{"range":[5072,5121],"text":"[decideActivityChange, getIncompleteTutorialsInGroup, transitionToGame]"}}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":136,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":136,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5490,5517],"text":"currentTutorialRef.current == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"no-param-reassign","severity":1,"message":"Assignment to function parameter 'command'.","line":143,"column":9,"nodeType":"Identifier","messageId":"assignmentToFunctionParam","endLine":143,"endColumn":16},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":144,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":144,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5770,5777],"text":"command != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[5770,5777],"text":"command ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5770,5777],"text":"Boolean(command)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":154,"column":21,"nodeType":"Identifier","messageId":"conditionErrorString","endLine":154,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[6251,6259],"text":"groupKey.length > 0"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[6251,6259],"text":"groupKey !== \"\""},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6251,6259],"text":"Boolean(groupKey)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":156,"column":25,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":156,"endColumn":49,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6390,6414],"text":"incompletePhrasesInGroup != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":176,"column":13,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":176,"endColumn":33,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7178,7198],"text":"(nextTutorial?.phrase) != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[7178,7198],"text":"(nextTutorial?.phrase) ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[7178,7198],"text":"Boolean((nextTutorial?.phrase))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":187,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":187,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7612,7626],"text":"nextGamePhrase != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'decideActivityChange'. Either include it or remove the dependency array.","line":191,"column":8,"nodeType":"ArrayExpression","endLine":191,"endColumn":45,"suggestions":[{"desc":"Update the dependencies array to be: [canUnlockTutorial, decideActivityChange, transitionToGame]","fix":{"range":[7724,7761],"text":"[canUnlockTutorial, decideActivityChange, transitionToGame]"}}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":199,"column":71,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":199,"endColumn":97,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8149,8175],"text":"(parseLocation().contentKey != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[8149,8175],"text":"(parseLocation().contentKey ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[8149,8175],"text":"(Boolean(parseLocation().contentKey))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":201,"column":17,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":201,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8291,8301],"text":"gamePhrase != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":22,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useEffect, useRef } from 'react';\nimport { useComputed } from '@preact/signals-react';\n\nimport { activitySignal, setNotification, bypassTutorialSignal } from 'src/signals/appSignals';\nimport {\n    getIncompletePhrasesByTutorialGroup, initializeGame,\n    setCompletedGamePhrase,\n    getNextGamePhrase,\n    setGamePhrase,\n} from 'src/signals/gameSignals';\nimport {\n    setNextTutorial, resetCompletedTutorials,\n    tutorialSignal, getNextTutorial, setCompletedTutorial\n} from 'src/signals/tutorialSignals';\nimport { createLogger } from 'src/utils/Logger';\nimport { navigate, parseLocation } from 'src/utils/navigationUtils';\n\nimport { type ActionType } from '../game/types/ActionTypes';\nimport { ActivityType, type ParsedCommand, type GamePhrase, type Tutorial } from '../types/Types';\nimport GamePhrases from '../utils/GamePhrases';\n\nimport { useTutorial } from './useTutorials';\n\n\nconst logger = createLogger({ prefix: 'ActivityMediator' });\n\nexport function useActivityMediator(): {\n    isInGameMode: boolean;\n    isInTutorial: boolean;\n    isInEdit: boolean;\n    isInNormal: boolean;\n    checkTutorialProgress: (command: string | null) => void;\n    heroAction: ActionType;\n    zombie4Action: ActionType;\n    handleCommandExecuted: (parsedCommand: ParsedCommand) => boolean;\n    setHeroAction: React.Dispatch<React.SetStateAction<ActionType>>;\n    setZombie4Action: React.Dispatch<React.SetStateAction<ActionType>>;\n    checkGameProgress: (successPhrase: GamePhrase) => void;\n} {\n    const [heroAction, setHeroAction] = useState<ActionType>('Idle');\n    const [zombie4Action, setZombie4Action] = useState<ActionType>('Walk');\n    const {\n        getIncompleteTutorialsInGroup,\n        canUnlockTutorial\n    } = useTutorial();\n    const activity = useComputed(() => activitySignal.value).value;\n    const bypassTutorial = useComputed(() => bypassTutorialSignal.value);\n    const currentTutorialRef = useRef<Tutorial | null>(null);\n\n    const transitionToGame = useCallback((contentKey?: string | null, groupKey?: string | null): void => {\n        // First initialize game if group key is provided\n        if (groupKey) {\n            initializeGame(groupKey);\n        } else {\n            initializeGame();\n        }\n        // Then update activity and navigate\n        activitySignal.value = ActivityType.GAME;\n        navigate({\n            activityKey: ActivityType.GAME,\n            contentKey: contentKey ?? null,\n            groupKey: groupKey ?? null\n        });\n    }, []);\n\n    const decideActivityChange = useCallback((commandActivity: ActivityType | null = null): ActivityType => {\n        logger.debug('Deciding activity change:', {\n            commandActivity,\n            currentActivity: activity,\n            bypassTutorial: bypassTutorial.value,\n            currentTutorial: tutorialSignal.value\n        });\n\n        const bypassTutorialValue = bypassTutorial.value;\n        if (bypassTutorialValue) {\n            return ActivityType.NORMAL;\n        }\n        if (tutorialSignal.value && !tutorialSignal.value?.tutorialGroup && activity !== ActivityType.GAME) {\n            return ActivityType.TUTORIAL;\n        }\n\n        if (currentTutorialRef.current && currentTutorialRef.current?.tutorialGroup && activity !== ActivityType.GAME) {\n            return ActivityType.GAME;\n        }\n        if (getNextTutorial()) commandActivity = ActivityType.TUTORIAL;\n\n        return commandActivity ?? ActivityType.NORMAL;\n    }, [activity, bypassTutorial.value]);\n\n    const checkGameProgress = useCallback((successPhrase: GamePhrase) => {\n        logger.debug('Checking game progress:', successPhrase);\n        const groupKey = parseLocation().groupKey ?? '';\n        setCompletedGamePhrase(successPhrase.key);\n        if (groupKey) {\n            const nextPhraseInGroup = getIncompletePhrasesByTutorialGroup(groupKey)[0];\n            if (nextPhraseInGroup) {\n                setGamePhrase(getNextGamePhrase());\n                transitionToGame(nextPhraseInGroup.key, nextPhraseInGroup.tutorialGroup);\n                return;\n            }\n            const incompleteTutorialInGroup = getIncompleteTutorialsInGroup(groupKey);\n            incompleteTutorialInGroup.forEach(itig => {\n                setCompletedTutorial(itig.phrase);\n            });\n            const nextTutorial = getNextTutorial();\n            if (nextTutorial) {\n                const resultActivity = decideActivityChange(ActivityType.TUTORIAL);\n                navigate({\n                    activityKey: resultActivity,\n                    contentKey: nextTutorial.phrase ?? '',\n                    groupKey: nextTutorial.tutorialGroup ?? ''\n                })\n                return;\n            }\n        }\n\n        const nextGamePhrase = getNextGamePhrase();\n        if (nextGamePhrase) {\n            setGamePhrase(nextGamePhrase);\n            transitionToGame(nextGamePhrase.key, nextGamePhrase.tutorialGroup);\n            return;\n        }\n        activitySignal.value = ActivityType.NORMAL;\n        navigate({ activityKey: ActivityType.NORMAL })\n    }, [getIncompleteTutorialsInGroup, transitionToGame]);\n\n    const checkTutorialProgress = useCallback((command: string | null) => {\n        logger.debug('Checking tutorial progress:', {\n            command,\n            currentTutorial: tutorialSignal.value,\n            activity: activitySignal.value,\n            location: parseLocation()\n        });\n\n        currentTutorialRef.current = getNextTutorial();\n        if (!currentTutorialRef.current) {\n            logger.debug('No current tutorial found');\n            return;\n        }\n\n        const groupKey = parseLocation().groupKey ?? '';\n        // Normalize command for Enter key\n        command = command === '' ? '\\r' : command;\n        if (command) {\n            logger.debug('Checking if can unlock tutorial:', {\n                command,\n                currentPhrase: currentTutorialRef.current.phrase,\n                charCodesCommand: [...command].map(c => c.charCodeAt(0)),\n                charCodesPhrase: [...currentTutorialRef.current.phrase].map(c => c.charCodeAt(0))\n            });\n\n            if (canUnlockTutorial(command)) {\n                logger.debug('Tutorial unlocked:', command);\n                if (groupKey) {\n                    const incompletePhrasesInGroup = getIncompletePhrasesByTutorialGroup(groupKey)[0];\n                    if (incompletePhrasesInGroup) {\n                        transitionToGame(incompletePhrasesInGroup.key, incompletePhrasesInGroup.tutorialGroup);\n                    }\n                    return;\n                }\n                setCompletedTutorial(currentTutorialRef.current.phrase);\n            } else {\n                logger.debug('Tutorial not unlocked:', {\n                    expected: currentTutorialRef.current.phrase,\n                    received: command\n                });\n                setNotification(\n                    `Tutorial ${tutorialSignal.value?.phrase} not unlocked with ${command}`\n                )\n                return;\n            }\n        }\n\n        const nextTutorial = getNextTutorial();\n        logger.debug('Next tutorial:', nextTutorial);\n        if (nextTutorial?.phrase) {\n            const resultActivity = decideActivityChange(ActivityType.TUTORIAL);\n            setNextTutorial(nextTutorial);\n            navigate({\n                activityKey: resultActivity,\n                contentKey: nextTutorial.phrase,\n                groupKey: nextTutorial.tutorialGroup ?? null\n            })\n            return;\n        }\n        const nextGamePhrase = getNextGamePhrase();\n        if (nextGamePhrase) {\n            transitionToGame(nextGamePhrase?.key, groupKey);\n        }\n        return;\n    }, [canUnlockTutorial, transitionToGame]);\n\n    const handleCommandExecuted = useCallback((parsedCommand: ParsedCommand): boolean => {\n        logger.debug('Handling command:', parsedCommand);\n        let result = false;\n        if (parseLocation().activityKey === ActivityType.TUTORIAL) {\n            checkTutorialProgress(parsedCommand.command);\n        }\n        else if (parseLocation().activityKey === ActivityType.GAME && parseLocation().contentKey) {\n            const gamePhrase = GamePhrases.getGamePhraseByKey(parseLocation().contentKey ?? '')\n            if (gamePhrase) checkGameProgress(gamePhrase);\n        }\n        switch (parsedCommand.command) {\n            case 'play': {\n                const nextGamePhrase = getNextGamePhrase();\n                transitionToGame(nextGamePhrase?.key);\n                result = true;\n                break;\n            }\n            case 'tut': {\n                if ('r' in parsedCommand.switches) {\n                    resetCompletedTutorials();\n                }\n                const nextTutorial = getNextTutorial();\n                navigate({\n                    activityKey: ActivityType.TUTORIAL,\n                    contentKey: nextTutorial?.phrase ?? null,\n                    groupKey: nextTutorial?.tutorialGroup ?? null\n                })\n                result = true;\n                break;\n            }\n            default:\n                result = false;\n        }\n\n        return result;\n    }, [checkGameProgress, checkTutorialProgress, transitionToGame]);\n\n    useEffect(() => {\n        const resultActivity = decideActivityChange(null);\n        if (resultActivity === ActivityType.TUTORIAL) {\n            checkTutorialProgress(null);\n        }\n    }, [decideActivityChange, checkTutorialProgress]);\n\n    return {\n        isInGameMode: activity === ActivityType.GAME,\n        isInTutorial: activity === ActivityType.TUTORIAL,\n        isInEdit: activity === ActivityType.EDIT,\n        isInNormal: activity === ActivityType.NORMAL,\n        checkTutorialProgress,\n        heroAction,\n        zombie4Action,\n        handleCommandExecuted,\n        setHeroAction,\n        setZombie4Action,\n        checkGameProgress,\n    };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useAuth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useCharacterHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useCommand.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":55,"column":13,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":55,"endColumn":25},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":88,"column":17,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":88,"endColumn":55,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[3748,3786],"text":"(key?.startsWith(LogKeys.Command + '_')) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[3748,3786],"text":"(key?.startsWith(LogKeys.Command + '_')) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":95,"column":17,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":95,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3976,3987],"text":"historyJSON != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3976,3987],"text":"historyJSON ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3976,3987],"text":"Boolean(historyJSON)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":144,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":144,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5643,5650],"text":"(command != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":144,"column":24,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":144,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5654,5661],"text":"(context != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/hooks/useCommand.ts\nimport { useComputed } from '@preact/signals-react';\nimport type React from 'react';\nimport { useContext, useState, useCallback, useEffect } from 'react';\n\nimport { activitySignal, appendToOutput } from 'src/signals/appSignals';\nimport { setCommandTime } from 'src/signals/commandLineSignals';\nimport { createLogger } from 'src/utils/Logger';\n\nimport { commandRegistry } from '../commands/commandRegistry';\nimport { CommandContext, type ICommandResponse } from '../contexts/CommandContext';\nimport { LogKeys } from '../types/TerminalTypes';\nimport { ActivityType, type OutputElement, type ParsedCommand } from '../types/Types';\nimport { parsedCommandToString, loadCommandHistory, saveCommandHistory } from '../utils/commandUtils';\n\nimport { useActivityMediator } from './useActivityMediator';\nimport { useWPMCalculator } from './useWPMCaculator';\n\n\nconst logger: ReturnType<typeof createLogger> = createLogger({ prefix: 'useCommand' });\n\nexport const useCommand = (): {\n  output: OutputElement[];\n  resetOutput: () => void;\n  commandHistory: string[];\n  addToCommandHistory: (command: ParsedCommand | string) => void;\n  getCommandResponseHistory: () => string[];\n  handleCommand: (parsedCommand: ParsedCommand) => Promise<void>;\n  commandHistoryIndex: number;\n  setCommandHistoryIndex: React.Dispatch<React.SetStateAction<number>>;\n  commandHistoryFilter: string | null;\n  setCommandHistoryFilter: React.Dispatch<React.SetStateAction<string | null>>;\n  appendToOutput: (outputElement: OutputElement) => void;\n  executeCommand: (parsedCommand: ParsedCommand) => Promise<void>;\n} => {\n    const [output, setOutput] = useState<OutputElement[]>([]);\n    const [commandHistory, setCommandHistory] = useState<string[]>([]);\n    const [commandHistoryIndex, setCommandHistoryIndex] = useState(-1);\n    const [commandHistoryFilter, setCommandHistoryFilter] = useState<string | null>(null);\n    const currentActivity = useComputed(() => activitySignal.value);\n    const {\n        handleCommandExecuted,\n        checkTutorialProgress\n    } = useActivityMediator();\n    const wpmCalculator = useWPMCalculator();\n    const context = useContext(CommandContext);\n\n    if (context === undefined) {\n        throw new Error('useCommand must be used within a CommandProvider');\n    }\n\n    // Load command history from localStorage on mount\n    useEffect(() => {\n        const savedHistory = loadCommandHistory();\n        if (savedHistory && savedHistory.length > 0) {\n            logger.debug('Loaded command history:', savedHistory);\n            setCommandHistory(savedHistory);\n        }\n    }, []);\n\n    const resetOutput = useCallback((): void => {\n        logger.debug('Resetting output');\n        setOutput([]);\n    }, []);\n\n    const addToCommandHistory = useCallback((command: ParsedCommand | string): void => {\n        const commandString = typeof command === 'string'\n            ? command\n            : parsedCommandToString(command);\n\n        logger.debug('Adding to command history:', commandString);\n        setCommandHistory(prev => {\n            // Don't add if it's identical to the previous command\n            if (prev.length > 0 && prev[prev.length - 1] === commandString) {\n                return prev;\n            }\n            const newHistory = [...prev, commandString].slice(-120); // Keep last 120 commands\n            saveCommandHistory(newHistory); // Save to localStorage whenever history changes\n            return newHistory;\n        });\n    }, []);\n\n    const getCommandResponseHistory = useCallback((): string[] => {\n        const keys: string[] = [];\n        const history: string[] = [];\n        for (let i = 0; i < localStorage.length; i++) {\n            const key = localStorage.key(i);\n            if (key?.startsWith(LogKeys.Command + '_')) {\n                keys.push(key);\n            }\n        }\n        keys.sort();\n        for (const key of keys) {\n            const historyJSON = localStorage.getItem(key);\n            if (historyJSON) {\n                history.push(historyJSON);\n            }\n        }\n        logger.debug('Retrieved command response history:', history);\n        return history;\n    }, []);\n\n    const createCommandRecord = useCallback((\n        command: ParsedCommand,\n        response: React.ReactNode,\n        status: number,\n        commandTime: Date,\n        sensitive: boolean\n    ): OutputElement => {\n        const wpms = wpmCalculator.getWPMs();\n        logger.debug('Creating command record:', { command, response, status });\n        return {\n            command,\n            response,\n            status,\n            wpmAverage: wpms.wpmAverage,\n            characterAverages: wpms.charWpms,\n            commandTime,\n            sensitive: sensitive ?? false\n        };\n    }, [wpmCalculator]);\n\n    const processCommandOutput = useCallback((\n        command: ParsedCommand,\n        response: ICommandResponse,\n    ): void => {\n        logger.debug('Processing command output:', { command, response });\n        const commandTime = new Date();\n        const outputElement = createCommandRecord(\n            command,\n            response.message,\n            response.status,\n            commandTime,\n            response.sensitive ?? false\n        );\n        appendToOutput(outputElement);\n        addToCommandHistory(command);\n    }, [createCommandRecord, addToCommandHistory]);\n\n    const executeCommand = useCallback(async (parsedCommand: ParsedCommand) => {\n        // Breakpoint 5: Start of command execution\n        logger.debug('Executing command:', parsedCommand);\n        const command = commandRegistry.getCommand(parsedCommand.command);\n        if (command && context) {\n            try {\n                const response = await command.execute(context, parsedCommand);\n                logger.debug('Command executed successfully:', response);\n                processCommandOutput(parsedCommand, response);\n                handleCommandExecuted(parsedCommand);\n            } catch (error) {\n                const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n                logger.error('Command execution failed:', error);\n                processCommandOutput(parsedCommand, {\n                    status: 500,\n                    message: errorMessage\n                });\n                handleCommandExecuted(parsedCommand);\n            }\n        } else {\n            // Breakpoint 6: Tutorial command handling\n            const response = currentActivity.value === ActivityType.TUTORIAL ? `Tutorial attempt: ${parsedCommand.command}` : `Command not found: ${parsedCommand.command}`;\n            logger.debug('Command not found:', { command: parsedCommand.command, activity: currentActivity.value });\n            processCommandOutput(parsedCommand, {\n                status: 404,\n                message: response\n            });\n            handleCommandExecuted(parsedCommand);\n        }\n    }, [context, processCommandOutput, handleCommandExecuted, currentActivity]);\n\n    const handleCommand = useCallback(async (parsedCommand: ParsedCommand) => {\n        // Breakpoint 7: Start of command handling\n        logger.debug('Handling command:', { parsedCommand, activity: currentActivity.value });\n        setCommandTime(new Date());\n        if (currentActivity.value === ActivityType.TUTORIAL) {\n            // Breakpoint 8: Tutorial progress check\n            logger.debug('Processing tutorial command:', parsedCommand.command);\n            checkTutorialProgress(parsedCommand.command);\n        }\n\n        await executeCommand(parsedCommand);\n    }, [currentActivity.value, executeCommand, checkTutorialProgress]);\n\n    return {\n        output,\n        resetOutput,\n        commandHistory,\n        addToCommandHistory,\n        getCommandResponseHistory,\n        handleCommand,\n        commandHistoryIndex,\n        setCommandHistoryIndex,\n        commandHistoryFilter,\n        setCommandHistoryFilter,\n        appendToOutput,\n        executeCommand\n    };\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useReactiveLocation.ts","messages":[{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":5,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":5,"endColumn":36}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useSignal, useComputed } from '@preact/signals-react';\nimport { useEffect } from 'react';\nimport { useLocation, useSearchParams } from 'react-router-dom';\n\nexport function useReactiveLocation() {\n  const location = useLocation();\n  useSearchParams();\n\n  const pathSignal = useSignal(location.pathname);\n  const searchSignal = useSignal(location.search);\n  const isInitialized = useSignal(false);\n\n  useEffect(() => {\n    if (!isInitialized.value) {\n      pathSignal.value = location.pathname;\n      searchSignal.value = location.search;\n      isInitialized.value = true;\n    } else {\n      // Only update if the location has actually changed\n      if (pathSignal.value !== location.pathname || searchSignal.value !== location.search) {\n        pathSignal.value = location.pathname;\n        searchSignal.value = location.search;\n      }\n    }\n  }, [location, pathSignal, searchSignal, isInitialized]);\n\n\n  return {\n    pathname: pathSignal,\n    search: searchSignal,\n    isInitialized: useComputed(() => isInitialized.value)\n  };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useResizeCanvasAndFont.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":23,"column":17,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":23,"endColumn":45,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[989,1017],"text":"(lastTouchDistanceRef.current != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[989,1017],"text":"(lastTouchDistanceRef.current ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[989,1017],"text":"(Boolean(lastTouchDistanceRef.current))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":27,"column":21,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":27,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// useResizeCanvasAndFont.ts\nimport { useState, useCallback, type TouchEventHandler, useRef } from 'react';\n\nexport function useResizeCanvasAndFont(): {\n    fontSize: number;\n    canvasHeight: number;\n    handleTouchMove: (event: TouchEvent) => void;\n    handleTouchStart: TouchEventHandler<HTMLElement>;\n    handleTouchEnd: TouchEventHandler<HTMLDivElement>;\n} {\n    const initialFontSize = parseInt(localStorage.getItem(\"fontSize\") ?? '17');\n    const initialCanvasHeight = parseInt(localStorage.getItem('canvas-height') ?? '100');\n    const [fontSize, setFontSize] = useState(initialFontSize);\n    const [canvasHeight, setCanvasHeight] = useState(initialCanvasHeight);\n    const lastTouchDistanceRef = useRef<number | null>(null);\n\n    const handleTouchMove = useCallback((event: TouchEvent) => {\n        if (event.touches.length === 2) {\n            event.preventDefault();\n\n            const currentDistance =\n                getDistanceBetweenTouches(event.touches);\n            if (lastTouchDistanceRef.current && lastTouchDistanceRef.current > 0) {\n                const eventTarget = event.target as HTMLElement;\n                const scaleFactor = currentDistance /\n                    lastTouchDistanceRef.current;\n                if (eventTarget && eventTarget.nodeName ===\n                    'CANVAS') {\n                    setCanvasHeight(prevCanvasHeight => prevCanvasHeight * scaleFactor);\n                } else {\n                    setFontSize(prevFontSize => prevFontSize *\n                        scaleFactor);\n                    document.documentElement.style.setProperty('--rminal-font-size', `${fontSize}px`);\n                }\n                lastTouchDistanceRef.current = currentDistance;\n            }\n        }\n    }, [fontSize]);\n\n    const handleTouchStart: TouchEventHandler<HTMLElement> = (event: React.TouchEvent<HTMLElement>) => {\n        setTimeout(() => {\n            // this.terminalElement.focus();\n        }, 500)\n        if (event.touches.length === 2) {\n            // event.preventDefault();\n            lastTouchDistanceRef.current = getDistanceBetweenTouches(event.touches as unknown as TouchList);\n        }\n    }\n\n    const handleTouchEnd: TouchEventHandler<HTMLDivElement> = () => {\n        localStorage.setItem('terminalFontSize', `${fontSize}`);\n        lastTouchDistanceRef.current = null;\n    }\n\n    const getDistanceBetweenTouches = (touches: TouchList): number => {\n        const touch1 = touches[0];\n        const touch2 = touches[1];\n        return Math.sqrt(\n            Math.pow(touch2.pageX - touch1.pageX, 2) +\n            Math.pow(touch2.pageY - touch1.pageY, 2),\n        );\n    }\n\n    // Return the state and handlers\n    return {\n        fontSize,\n        canvasHeight,\n        handleTouchMove,\n        handleTouchStart,\n        handleTouchEnd,\n    };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useStateLogger.ts","messages":[{"ruleId":"no-restricted-syntax","severity":1,"message":"Consider using type guards for more explicit type checking. Refer to docs/linting/type_safety_strategies.md","line":10,"column":7,"nodeType":"IfStatement","messageId":"restrictedSyntax","endLine":24,"endColumn":8},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":11,"column":27,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":11,"endColumn":47,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[321,341],"text":"(prevStateRef.current != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[321,341],"text":"(prevStateRef.current ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[321,341],"text":"(Boolean(prevStateRef.current))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":19,"column":46,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":19,"endColumn":60},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":19,"column":64,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":19,"endColumn":82},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":28,"column":44,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":28,"endColumn":58},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":28,"column":62,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":28,"endColumn":82}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useRef, useEffect } from 'react';\n\nexport function useStateLogger<T>(state: T, name: string): void {\n  const prevStateRef = useRef<string | null>(null);\n\n  useEffect(() => {\n    try {\n      const currentState = JSON.stringify(state);\n\n      if (prevStateRef.current !== currentState) {\n        const prevState = prevStateRef.current ? JSON.parse(prevStateRef.current) as T : {} as T;\n        const stateChangeLog = {\n          from: prevState,\n          to: state\n        };\n\n        // Log error without using console.log\n        const logMessage = `[${name}] State changed: ${JSON.stringify(stateChangeLog, null, 2)}`;\n        if (typeof window !== 'undefined' && window.console && window.console.log) {\n          window.console.log(logMessage);\n        }\n\n        prevStateRef.current = currentState;\n      }\n    } catch (error) {\n      // Silent error handling to prevent breaking the application\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error in state logging';\n      if (typeof window !== 'undefined' && window.console && window.console.error) {\n        window.console.error(`[${name}] State logging error:`, errorMessage);\n      }\n    }\n  }, [state, name]);\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useTerminal.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":50,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":50,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1873,1882],"text":"instance == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":74,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":74,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2548,2557],"text":"instance == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":79,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":79,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2731,2735],"text":"line != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":90,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":90,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3151,3160],"text":"instance == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":97,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":97,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3440,3449],"text":"(instance == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":104,"column":13,"nodeType":"Identifier","messageId":"conditionErrorString","endLine":104,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[3657,3671],"text":"currentCommand.length > 0"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[3657,3671],"text":"currentCommand !== \"\""},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3657,3671],"text":"Boolean(currentCommand)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":115,"column":13,"nodeType":"Identifier","messageId":"conditionErrorString","endLine":115,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[4094,4106],"text":"savedCommand.length > 0"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[4094,4106],"text":"savedCommand !== \"\""},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4094,4106],"text":"Boolean(savedCommand)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":236,"column":12,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":236,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// hooks/useTerminal.ts\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport { useComputed } from '@preact/signals-react';\nimport { FitAddon } from '@xterm/addon-fit';\nimport { useXTerm } from 'react-xtermjs';\n\nimport { TERMINAL_CONSTANTS } from 'src/constants/terminal';\nimport {\n  isInLoginProcessSignal,\n  isInSignUpProcessSignal,\n  setActivity,\n  setIsInLoginProcess,\n  setIsInSignUpProcess,\n  setTempEmail,\n  setTempPassword,\n  setTempUserName,\n  tempEmailSignal,\n  tempPasswordSignal,\n  tempUserNameSignal\n} from 'src/signals/appSignals';\nimport { addKeystroke, commandLineSignal , setCommandLine } from 'src/signals/commandLineSignals';\nimport { ActivityType } from 'src/types/Types';\nimport { parseCommand } from 'src/utils/commandUtils';\nimport { createLogger } from 'src/utils/Logger';\n\nimport { XtermAdapterConfig } from '../components/XtermAdapterConfig';\n\nimport { useCharacterHandler } from './useCharacterHandler';\nimport { useCommand } from './useCommand';\nimport { useWPMCalculator } from './useWPMCaculator';\n\nconst logger = createLogger({ prefix: 'useTerminal' });\n\nexport const useTerminal = (): { xtermRef: React.RefObject<HTMLDivElement>; writeToTerminal: (data: string) => void; resetPrompt: () => void } => {\n  const { instance, ref: xtermRef } = useXTerm({ options: XtermAdapterConfig });\n  const { handleCommand, commandHistory, commandHistoryIndex, setCommandHistoryIndex } = useCommand();\n  const wpmCalculator = useWPMCalculator();\n  const commandLine = useComputed(() => commandLineSignal.value);\n\n  const [_commandLineState, _setCommandLineState] = useState('');\n\n  const fitAddon = useRef(new FitAddon());\n\n  const writeToTerminal = useCallback((data: string): void => {\n    logger.debug('Writing to terminal:', data);\n    instance?.write(data);\n  }, [instance]);\n\n  const resetPrompt = useCallback((): void => {\n    if (!instance) return;\n    logger.debug('Resetting prompt');\n    instance.reset();\n    setCommandLine('');\n    _setCommandLineState('');\n    instance.write(TERMINAL_CONSTANTS.PROMPT);\n    instance.scrollToBottom();\n  }, [instance]);\n\n  const lastTypedCharacterRef = useRef<string | null>(null);\n  const setLastTypedCharacter = (value: string | null) => {\n    lastTypedCharacterRef.current = value;\n  };\n\n  const {\n    handleCharacter,\n  } = useCharacterHandler({\n    setLastTypedCharacter,\n    isInSvgMode: false,\n    isInLoginProcess: isInLoginProcessSignal.value,\n    writeOutputInternal: writeToTerminal,\n  });\n\n  const getCurrentCommand = useCallback((): string => {\n    if (!instance) return '';\n    const buffer = instance.buffer.active;\n    let command = '';\n    for (let i = 0; i <= buffer.cursorY; i++) {\n      const line = buffer.getLine(i);\n      if (line) {\n        command += line.translateToString(true);\n      }\n    }\n    const promptEndIndex = command.indexOf(TERMINAL_CONSTANTS.PROMPT) + TERMINAL_CONSTANTS.PROMPT_LENGTH;\n    const currentCommand = command.substring(promptEndIndex).trimStart();\n    logger.debug('Getting current command:', currentCommand);\n    return currentCommand;\n  }, [instance]);\n\n  const clearCurrentLine = useCallback((): void => {\n    if (!instance) return;\n    logger.debug('Clearing current line');\n    instance.write('\\x1b[2K\\r'); // Clear the current line\n    instance.write(TERMINAL_CONSTANTS.PROMPT); // Rewrite prompt\n  }, [instance]);\n\n  const navigateHistory = useCallback((direction: 'up' | 'down'): void => {\n    if (!instance || (commandHistory.length === 0)) return;\n\n    let newIndex = commandHistoryIndex;\n\n    if (direction === 'up') {\n      if (newIndex === -1) {\n        const currentCommand = getCurrentCommand();\n        if (currentCommand) {\n          setCommandLine(currentCommand);\n          _setCommandLineState(currentCommand);\n        }\n      }\n      newIndex = newIndex === -1 ? commandHistory.length - 1 : Math.max(0, newIndex - 1);\n    } else {\n      newIndex = newIndex === -1 ? -1 : Math.min(commandHistory.length - 1, newIndex + 1);\n      if (newIndex === -1) {\n        clearCurrentLine();\n        const savedCommand = commandLine.value;\n        if (savedCommand) {\n          instance.write(savedCommand);\n          setCommandLine(savedCommand);\n          _setCommandLineState(savedCommand);\n        }\n        setCommandHistoryIndex(newIndex);\n        return;\n      }\n    }\n\n    clearCurrentLine();\n    const historicalCommand = commandHistory[newIndex] ?? '';\n    instance.write(historicalCommand);\n    setCommandLine(historicalCommand);\n    _setCommandLineState(historicalCommand);\n    setCommandHistoryIndex(newIndex);\n  }, [instance, commandHistory, commandHistoryIndex, getCurrentCommand, clearCurrentLine, setCommandHistoryIndex, commandLine, _setCommandLineState]);\n\n  useEffect(() => {\n    if (instance == null) return;\n    instance.loadAddon(fitAddon.current);\n    fitAddon.current.fit();\n    resetPrompt();\n  }, [instance, resetPrompt]);\n\n  useEffect(() => {\n    if (instance == null) return;\n\n    const handleControlCharacters = (data: string, cursorX: number) => {\n      logger.debug('Handling control character:', { data, cursorX });\n      switch (data) {\n        case '\\x03': // Ctrl+C\n          setCommandLine('');\n          _setCommandLineState('');\n          setActivity(ActivityType.NORMAL);\n          instance?.write('^C');\n          resetPrompt();\n          return true;\n\n        case '\\r': // Enter key\n          handleEnterKey();\n          return true;\n\n        case '\\x7F': // Backspace\n          handleBackspace(cursorX);\n          return true;\n\n        case '\\x1b[D': // Left arrow\n          if (cursorX > TERMINAL_CONSTANTS.PROMPT_LENGTH) {\n            instance?.write(data);\n          }\n          return true;\n\n        case '\\x1b[A': // Up arrow\n          navigateHistory('up');\n          return true;\n\n        case '\\x1b[B': // Down arrow\n          navigateHistory('down');\n          return true;\n\n        default:\n          return false;\n      }\n    };\n\n    const handleEnterKey = () => {\n      logger.debug('Handling Enter key');\n      if (isInLoginProcessSignal.value) {\n        const loginCommand = parseCommand([\n          'login',\n          tempUserNameSignal.value,\n          tempPasswordSignal.value\n        ].join(' '));\n        handleCommand(loginCommand).catch(console.error);\n        setIsInLoginProcess(false);\n        setTempPassword('');\n        setTempUserName('');\n      } else if (isInSignUpProcessSignal.value) {\n        const signupCommand = parseCommand([\n          'signup',\n          tempUserNameSignal.value,\n          tempEmailSignal.value,\n          tempPasswordSignal.value\n        ].join(' '));\n        handleCommand(signupCommand).catch(console.error);\n        setIsInSignUpProcess(false);\n        setTempPassword('');\n        setTempUserName('');\n        setTempEmail('');\n      } else {\n        const currentCommand = getCurrentCommand();\n        logger.debug('Processing command:', currentCommand);\n        const parsedCommand = parseCommand(currentCommand === '' ? '\\r' : currentCommand);\n        logger.debug('Parsed command:', parsedCommand);\n        instance?.write('\\r\\n');\n        setCommandLine('');\n        _setCommandLineState('');\n        handleCommand(parsedCommand).catch(console.error);\n        wpmCalculator.clearKeystrokes();\n      }\n      setCommandHistoryIndex(-1); // Reset history index after command execution\n      resetPrompt();\n    };\n\n    const handleBackspace = (cursorX: number) => {\n      logger.debug('Handling backspace:', { cursorX });\n      if (isInLoginProcessSignal.value ?? isInSignUpProcessSignal.value) {\n        if (tempPasswordSignal.value.length > 0) {\n          tempPasswordSignal.value = tempPasswordSignal.value.slice(0, -1);\n          instance?.write('\\b \\b');\n        }\n      } else if (cursorX > TERMINAL_CONSTANTS.PROMPT_LENGTH) {\n        instance?.write('\\b \\b');\n        const newCommandLine = _commandLineState.slice(0, -1);\n        setCommandLine(newCommandLine);\n        _setCommandLineState(newCommandLine);\n      }\n    };\n\n    const handleData = (data: string) => {\n      if (!instance) return;\n      logger.debug('Handling terminal data:', data);\n      const cursorX = instance.buffer.active.cursorX;\n\n      if (handleControlCharacters(data, cursorX)) {\n        return;\n      }\n\n      // Handle regular character input\n      if (isInLoginProcessSignal.value ?? isInSignUpProcessSignal.value) {\n        tempPasswordSignal.value += data;\n        handleCharacter(data); // This will handle masking\n      } else {\n        const newCommandLine = _commandLineState + data;\n        instance.write(data);\n        setCommandLine(newCommandLine);\n        _setCommandLineState(newCommandLine);\n        addKeystroke(data);\n      }\n      return;\n    };\n\n    const resizeHandler = () => {\n      fitAddon.current.fit();\n      instance.scrollToBottom();\n    };\n    window.addEventListener('resize', resizeHandler);\n\n    const dataHandler = instance.onData(handleData);\n\n    return () => {\n      window.removeEventListener('resize', resizeHandler);\n      dataHandler.dispose();\n    };\n  }, [instance, getCurrentCommand, resetPrompt, wpmCalculator, commandLine, navigateHistory, handleCharacter, _commandLineState, handleCommand, setCommandHistoryIndex]);\n\n  return {\n    xtermRef,\n    writeToTerminal,\n    resetPrompt,\n  };\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useTutorials.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":70,"column":14,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":70,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2815,2839],"text":"(currentTutorial?.phrase) == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2816,2839],"text":"((currentTutorial?.phrase) ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2815,2839],"text":"!Boolean((currentTutorial?.phrase))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/hooks/useTutorial.ts\nimport { useComputed } from '@preact/signals-react';\nimport { useState, useCallback, useEffect } from 'react';\n\nimport {\n    completedTutorialsSignal,\n    getNextTutorial,\n} from 'src/signals/tutorialSignals';\nimport { createLogger } from 'src/utils/Logger';\nimport { parseLocation } from 'src/utils/navigationUtils';\n\nimport { type Tutorial, Tutorials } from \"../types/Types\";\n\nconst logger = createLogger({ prefix: 'useTutorials' });\n\nexport const useTutorial = (): {\n    getTutorialByPhrasekey: (phraseKey: string) => Tutorial | undefined;\n    canUnlockTutorial: (command: string) => boolean;\n    getTutorialsInGroup: (groupName: string) => Tutorial[];\n    getIncompleteTutorialsInGroup: (groupName: string) => Tutorial[];\n} => {\n    const [, setCurrentTutorial] = useState<Tutorial | null>(null);\n    const completedTutorials = useComputed(() => completedTutorialsSignal.value);\n\n    // Get all completed tutorials as an array if needed\n    const completedTutorialsArray = (): string[] => {\n        const completed = [...completedTutorialsSignal.value];\n        logger.debug('Completed tutorials:', completed);\n        return completed;\n    }\n\n    const getIncompleteTutorials = useCallback((): Tutorial[] => {\n        // Breakpoint 9: Getting incomplete tutorials\n        const incomplete = Tutorials.filter(tut => !completedTutorialsArray().includes(tut.phrase));\n        logger.debug('Incomplete tutorials:', incomplete);\n        return incomplete;\n    }, [])\n\n    const getTutorialsInGroup = (groupName: string) => {\n        // Breakpoint 10: Getting tutorials in group\n        const result = Tutorials.filter(t => t.tutorialGroup === groupName);\n        logger.debug('Tutorials in group:', { groupName, result });\n        return result;\n    }\n\n    const getTutorialByPhrasekey = (phraseKey: string) => {\n        // Breakpoint 11: Getting tutorial by phrase key\n        const foundTutorial = Tutorials.find(t => t.phrase === phraseKey?.replace('_r', '\\r'));\n        logger.debug('Getting tutorial by phrase key:', {\n            phraseKey,\n            currentTutorial: foundTutorial,\n            normalizedKey: phraseKey?.replace('_r', '\\r'),\n            allTutorials: Tutorials.map(t => ({ phrase: t.phrase, prompt: t.prompt }))\n        });\n        return foundTutorial;\n    }\n\n    const canUnlockTutorial = (command: string): boolean => {\n        // Breakpoint 12: Checking if can unlock tutorial\n        const phraseKey = parseLocation().contentKey ?? '';\n        const currentTutorial = getTutorialByPhrasekey(phraseKey);\n        logger.debug('Checking if can unlock tutorial:', {\n            command,\n            phraseKey,\n            currentTutorial,\n            location: parseLocation(),\n            completedTutorials: completedTutorialsArray()\n        });\n\n        if (!currentTutorial?.phrase) {\n            logger.debug('No current tutorial found');\n            return false;\n        }\n\n        // Breakpoint 13: Tutorial phrase comparison\n        if (currentTutorial.phrase === command) {\n            logger.debug('Tutorial unlocked:', command);\n            return true;\n        }\n        logger.debug('Tutorial not unlocked:', {\n            expected: currentTutorial.phrase,\n            received: command,\n            charCodesExpected: [...currentTutorial.phrase].map(c => c.charCodeAt(0)),\n            charCodesReceived: [...command].map(c => c.charCodeAt(0))\n        });\n        return false;\n    };\n\n    const getIncompleteTutorialsInGroup = (groupName: string): Tutorial[] => {\n        // Breakpoint 14: Getting incomplete tutorials in group\n        const incompleteTutorials = getIncompleteTutorials();\n        const tutorialsInGroup = getTutorialsInGroup(groupName);\n\n        const result = tutorialsInGroup\n            .filter(tig => incompleteTutorials.includes(tig));\n        logger.debug('Incomplete tutorials in group:', {\n            groupName,\n            result,\n            allIncomplete: incompleteTutorials,\n            groupTutorials: tutorialsInGroup\n        });\n        return result;\n    }\n\n    useEffect(() => {\n        const nextTutorial = getNextTutorial();\n        logger.debug('Setting current tutorial:', nextTutorial);\n        setCurrentTutorial(nextTutorial);\n    }, [completedTutorials]);\n\n    return {\n        getTutorialByPhrasekey,\n        canUnlockTutorial,\n        getTutorialsInGroup,\n        getIncompleteTutorialsInGroup\n    };\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/hooks/useWPMCaculator.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":29,"column":12,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":29,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[843,851],"text":"(current == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":29,"column":24,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":29,"endColumn":32,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[855,864],"text":"(previous == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/hooks/useWPMCalculator.ts\n\nimport { useComputed } from '@preact/signals-react';\nimport { useCallback } from 'react';\n\nimport { keystrokesSignal, addKeystroke, clearKeystrokes } from 'src/signals/commandLineSignals';\n\nimport { type WPM, type WPMs } from '../types/Types';\n\n\nexport const useWPMCalculator = (): {\n  addKeystroke: (char: string) => void;\n  getWPMs: () => WPMs;\n  clearKeystrokes: () => void;\n  keystrokeCount: number;\n} => {\n  const keystrokes = useComputed(() => keystrokesSignal.value);\n\n\n  const getWPMs = useCallback((): WPMs => {\n    if (keystrokes.value.length < 2) return { wpmAverage: 0, charWpms: [] };\n\n    const charWpms: WPM[] = [];\n    let totalWPM = 0;\n\n    for (let i = 1; i < keystrokes.value.length; i++) {\n      const current = keystrokes.value[i];\n      const previous = keystrokes.value[i-1];\n      if (!current || !previous) continue;\n\n      const duration = current.timestamp - previous.timestamp;\n      const minutes = duration / 60000; // Convert to minutes\n      const cpm = 1 / minutes; // 1 character per minute.\n      const wpm = cpm / 5; // five character words per minute.\n\n      charWpms.push({\n        character: current.char,\n        wpm,\n        durationMilliseconds: duration\n      });\n\n      totalWPM += wpm;\n    }\n\n    const wpmAverage = totalWPM / (keystrokes.value.length - 1);\n\n    return {\n      wpmAverage,\n      charWpms: Object.freeze(charWpms) // Make charWpms immutable\n    };\n  }, [keystrokes]);\n\n  return {\n    addKeystroke,\n    getWPMs, // Return the memoized value\n    clearKeystrokes,\n    keystrokeCount: keystrokes.value.length // Add this for debugging\n  };\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/providers/QueryProvider.tsx","messages":[{"ruleId":"@typescript-eslint/explicit-module-boundary-types","severity":2,"message":"Missing return type on function.","line":17,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":17,"endColumn":30}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { type ReactNode } from 'react';\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 5 * 60 * 1000, // 5 minutes\n      retry: 1,\n    },\n  },\n});\n\ninterface QueryProviderProps {\n  children: ReactNode;\n}\n\nexport function QueryProvider({ children }: QueryProviderProps) {\n  return (\n    <QueryClientProvider client={queryClient}>\n      {children}\n    </QueryClientProvider>\n  );\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/signals/appSignals.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":83,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":83,"endColumn":30,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[2902,2919],"text":"(element.sensitive ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[2902,2919],"text":"(element.sensitive === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":83,"column":34,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":83,"endColumn":49},{"ruleId":"no-param-reassign","severity":1,"message":"Assignment to function parameter 'element'.","line":90,"column":13,"nodeType":"Identifier","messageId":"assignmentToFunctionParam","endLine":90,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/signals/appSignals.ts\nimport { computed, signal } from '@preact/signals-react';\n\nimport { ActivityType, type OutputElement } from 'src/types/Types';\nimport { createLogger, LogLevel } from 'src/utils/Logger';\nimport { createPersistentSignal } from 'src/utils/signalPersistence';\n\nconst logger = createLogger({\n  prefix: 'AppSignals',\n  level: LogLevel.DEBUG\n});\n\nconst currentOutputKey = 'current-output';\nexport const activitySignal = signal<ActivityType>(ActivityType.NORMAL);\nexport const notificationSignal = signal<string | null>(null);\nexport const isEditModeSignal = signal<boolean>(false);\nexport const isShowVideoSignal = signal<boolean>(false);\nexport const isInLoginProcessSignal = signal<boolean>(false);\nexport const isInSignUpProcessSignal = signal<boolean>(false);\nexport const tempUserNameSignal = signal<string>('');\nexport const tempPasswordSignal = signal<string>('');\nexport const tempEmailSignal = signal<string>('');\n\nexport const setIsInSignUpProcess = (value: boolean): void => {\n    isInSignUpProcessSignal.value = value;\n};\n\nexport const setTempEmail = (value: string): void => {\n    tempEmailSignal.value = value;\n};\n\nexport const toggleVideo = (): boolean => {\n    isShowVideoSignal.value = !isShowVideoSignal.value;\n    return isShowVideoSignal.value;\n};\n\nexport const setIsInLoginProcess = (value: boolean): void => {\n    isInLoginProcessSignal.value = value;\n};\n\nexport const setTempUserName = (value: string): void => {\n    tempUserNameSignal.value = value;\n};\n\nexport const setTempPassword = (value: string): void => {\n    tempPasswordSignal.value = value;\n};\n\n// Create a persistent signal for bypassTutorial\nexport const {\n    signal: bypassTutorialSignal,\n    update: setBypassTutorial\n} = createPersistentSignal<boolean>({\n    key: 'bypassTutorialKey', // Unique key for localStorage\n    signal: signal<boolean>(false),\n    serialize: (value: boolean) => JSON.stringify(value),\n    deserialize: (value: string) => JSON.parse(value) as boolean\n});\n\nconst {\n    signal: outputElementsSignal,\n    update: updateOutput\n} = createPersistentSignal<OutputElement[]>({\n    key: currentOutputKey,\n    signal: signal<OutputElement[]>([]),\n    serialize: (value: OutputElement[]) => JSON.stringify(value),\n    deserialize: (value: string) => JSON.parse(value) as OutputElement[]\n});\n\nexport { outputElementsSignal };\n\nexport const isInGameModeSignal = computed(() => activitySignal.value === ActivityType.GAME);\nexport const isInTutorialModeSignal = computed(() => activitySignal.value === ActivityType.TUTORIAL);\n\nexport const setActivity = (activity: ActivityType): void => {\n    activitySignal.value = activity;\n    logger.debug(ActivityType[activitySignal.value]);\n};\n\nexport const appendToOutput = (element: OutputElement): void => {\n    updateOutput(prevOutput => {\n        // If the command is sensitive, mask the args except the first one (username)\n        if (element.sensitive && element.command) {\n            const maskedCommand = {\n                ...element.command,\n                args: element.command.args.map((arg, index) =>\n                    index === 0 ? arg : '*'.repeat(arg.length)\n                )\n            };\n            element = { ...element, command: maskedCommand };\n        }\n        const newOutput = [...prevOutput, element].slice(-3);\n        return newOutput;\n    });\n};\n\nexport const setNotification = (notification: string): void => {\n    notificationSignal.value = notification;\n};\n\nexport const isLoggedInSignal = signal<boolean>(false);\nexport const userNameSignal = signal<string | null>(null);\n\nexport const setIsLoggedIn = (value: boolean): void => {\n    isLoggedInSignal.value = value;\n};\n\nexport const setUserName = (name: string | null): void => {\n    userNameSignal.value = name;\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/signals/commandLineSignals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/signals/gameSignals.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":64,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":64,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2365,2378],"text":"tutorialGroup != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2365,2378],"text":"tutorialGroup ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2365,2378],"text":"Boolean(tutorialGroup)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":79,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":79,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2844,2859],"text":"storedTutorials != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2844,2859],"text":"storedTutorials ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2844,2859],"text":"Boolean(storedTutorials)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\n// gameSignals.ts\nimport { signal } from \"@preact/signals-react\";\n\nimport { type ActionType } from \"src/game/types/ActionTypes\";\nimport { type GamePhrase, Phrases } from \"src/types/Types\";\nimport { createPersistentSignal } from \"src/utils/signalPersistence\";\n\nexport const startGameSignal = signal<string | undefined>(undefined);\nexport const gamePhraseSignal = signal<GamePhrase | null>(null);\nexport const gameInitSignal = signal<boolean>(false);\nexport const isInGameModeSignal = signal<boolean>(false);\nexport const currentGamePhraseSignal = signal<GamePhrase | null>(null);\nexport const gameLevelSignal = signal<number | null>(null);\nexport const heroActionSignal = signal<ActionType>('Idle');\nexport const zombie4ActionSignal = signal<ActionType>('Walk');\n\nconst completedGamePhrasesKey = 'completed-game-phrases';\n\nexport const setHeroAction = (action: ActionType): void => {\n  heroActionSignal.value = action;\n};\n\nexport const setZombie4Action = (action: ActionType): void => {\n  zombie4ActionSignal.value = action;\n};\n\nexport const setGameLevel = (level: number): void => {\n  gameLevelSignal.value = level;\n};\n\nconst { signal: completedGamePhrasesSignal, update: updateCompletedGamePhrases } = createPersistentSignal<Set<string>>({\n  key: completedGamePhrasesKey,\n  signal: signal<Set<string>>(new Set()),\n  serialize: (value: Set<string>) => JSON.stringify([...value]),\n  deserialize: (value: string) => new Set(JSON.parse(value) as string[]),\n});\n\nexport { completedGamePhrasesSignal };\n\nexport const setCompletedGamePhrase = (gamePhraseId: string): void => {\n  updateCompletedGamePhrases(prev => prev.add(gamePhraseId));\n}\n\nexport const getIncompletePhrasesByTutorialGroup = (tutorialGroup: string): GamePhrase[] => {\n  const phrasesInGroup = Phrases.filter(p => p.tutorialGroup === tutorialGroup);\n  const incompletePhrasesInGroup = phrasesInGroup\n    .filter(pig => !Array.from(completedGamePhrasesSignal.value).includes(pig.key))\n  return incompletePhrasesInGroup;\n}\n\nexport const getNextGamePhrase = (): GamePhrase | null => {\n  const nextGamePhrase = Phrases\n    .find(t => !completedGamePhrasesSignal.value.has(t.key));\n  if (nextGamePhrase === undefined) {\n    return null;\n  }\n  return nextGamePhrase;\n};\n\nexport const initializeGame = (tutorialGroup?: string): void => {\n  gameInitSignal.value = true;\n  isInGameModeSignal.value = true;\n  if (tutorialGroup) {\n    const tutorialGroupGamePhrase = getIncompletePhrasesByTutorialGroup(tutorialGroup);\n    if (tutorialGroupGamePhrase.length > 0) {\n      gamePhraseSignal.value = tutorialGroupGamePhrase[0] ?? null;\n    }\n  }\n};\n\nexport const setGamePhrase = (phrase: GamePhrase | null): void => {\n  gamePhraseSignal.value = phrase;\n};\n\n// Load initial state\nconst loadInitialState = (): void => {\n  const storedTutorials = localStorage.getItem(completedGamePhrasesKey);\n  if (storedTutorials) {\n    try {\n      const parsedTutorials = JSON.parse(storedTutorials) as string[];\n      completedGamePhrasesSignal.value = new Set(parsedTutorials);\n    } catch (error) {\n      console.error('Failed to parse stored tutorials:', error);\n      completedGamePhrasesSignal.value = new Set();\n    }\n  }\n  setGamePhrase(getNextGamePhrase());\n};\n\nloadInitialState();\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/signals/treeViewSignals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/signals/tutorialSignals.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":47,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":47,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1588,1603],"text":"storedTutorials != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1588,1603],"text":"storedTutorials ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1588,1603],"text":"Boolean(storedTutorials)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/signals/tutorialSignals.ts\nimport { computed, signal } from \"@preact/signals-react\";\n\nimport { type Tutorial, Tutorials } from \"src/types/Types\";\nimport { createLogger } from \"src/utils/Logger\";\n\nimport { createPersistentSignal } from \"../utils/signalPersistence\";\n\nconst logger = createLogger({ prefix: 'tutorialSignals' });\n\nconst completedTutorialsKey = \"completed-tutorials\";\n\nconst { signal: completedTutorialsSignal, update: updateCompletedTutorials } = createPersistentSignal({\n  key: completedTutorialsKey,\n  signal: signal<Set<string>>(new Set()),\n  serialize: (value) => JSON.stringify([...value]),\n  deserialize: (value) => new Set(JSON.parse(value) as string[]),\n});\n\nexport { completedTutorialsSignal };\n\nexport const tutorialSignal = signal<Tutorial | null>(null);\n\n/**\n * Gets the next uncompleted tutorial\n * @returns The next Tutorial or null if all are completed\n */\nexport const getNextTutorial = (): Tutorial | null => {\n  const nextTutorial = Tutorials\n    .find(t => !completedTutorialsSignal.value.has(t.phrase));\n  logger.debug('Getting next tutorial:', { nextTutorial, completedTutorials: [...completedTutorialsSignal.value] });\n  return nextTutorial ?? null;\n};\n\n/**\n * Sets the next tutorial\n * @param nextTutorial - The tutorial to set as next\n */\nexport const setNextTutorial = (nextTutorial: Tutorial | null): void => {\n  logger.debug('Setting next tutorial:', nextTutorial);\n  tutorialSignal.value = nextTutorial;\n};\n\n// Load initial state\nconst loadInitialState = () => {\n  const storedTutorials = localStorage.getItem(completedTutorialsKey);\n  if (storedTutorials) {\n    logger.debug('Loading stored tutorials:', storedTutorials);\n    completedTutorialsSignal.value = new Set(JSON.parse(storedTutorials) as string[]);\n  }\n  const nextTutorial = getNextTutorial();\n  logger.debug('Initial tutorial:', nextTutorial);\n  setNextTutorial(nextTutorial);\n};\n\nloadInitialState();\n\n// Computed signals\nexport const completedTutorialsArray = computed(() => [...completedTutorialsSignal.value]);\n\n// Exported functions\n/**\n * Marks a tutorial as completed and sets the next tutorial\n * @param tutorialId - The ID of the completed tutorial\n */\nexport const setCompletedTutorial = (tutorialId: string): void => {\n  logger.debug('Setting completed tutorial:', { tutorialId, currentTutorial: tutorialSignal.value });\n  updateCompletedTutorials(prev => new Set(prev).add(tutorialId));\n  // After marking a tutorial as complete, get and set the next one\n  const nextTutorial = getNextTutorial();\n  logger.debug('Next tutorial after completion:', nextTutorial);\n  setNextTutorial(nextTutorial);\n};\n\n/**\n * Resets all completed tutorials and sets the first tutorial\n */\nexport const resetCompletedTutorials = (): void => {\n  logger.debug('Resetting completed tutorials');\n  updateCompletedTutorials(new Set());\n  const nextTutorial = getNextTutorial();\n  logger.debug('First tutorial after reset:', nextTutorial);\n  setNextTutorial(nextTutorial);\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/terminal-data.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/test-utils/canvasMock.d.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ESLint was configured to run on `<tsconfigRootDir>/src/test-utils/canvasMock.d.ts` using `parserOptions.project`: \n- <tsconfigRootDir>/tsconfig.json\n- <tsconfigRootDir>/tsconfig.test.json\n- <tsconfigRootDir>/tsconfig.node.json\n- <tsconfigRootDir>/tsconfig.eslint-rules.json\nHowever, none of those TSConfigs include this file. Either:\n- Change ESLint's list of included files to not include this file\n- Change one of those TSConfigs to include this file\n- Create a new TSConfig that includes this file and include it in your parserOptions.project\nSee the typescript-eslint docs for more info: https://typescript-eslint.io/troubleshooting/typed-linting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file","nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Mock } from 'vitest';\n\nexport interface MockCanvasContext {\n  fillRect: Mock;\n  clearRect: Mock;\n  drawImage: Mock;\n  beginPath: Mock;\n  closePath: Mock;\n  stroke: Mock;\n  fill: Mock;\n}\n\nexport interface CanvasMock {\n  mockGetContext: Mock;\n  restoreOriginalGetContext: () => void;\n}\n\nexport function createMockCanvasContext(): MockCanvasContext;\nexport function setupCanvasMock(): CanvasMock;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/test-utils/canvasMock.ts","messages":[{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":34,"column":30,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":34,"endColumn":68},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":47,"column":11,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":47,"endColumn":29}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { vi, type Mock } from 'vitest';\n\n// Define an interface for the mock canvas context methods\ninterface MockCanvasContext {\n  fillRect: Mock<any, any>;\n  clearRect: Mock<any, any>;\n  drawImage: Mock<any, any>;\n  beginPath: Mock<any, any>;\n  closePath: Mock<any, any>;\n  stroke: Mock<any, any>;\n  fill: Mock<any, any>;\n}\n\n// Create a reusable canvas context mock\nexport const createMockCanvasContext = (): MockCanvasContext => {\n  const mockContext: MockCanvasContext = {\n    fillRect: vi.fn(),\n    clearRect: vi.fn(),\n    drawImage: vi.fn(),\n    beginPath: vi.fn(),\n    closePath: vi.fn(),\n    stroke: vi.fn(),\n    fill: vi.fn(),\n  };\n\n  return mockContext;\n};\n\n// Global mock for canvas context\nexport const setupCanvasMock = (): {\n  mockGetContext: Mock<any, any>;\n  restoreOriginalGetContext: () => void;\n} => {\n  const originalGetContext = HTMLCanvasElement.prototype.getContext;\n  const mockGetContext = vi.fn(() => createMockCanvasContext());\n\n  Object.defineProperty(HTMLCanvasElement.prototype, 'getContext', {\n    value: mockGetContext,\n    configurable: true,\n    writable: true\n  });\n\n  return {\n    mockGetContext,\n    restoreOriginalGetContext: () => {\n      // Safely restore original implementation\n      if (originalGetContext) {\n        Object.defineProperty(HTMLCanvasElement.prototype, 'getContext', {\n          value: originalGetContext,\n          configurable: true,\n          writable: true\n        });\n      } else {\n        // If no original method existed, remove the property\n        const canvasProto = HTMLCanvasElement.prototype as { getContext?: unknown };\n        delete canvasProto.getContext;\n      }\n    }\n  };\n};\n\n// Export the type for CanvasMock\nexport type CanvasMock = ReturnType<typeof setupCanvasMock>;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/test-utils/setup.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-call","severity":2,"message":"Unsafe call of an `any` typed value.","line":75,"column":7,"nodeType":"Identifier","messageId":"unsafeCall","endLine":75,"endColumn":15},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":121,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":121,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2788,2805],"text":"xtermDataCallback != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { vi } from 'vitest';\n\n// Mock localStorage\nconst localStorageMock = {\n  getItem: vi.fn(),\n  setItem: vi.fn(),\n  clear: vi.fn(),\n  removeItem: vi.fn(),\n  length: 0,\n  key: vi.fn(),\n};\nglobal.localStorage = localStorageMock as typeof localStorage;\n\n// Mock matchMedia\nObject.defineProperty(window, 'matchMedia', {\n  writable: true,\n  value: vi.fn().mockImplementation((query: string) => ({\n    matches: false,\n    media: query,\n    onchange: null,\n    addListener: vi.fn(), // Deprecated\n    removeListener: vi.fn(), // Deprecated\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn(),\n    dispatchEvent: vi.fn(),\n  })),\n});\n\n// Mock ResizeObserver\nclass ResizeObserverMock {\n  observe = vi.fn();\n  unobserve = vi.fn();\n  disconnect = vi.fn();\n}\n\nwindow.ResizeObserver = ResizeObserverMock as unknown as typeof ResizeObserver;\n\n// Mock requestAnimationFrame\nwindow.requestAnimationFrame = vi.fn((callback) => {\n  return setTimeout(callback, 0);\n});\n\n// Mock canvas context\nHTMLCanvasElement.prototype.getContext = vi.fn(() => ({\n  fillRect: vi.fn(),\n  clearRect: vi.fn(),\n  getImageData: vi.fn(() => ({\n    data: new Array(4),\n  })),\n  putImageData: vi.fn(),\n  createImageData: vi.fn(),\n  setTransform: vi.fn(),\n  drawImage: vi.fn(),\n  save: vi.fn(),\n  restore: vi.fn(),\n  scale: vi.fn(),\n  rotate: vi.fn(),\n  translate: vi.fn(),\n  transform: vi.fn(),\n  beginPath: vi.fn(),\n  moveTo: vi.fn(),\n  lineTo: vi.fn(),\n  stroke: vi.fn(),\n  fill: vi.fn(),\n  arc: vi.fn(),\n})) as unknown as typeof HTMLCanvasElement.prototype.getContext;\n\n// Mock xterm.js\nconst mockTerminal = {\n  loadAddon: vi.fn(),\n  open: vi.fn(),\n  write: vi.fn(),\n  onData: vi.fn((callback) => {\n    (window as WindowWithXtermCallback).__xtermDataCallback = (data: string) => {\n      callback(data);\n    };\n    return { dispose: vi.fn() };\n  }),\n  onKey: vi.fn(),\n  clear: vi.fn(),\n  focus: vi.fn(),\n  dispose: vi.fn(),\n  reset: vi.fn(() => {\n  }),\n  scrollToBottom: vi.fn(),\n  buffer: {\n    active: {\n      cursorX: 2,\n      cursorY: 0,\n      getLine: () => ({\n        translateToString: () => {\n          return '> ';\n        }\n      })\n    }\n  }\n};\n\nvi.mock('xterm', () => ({\n  Terminal: vi.fn().mockImplementation(() => mockTerminal)\n}));\n\nvi.mock('@xterm/addon-fit', () => ({\n  FitAddon: vi.fn().mockImplementation(() => ({\n    fit: vi.fn(),\n    activate: vi.fn(),\n    dispose: vi.fn()\n  }))\n}));\n\n// Define types for window extensions\ninterface WindowWithXtermCallback extends Window {\n  __xtermDataCallback?: (data: string) => void;\n  mockTerminal?: typeof mockTerminal;\n  triggerTerminalInput?: (data: string) => void;\n}\n\n// Helper to trigger terminal input\nfunction createTriggerTerminalInput(data: string) {\n  const xtermDataCallback = (window as WindowWithXtermCallback).__xtermDataCallback;\n  if (xtermDataCallback) {\n    // For Enter key, ensure we send just \\r\n    if (data === '\\r\\n') {\n      xtermDataCallback('\\r');\n    } else {\n      xtermDataCallback(data);\n    }\n  }\n}\n\n// Initialize window extensions\n(window as WindowWithXtermCallback).__xtermDataCallback = undefined;\n(window as WindowWithXtermCallback).triggerTerminalInput = createTriggerTerminalInput;\n(window as WindowWithXtermCallback).mockTerminal = mockTerminal;\n\n// Set up callback handler\n(window as WindowWithXtermCallback).__xtermDataCallback = (data: string) => {\n  (window as WindowWithXtermCallback).__xtermDataCallback?.(data);\n};\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/test-utils/test-utils.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/types/HandTerm.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/types/Signals.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/types/TerminalTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/types/Types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/types/elements.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/types/importMeta.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/types/monaco-vim.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/types/testing-library__jest-dom.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/GamePhrases.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":124,"column":50,"nodeType":"ChainExpression","messageId":"conditionErrorObject","endLine":124,"endColumn":71}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type GamePhrase, type MyResponse, Phrases } from \"../types/Types\";\n\ninterface PhraseAchievement {\n    wpm: string;\n    phraseName: string;\n}\n\nconst standardChars = /^[a-zA-Z0-9\\s'\";:.!,?]+$/;\n\nexport default class GamePhrases {\n    /**\n     * Gets a game phrase by its key\n     * @param key - The phrase key to search for\n     * @returns The matching GamePhrase or null if not found\n     */\n    public static getGamePhraseByKey(key: string): GamePhrase | null {\n        const phrase = Phrases.find(x => x.key == key);\n        if (phrase != null) {\n            // Return specified phrase, if it exists.\n            return phrase;\n        }\n        // Else, return first phrase.\n        return this.getGamePhraseByIndex(0);\n    }\n\n    /**\n     * Gets game phrases by tutorial group\n     * @param tutorialGroup - The tutorial group to filter by\n     * @returns Array of matching GamePhrases\n     */\n    public static getGamePhrasesByTutorialGroup(tutorialGroup: string): GamePhrase[] {\n        const phrases = Phrases.filter(p => tutorialGroup.includes(p.tutorialGroup ?? 'exclude'))\n        return phrases;\n    }\n\n    /**\n     * Validates all game phrases for standard characters\n     * @returns MyResponse containing validation results\n     */\n    public checkGamePhrases(): MyResponse<string[]> {\n        const response: MyResponse<string[]> = {\n            status: 200,\n            message: '',\n            data: [],\n            error: []\n        };\n        Phrases.forEach((phrase, index) => {\n            if (!standardChars.test(phrase.value)) {\n                response.error.push(`Phrase at index ${index} contains non-standard characters: ${phrase.value}`);\n                response.status = 400;\n            }\n        });\n        return response;\n    }\n\n    /**\n     * Gets a game phrase by its index\n     * @param index - The index of the phrase to retrieve\n     * @returns The GamePhrase at the specified index or null if invalid\n     */\n    public static getGamePhraseByIndex(index: number): GamePhrase | null {\n        if (index >= 0 && index < Phrases.length && Phrases[index] != null) {\n            return Phrases[index];\n        }\n        if (index < 0 && Phrases[0] != null) return Phrases[0];\n        if (index >= Phrases.length && Phrases[Phrases.length - 1] != null){\n             return Phrases[Phrases.length - 1] ?? null;\n        }\n        if (Phrases[0] != null) return Phrases[0];\n        throw new Error('No phrases available');\n    }\n\n    /**\n     * Gets a game phrase by its value\n     * @param phrase - The phrase text to search for\n     * @returns The matching GamePhrase or null if not found\n     */\n    public static getGamePhraseByValue(phrase: string): GamePhrase | null {\n        const result = Phrases.find(p => p.value === phrase)\n        return result ?? null;\n    }\n\n    /**\n     * Gets all game phrase names\n     * @returns Array of phrase names\n     */\n    public static getGamePhraseNames(): string[] {\n        return Phrases.map(x => x.key);\n    }\n\n    /**\n     * Gets a random game phrase\n     * @returns A random phrase value\n     * @throws Error if no phrases are available\n     */\n    public static getRandomGamePhrase(): string {\n        const phrasesLength = Phrases.length;\n        if (phrasesLength === 0) throw new Error('No phrases available');\n        const randomKey = Math.floor(Math.random() * phrasesLength);\n        const phrase = Phrases[randomKey];\n        if (phrase == null) throw new Error('Invalid phrase index');\n        return phrase.value;\n    }\n\n    /**\n     * Gets achieved phrases from localStorage\n     * @returns Array of PhraseAchievement objects\n     */\n    public static getGamePhrasesAchieved(): PhraseAchievement[] {\n        const storedPhrasesAchieved = localStorage.getItem('phrasesAchieved');\n\n        try {\n            const parsedPhrases: string[] = JSON.parse(storedPhrasesAchieved ?? '[]') as string[];\n            return parsedPhrases.map((phrase: string) => {\n                const [wpm, phraseName] = phrase.split(':');\n                return {\n                    wpm: wpm ?? '',\n                    phraseName: phraseName ?? ''\n                };\n            });\n        } catch (error: unknown) {\n            // Log error without using console.error\n            const errorMessage = error instanceof Error ? error.message : 'Unknown parsing error';\n            if (typeof window !== 'undefined' && window.console?.error) {\n                window.console.error('Error parsing phrases achieved:', errorMessage);\n            }\n            return [];\n        }\n    }\n\n    /**\n     * Resets achieved phrases in localStorage\n     */\n    public static resetGamePhrasesAchieved(): void {\n        localStorage.removeItem('phrasesAchieved');\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/Logger.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":44,"column":42,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":44,"endColumn":56}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3,\n  SILENT = 4\n}\n\ninterface LoggerConfig {\n  level?: LogLevel;\n  prefix?: string;\n  logToConsole?: boolean;\n  logToFile?: boolean;\n}\n\nclass Logger {\n  private config: LoggerConfig;\n\n  constructor(config: Partial<LoggerConfig> = {}) {\n    this.config = {\n      level: config.level ?? LogLevel.INFO,\n      prefix: config.prefix ?? 'HandTerm',\n      logToConsole: config.logToConsole ?? true,\n      logToFile: config.logToFile ?? false\n    };\n  }\n\n  private log<T extends unknown[]>(level: LogLevel, message: string, ...args: T): void {\n    if (this.config.level !== undefined && level < this.config.level) return;\n\n    const timestamp = new Date().toISOString();\n    const formattedMessage = `[${timestamp}] [${this.config.prefix}] [${LogLevel[level]}] ${message}`;\n\n    if (this.config.logToConsole === true) {\n      this.safeConsoleLog(level, formattedMessage, ...args);\n    }\n\n    if (this.config.logToFile === true) {\n      this.writeToLogFile(formattedMessage, ...args);\n    }\n  }\n\n  private safeConsoleLog<T extends unknown[]>(level: LogLevel, formattedMessage: string, ...args: T): void {\n    if (typeof window !== 'undefined' && window.console) {\n      switch (level) {\n        case LogLevel.DEBUG:\n          window.console.log(formattedMessage, ...args);\n          break;\n        case LogLevel.INFO:\n          window.console.info(formattedMessage, ...args);\n          break;\n        case LogLevel.WARN:\n          window.console.warn(formattedMessage, ...args);\n          break;\n        case LogLevel.ERROR:\n          window.console.error(formattedMessage, ...args);\n          break;\n      }\n    }\n  }\n\n  private writeToLogFile<T extends unknown[]>(_message: string, ..._args: T): void {\n    // Implement file logging logic if needed\n    // This could write to a log file in the application's data directory\n    // Placeholder for future implementation\n  }\n\n  public debug(message: string, ...args: unknown[]): void {\n    this.log(LogLevel.DEBUG, message, ...args);\n  }\n\n  public info(message: string, ...args: unknown[]): void {\n    this.log(LogLevel.INFO, message, ...args);\n  }\n\n  public warn(message: string, ...args: unknown[]): void {\n    this.log(LogLevel.WARN, message, ...args);\n  }\n\n  public error(message: string, ...args: unknown[]): void {\n    this.log(LogLevel.ERROR, message, ...args);\n  }\n}\n\nfunction createLogger(config?: Partial<LoggerConfig>): Logger {\n  return new Logger(config);\n}\n\nexport { Logger, LogLevel, createLogger };\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/Phrase.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":12,"column":13,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":12,"endColumn":18},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":16,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":16,"endColumn":21,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[540,549],"text":"value[0] == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[541,549],"text":"(value[0] ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[540,549],"text":"!Boolean(value[0])"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":37,"column":17,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":37,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1029,1043],"text":"foundChordHTML != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":41,"column":17,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":41,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1200,1205],"text":"chord != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":48,"column":14,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":48,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1389,1400],"text":"foundChord == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":72,"column":17,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":72,"endColumn":29,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2459,2471],"text":"(chordElement != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":72,"column":33,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":72,"endColumn":43,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2475,2485],"text":"(foundChord != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { allChords } from \"../allChords\";\nimport { type Chord } from \"../types/Types\";\n\nimport { createHTMLElementFromHTML } from \"./dom\";\n\nexport class Phrase {\n    private internalValue: string[];\n    private internalChords: Chord[] = [];\n    private internalChordsHTML: HTMLElement[] = [];\n\n    constructor(value: string[]) {\n        if(!value || !Array.isArray(value) || value.length == 0){\n            throw new Error('Phrase value must be an array with at least one element');\n        }\n        this.internalValue = value;\n        if(!value[0]) return;\n        if (Array.isArray(value)) {\n            this.setChords(value);\n        }\n    }\n\n    get value(): string[] {\n        return this.internalValue;\n    }\n\n    get chordsHTML(): HTMLElement[] {\n        return this.internalChordsHTML;\n    }\n\n    get chords(): Chord[] {\n        return this.internalChords;\n    }\n\n    private setChords(keys: string[]): void {\n        keys.forEach((key) => {\n            const foundChordHTML = Phrase.findChordHTML(key);\n            if (foundChordHTML) {\n                this.internalChordsHTML.push(foundChordHTML);\n            }\n            const chord = allChords.find(x => x.key == key);\n            if (chord) {\n                this.internalChords.push(chord);\n            }\n        })\n    }\n\n    public static createChordHTML(foundChord: Chord | undefined): HTMLElement | null {\n        if (!foundChord) return null;\n        return createHTMLElementFromHTML(\n            `<div class=\"col-sm-2 row generated\" id=\"chord2\">\n                <span id=\"char${foundChord.index}\">${foundChord.key}</span>\n                <img loading=\"lazy\" alt=\"2\" src=\"/images/svgs/${foundChord.chordCode}.svg\" width=\"100\" class=\"hand\">\n            </div>`\n        )\n    }\n\n    public static findChordHTML(chordChar: string): HTMLElement | null {\n        let inChord: HTMLElement | null = null;\n        const foundChords\n            = Array.from(allChords)\n                .filter(x => {\n                    return x.key\n                        .replace('&#x2581;', ' ')\n                        .replace('(underscore)', '_')\n                        // .replace('Return (ENTER)', '\\r')\n                        == chordChar;\n                });\n        // Load the clone in Chord order into the wholePhraseChords div.\n        if (foundChords.length > 0) {\n            const foundChord = foundChords[0];\n            const chordElement = this.createChordHTML(foundChord);\n            if (chordElement && foundChord) {\n                chordElement.setAttribute(\"name\", foundChord.key.replace('(', '').replace(')', '').replace(' ', '-'));\n                inChord = chordElement;\n            }\n        }\n        // Removed console.error statement\n        return inChord;\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/WebCam.tsx","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":13,"column":14,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":13,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[352,365],"text":"videoElement == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":30,"column":25,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":30,"endColumn":37},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":38,"column":17,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":38,"endColumn":39,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1258,1280],"text":"videoElement.srcObject != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":48,"column":17,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":48,"endColumn":29},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":48,"column":33,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":48,"endColumn":55,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1599,1621],"text":"(videoElement.srcObject != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type React from 'react';\r\nimport { useRef, useEffect } from 'react';\r\n\r\nexport interface WebCamProps {\r\n    setOn: boolean;\r\n}\r\n\r\nconst WebCam: React.FC<WebCamProps> = ({ setOn }): JSX.Element => {\r\n    const videoRef = useRef<HTMLVideoElement | null>(null);\r\n\r\n    useEffect(() => {\r\n        const videoElement = videoRef.current;\r\n        if (!videoElement) return;\r\n\r\n        videoElement.autoplay = true;\r\n        videoElement.muted = true;\r\n        videoElement.id = 'terminal-video';\r\n        videoElement.setAttribute('playsinline', '');\r\n        videoElement.setAttribute('webkit-playsinline', '');\r\n        videoElement.setAttribute('x5-playsinline', '');\r\n\r\n        if (setOn) {\r\n            navigator.mediaDevices\r\n                .getUserMedia({\r\n                    video: {\r\n                        facingMode: 'environment'\r\n                    }\r\n                })\r\n                .then((stream: MediaStream) => {\r\n                    if (videoElement) {\r\n                        videoElement.srcObject = stream;\r\n                    }\r\n                })\r\n                .catch((error: Error) => {\r\n                    console.error('Error accessing media devices:', error);\r\n                });\r\n        } else {\r\n            if (videoElement.srcObject) {\r\n                const tracks = (videoElement.srcObject as MediaStream).getTracks();\r\n                tracks.forEach(track => track.stop());\r\n                videoElement.srcObject = null;\r\n            }\r\n        }\r\n\r\n        videoElement.hidden = !setOn;\r\n\r\n        return () => {\r\n            if (videoElement && videoElement.srcObject) {\r\n                const tracks = (videoElement.srcObject as MediaStream).getTracks();\r\n                tracks.forEach(track => {\r\n                    track.stop();\r\n                    track.enabled = false;\r\n                });\r\n                videoElement.srcObject = null;\r\n            }\r\n        };\r\n    }, [setOn]);\r\n\r\n    return (\r\n      <video ref={videoRef} style={{ width: '100%', height: 'auto' }}>\r\n        <track kind=\"captions\" src=\"\" label=\"No captions available\" />\r\n      </video>\r\n    );\r\n};\r\n\r\nexport default WebCam;\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/apiClient.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":91,"column":14,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":91,"endColumn":26},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":91,"column":62,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":91,"endColumn":79,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1968,1986],"text":"(authResponse.data == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":100,"column":14,"nodeType":"Identifier","messageId":"conditionErrorString","endLine":100,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[2231,2243],"text":"accessToken.length === 0"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[2231,2243],"text":"accessToken === \"\""},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2231,2243],"text":"!Boolean(accessToken)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":127,"column":17,"nodeType":"MemberExpression","messageId":"conditionErrorNullableObject","endLine":127,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2920,2934],"text":"error.response != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":153,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":153,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3899,3903],"text":"(path != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3899,3903],"text":"(path ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3899,3903],"text":"(Boolean(path))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":154,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":154,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3930,3933],"text":"(sha != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3930,3933],"text":"(sha ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3930,3933],"text":"(Boolean(sha))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios from 'axios';\n\nimport { type IAuthProps } from '../hooks/useAuth';\nimport ENDPOINTS from '../shared/endpoints.json';\n\nimport { createLogger } from './Logger';\n\nconst logger = createLogger();\n\nexport interface APIResponse<T> {\n    status: number;\n    data?: T;\n    error?: string;\n}\n\nexport interface FileContentResponse {\n    content: string;\n    encoding?: string;\n    sha?: string;\n    size?: number;\n}\n\nexport interface TreeItemResponse {\n    path: string;\n    type: string;\n    sha?: string;\n    size?: number;\n}\n\nexport interface RepoResponse {\n    name: string;\n    description?: string;\n    private: boolean;\n    default_branch: string;\n}\n\nexport interface SaveRepoFileResponse {\n    commit: {\n        sha: string;\n        url: string;\n    };\n    content: {\n        sha: string;\n    };\n}\n\nexport interface DeviceCodeResponse {\n    device_code: string;\n    user_code: string;\n    verification_uri: string;\n    expires_in: number;\n    interval: number;\n}\n\nexport interface DevicePollResponse {\n    status: 'pending' | 'complete' | 'error';\n    access_token?: string;\n    token_type?: string;\n    scope?: string;\n    message?: string;\n    error?: string;\n    error_description?: string;\n}\n\ninterface ErrorResponse {\n    message?: string;\n}\n\nfunction isErrorResponse(obj: unknown): obj is ErrorResponse {\n    return typeof obj === 'object' && obj !== null && 'message' in obj;\n}\n\n// Create axios instance with base configuration\nconst api = axios.create({\n    baseURL: ENDPOINTS.api.BaseUrl,\n    headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n    }\n});\n\nexport async function makeAuthenticatedRequest<T>(\n    auth: IAuthProps,\n    endpoint: string,\n    params?: Record<string, string>,\n    method: 'GET' | 'POST' = 'GET',\n    data?: unknown\n): Promise<APIResponse<T>> {\n    try {\n        const authResponse = await auth.validateAndRefreshToken();\n        if (!authResponse || authResponse.status !== 200 || !authResponse.data) {\n            return {\n                status: 401,\n                error: 'Authentication failed'\n            };\n        }\n\n        // Get access token from auth response\n        const accessToken = authResponse.data.accessToken;\n        if (!accessToken) {\n            return {\n                status: 401,\n                error: 'Access token not found'\n            };\n        }\n\n        const response = await api({\n            method,\n            url: endpoint,\n            headers: {\n                'Authorization': `Bearer ${accessToken}`\n            },\n            params,\n            data\n        });\n\n        return {\n            status: response.status,\n            data: response.data as T\n        };\n    } catch (error: unknown) {\n        if (error instanceof Error) {\n            logger.error(`API request failed: ${error.message}`);\n        }\n\n        if (axios.isAxiosError<ErrorResponse>(error)) {\n            if (error.response) {\n                const responseData = error.response.data;\n                const message = isErrorResponse(responseData) && typeof responseData.message === 'string'\n                    ? responseData.message\n                    : `Request failed with status ${error.response.status}`;\n                return {\n                    status: error.response.status,\n                    error: message\n                };\n            }\n            return {\n                status: 500,\n                error: typeof error.message === 'string' ? error.message : 'Request failed'\n            };\n        }\n\n        return {\n            status: 500,\n            error: 'An unknown error occurred'\n        };\n    }\n}\n\nexport async function getRepoTree(auth: IAuthProps, repo: string, path?: string, sha?: string): Promise<APIResponse<TreeItemResponse[]>> {\n    return makeAuthenticatedRequest<TreeItemResponse[]>(auth, ENDPOINTS.api.GetRepoTree, {\n        repo,\n        ...(path && { path }),\n        ...(sha && { sha })\n    });\n}\n\nexport async function getFileContent(auth: IAuthProps, repo: string, path: string): Promise<APIResponse<FileContentResponse>> {\n    // Use the same getRepoTree endpoint - it handles both tree and file content\n    return makeAuthenticatedRequest<FileContentResponse>(auth, ENDPOINTS.api.GetRepoTree, {\n        repo,\n        path\n    });\n}\n\nexport async function saveRepoFile(\n    auth: IAuthProps,\n    repo: string,\n    path: string,\n    content: string,\n    message: string\n): Promise<APIResponse<SaveRepoFileResponse>> {\n    return makeAuthenticatedRequest<SaveRepoFileResponse>(\n        auth,\n        ENDPOINTS.api.SaveRepoFile,\n        { repo, path, message },\n        'POST',\n        content\n    );\n}\n\nexport async function listRecentRepos(auth: IAuthProps): Promise<APIResponse<RepoResponse[]>> {\n    return makeAuthenticatedRequest<RepoResponse[]>(auth, ENDPOINTS.api.ListRecentRepos);\n}\n\nexport async function unlinkGitHub(auth: IAuthProps): Promise<APIResponse<{ message: string }>> {\n    return makeAuthenticatedRequest<{ message: string }>(\n        auth,\n        ENDPOINTS.api.UnlinkGitHub,\n        undefined,\n        'POST'\n    );\n}\n\nexport async function getGitHubDeviceCode(\n    auth: IAuthProps\n): Promise<APIResponse<DeviceCodeResponse>> {\n    return makeAuthenticatedRequest<DeviceCodeResponse>(\n        auth,\n        ENDPOINTS.api.GitHubDeviceCode,\n        undefined,\n        'POST'\n    );\n}\n\nexport async function pollGitHubDeviceAuth(\n    auth: IAuthProps,\n    deviceCode: string\n): Promise<APIResponse<DevicePollResponse>> {\n    return makeAuthenticatedRequest<DevicePollResponse>(\n        auth,\n        ENDPOINTS.api.GitHubDevicePoll,\n        undefined,\n        'POST',\n        { device_code: deviceCode }\n    );\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/commandUtils.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":79,"column":15,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":79,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3105,3113],"text":"(nextPart != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3105,3113],"text":"(nextPart ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3105,3113],"text":"(Boolean(nextPart))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { LogKeys } from \"../types/TerminalTypes\";\nimport { type ParsedCommand } from \"../types/Types\";\n\nexport const commandTextToHTML = (text: string): string => {\n  return text.replace(/\\n/g, '<br/>');\n};\n\nexport const loadCommandHistory = (): string[] => {\n  const storedHistory = localStorage.getItem(LogKeys.commandHistory ?? '') ?? '[]';\n  try {\n    const parsedHistory = JSON.parse(storedHistory) as unknown;\n    // If it's an array of strings, return it directly\n    if (Array.isArray(parsedHistory) && parsedHistory.every((item): item is string => typeof item === 'string')) {\n      return parsedHistory;\n    }\n    // If it's an array of ParsedCommand, convert to strings\n    if (Array.isArray(parsedHistory) && parsedHistory.every((item): item is ParsedCommand =>\n      typeof item === 'object' && item !== null && 'command' in item\n    )) {\n      return parsedHistory.map(parsedCommandToString);\n    }\n    // If parsing fails or is invalid, return an empty array\n    return [];\n  } catch {\n    return [];\n  }\n}\n\nexport const saveCommandHistory = (commandHistory: string[]): void => {\n  if (LogKeys.commandHistory != null)\n    localStorage.setItem(LogKeys.commandHistory ?? '', JSON.stringify(commandHistory));\n}\n\nexport function parsedCommandToString(cmd: ParsedCommand): string {\n  const argsStr = cmd.args != null ? cmd.args.join(' ') : '';\n  const switchesStr = cmd.switches == null ? '' : Object.entries(cmd.switches)\n    .map(([key, value]) => {\n      if (typeof value === 'boolean') {\n        return value ? `-${key}` : '';\n      }\n      return `-${key} ${value}`;\n    })\n    .filter(s => s)\n    .join(' ');\n\n  return [cmd.command, argsStr, switchesStr]\n    .filter(s => s)\n    .join(' ')\n    .trim();\n}\n\nfunction isSwitch(part: string): boolean {\n  return part.substring(0, 1) === '--'  || (part.startsWith('-') && part.length === 2);\n}\n\nexport const parseCommand = (input: string): ParsedCommand => {\n  const parts = input.split(/\\s+/).filter(Boolean); // Split by whitespace and remove empty strings\n  const command = parts.shift() ?? ''; // The first element is the command\n  const args: string[] = [];\n  const switches: Record<string, boolean | string> = {};\n\n  for (let i = 0; i < parts.length; i++) {\n    const part: string | undefined = parts[i];\n    if (part === undefined) continue;\n    if (part == null) continue; // Skip if undefined (shouldn't happen due to filter)\n    if (isSwitch(part)) {\n      const switchAssignmentIndex = part.indexOf('=');\n      if (switchAssignmentIndex > -1) {\n        // It's a switch with an explicit value\n        const switchName = part.substring(2, switchAssignmentIndex);\n        const switchValue = part.substring(switchAssignmentIndex + 1);\n        switches[switchName] = switchValue;\n      } else {\n        // It's a boolean switch or a switch with a value that's the next part\n        const switchName = part.substring(0, 2) === '--' ? part.substring(2) : part.substring(1);\n        // Look ahead to see if the next part is a value for this switch\n        if (i + 1 < parts.length) {\n          const nextPart = parts[i + 1];\n          if (nextPart && !nextPart.startsWith('-')) {\n            switches[switchName] = nextPart;\n            i++; // Increment i to skip the value\n          } else {\n            switches[switchName] = true; // No value provided, treat it as a boolean switch\n          }\n        } else {\n          switches[switchName] = true; // No value provided, treat it as a boolean switch\n        }\n      }\n    } else {\n      // It's an argument\n      args.push(part);\n    }\n  }\n\n  return {\n    command,\n    args,\n    switches\n  } as const;\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/defaultUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/dom.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":4,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":4,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[183,192],"text":"className != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[183,192],"text":"className ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[183,192],"text":"Boolean(className)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\nexport function createElement<T extends HTMLElement>(tagName: keyof HTMLElementTagNameMap, className?: string): T {\n    const element = document.createElement(tagName) as T;\n    if (className) {\n        element.id = className;\n        element.classList.add(className);\n    }\n    return element;\n}\n\nexport function createHTMLElementFromHTML(htmlString: string): HTMLElement {\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(htmlString, 'text/html');\n    return doc.body.firstChild as HTMLElement;\n}","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/fileIcons.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/navigationUtils.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":10,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":10,"endColumn":13,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[385,391],"text":"pParam != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[385,391],"text":"pParam ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[385,391],"text":"Boolean(pParam)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":40,"column":24,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":40,"endColumn":42,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1636,1654],"text":"(options.contentKey != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1636,1654],"text":"(options.contentKey ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1636,1654],"text":"(Boolean(options.contentKey))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":43,"column":28,"nodeType":"Identifier","messageId":"conditionErrorString","endLine":43,"endColumn":40,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[1776,1788],"text":"(newPhraseKey.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[1776,1788],"text":"(newPhraseKey !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1776,1788],"text":"(Boolean(newPhraseKey))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":44,"column":23,"nodeType":"Identifier","messageId":"conditionErrorString","endLine":44,"endColumn":34,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[1852,1863],"text":"(newGroupKey.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[1852,1863],"text":"(newGroupKey !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1852,1863],"text":"(Boolean(newGroupKey))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":47,"column":35,"nodeType":"Identifier","messageId":"conditionErrorString","endLine":47,"endColumn":51,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[2058,2074],"text":"(encodedPhraseKey.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[2058,2074],"text":"(encodedPhraseKey !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2058,2074],"text":"(Boolean(encodedPhraseKey))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/utils/navigationUtils.ts\nimport { ActivityType, type ParsedLocation } from 'src/types/Types';\n\n// Parse location from either pathname or ?p= parameter\nexport function parseLocation(location: string = window.location.toString()): ParsedLocation {\n  // First, check for ?p= parameter\n  const urlParams = new URL(location);\n  const pParam = urlParams.searchParams.get('p');\n\n  if (pParam) {\n    // Remove leading slash if present\n    const cleanPath = pParam.startsWith('/') ? pParam.slice(1) : pParam;\n    const [activityKey, phraseKey] = cleanPath.split('/');\n\n    return {\n      activityKey: activityKey == null ? ActivityType.NORMAL : parseActivityType(activityKey),\n      contentKey: decodeURIComponent(phraseKey ?? ''),\n      groupKey: urlParams.searchParams.get('group') ?? null\n    };\n  }\n\n  // Fallback to pathname parsing\n  const [, activityKey, phraseKey] = window.location.pathname.split('/');\n  return {\n    activityKey: activityKey == null ? ActivityType.NORMAL : parseActivityType(activityKey),\n    contentKey: decodeURIComponent(phraseKey ?? ''),\n    groupKey: urlParams.searchParams.get('group') ?? null\n  };\n}\n\n// Helper function to parse activity type\nexport function parseActivityType(activityString: string): ActivityType {\n  const normalizedActivity = (activityString ?? '').toUpperCase();\n  return ActivityType[normalizedActivity as keyof typeof ActivityType] ?? ActivityType.NORMAL;\n}\n\n// Global navigation function that can be used outside of React components\nexport function navigate(options: ParsedLocation): void {\n  const newActivity = options.activityKey ?? ActivityType.NORMAL;\n  const newPhraseKey = options.contentKey ? options.contentKey.replace('\\r', '_r') : '';\n  const newGroupKey = options.groupKey ?? '';\n\n  const encodedPhraseKey = newPhraseKey ? encodeURIComponent(newPhraseKey) : '';\n  const queryString = newGroupKey ? `?group=${encodeURIComponent(newGroupKey)}` : '';\n\n  const activityPath = newActivity === ActivityType.NORMAL ? '' : ActivityType[newActivity].toLowerCase();\n  const path = `/${activityPath}${encodedPhraseKey ? `/${encodedPhraseKey}` : ''}${queryString}`;\n\n  // Use browser's history API directly\n  window.history.pushState(null, '', path);\n\n  // Dispatch a custom event to notify React router or other components about the navigation\n  window.dispatchEvent(new CustomEvent('locationchange', { detail: { path } }));\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/signalPersistence.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":23,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":23,"endColumn":20,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[576,587],"text":"storedValue != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[576,587],"text":"storedValue ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[576,587],"text":"Boolean(storedValue)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type Signal } from \"@preact/signals-react\";\n\nexport interface PersistenceConfig<T> {\n  key: string;\n  signal: Signal<T>;\n  serialize?: (value: T) => string;\n  deserialize?: (value: string) => T;\n}\n\ninterface PersistentSignal<T> {\n  signal: Signal<T>;\n  update: (newValue: T | ((prev: T) => T)) => void;\n}\n\nexport function createPersistentSignal<T>({\n  key,\n  signal,\n  serialize = JSON.stringify,\n  deserialize = JSON.parse,\n}: PersistenceConfig<T>): PersistentSignal<T> {\n  const loadInitialState = () => {\n    const storedValue = localStorage.getItem(key);\n    if (storedValue) {\n      signal.value = deserialize(storedValue);\n    }\n  };\n\n  const persistToLocalStorage = (value: T) => {\n    queueMicrotask(() => {\n      localStorage.setItem(key, serialize(value));\n    });\n  };\n\n  // Load initial state\n  loadInitialState();\n\n  const updateSignal = (newValue: T | ((prev: T) => T)) => {\n    if (typeof newValue === 'function') {\n      signal.value = (newValue as (prev: T) => T)(signal.value);\n    } else {\n      signal.value = newValue;\n    }\n    persistToLocalStorage(signal.value);\n  };\n\n  return { signal, update: updateSignal };\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/timeUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/treeFormatter.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected string value in conditional. An explicit empty string check is required.","line":27,"column":27,"nodeType":"Identifier","messageId":"conditionErrorString","endLine":27,"endColumn":38,"suggestions":[{"messageId":"conditionFixCompareStringLength","fix":{"range":[837,848],"text":"(currentPath.length > 0)"},"desc":"Change condition to check string's length (`value.length !== 0`)"},{"messageId":"conditionFixCompareEmptyString","fix":{"range":[837,848],"text":"(currentPath !== \"\")"},"desc":"Change condition to check for empty string (`value !== \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[837,848],"text":"(Boolean(currentPath))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":90,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":90,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3029,3034],"text":"(line == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3030,3034],"text":"(line ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3029,3034],"text":"(!Boolean(line))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":90,"column":19,"nodeType":"CallExpression","messageId":"conditionErrorNullableObject","endLine":90,"endColumn":48,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3038,3068],"text":"(line.match(/[▼▶]?\\s*[📁📄]/u) == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":96,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":96,"endColumn":15,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3206,3212],"text":"match == null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":99,"column":20,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":99,"endColumn":50,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3274,3304],"text":"((line.match(/^\\s*/)?.[0].length) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[3274,3304],"text":"((line.match(/^\\s*/)?.[0].length) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3274,3304],"text":"(Boolean((line.match(/^\\s*/)?.[0].length)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable object value in conditional. An explicit null check is required.","line":109,"column":13,"nodeType":"Identifier","messageId":"conditionErrorNullableObject","endLine":109,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3674,3683],"text":"prevMatch != null"},"desc":"Change condition to check for null/undefined (`value != null`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":110,"column":32,"nodeType":"ChainExpression","messageId":"conditionErrorNullableNumber","endLine":110,"endColumn":66,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3718,3752],"text":"((prevLine.match(/^\\s*/)?.[0].length) != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[3718,3752],"text":"((prevLine.match(/^\\s*/)?.[0].length) ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3718,3752],"text":"(Boolean((prevLine.match(/^\\s*/)?.[0].length)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"interface TreeItem {\n    path: string;\n    type: string;\n}\n\ninterface TreeState {\n    expandedFolders: Set<string>;\n}\n\nexport function formatTreeContent(items: TreeItem[], treeState: TreeState): string {\n    const sortedItems = [...items].sort((a, b) => {\n        // Directories come first\n        if (a.type === 'tree' && b.type !== 'tree') return -1;\n        if (a.type !== 'tree' && b.type === 'tree') return 1;\n        return a.path.localeCompare(b.path);\n    });\n\n    const lines: string[] = ['Repository Files', ''];\n\n    // First pass: collect all directories\n    const directories = new Set<string>();\n    sortedItems.forEach(item => {\n        const parts = item.path.split('/');\n        parts.pop(); // Remove the last part (file/dir name)\n        let currentPath = '';\n        parts.forEach(part => {\n            currentPath = currentPath ? `${currentPath}/${part}` : part;\n            directories.add(currentPath);\n        });\n    });\n\n    // Convert directories to array and sort\n    const sortedDirs = Array.from(directories).sort();\n\n    // Helper to check if path should be visible based on parent expansion state\n    const isVisible = (path: string): boolean => {\n        if (!path.includes('/')) return true;\n        const parentPath = path.split('/').slice(0, -1).join('/');\n        return treeState.expandedFolders.has(parentPath) &&\n               (parentPath.includes('/') ? isVisible(parentPath) : true);\n    };\n\n    // Build tree structure\n    sortedDirs.forEach(dir => {\n        if (isVisible(dir)) {\n            const depth = dir.split('/').length;\n            const indent = '  '.repeat(depth - 1);\n            const name = dir.split('/').pop() ?? '';\n            const isExpanded = treeState.expandedFolders.has(dir);\n            const arrow = isExpanded ? '▼' : '▶';\n            lines.push(`${indent}${arrow} 📁 ${name}/`);\n        }\n    });\n\n    // Add files under their directories\n    sortedItems.forEach(item => {\n        if (item.type !== 'tree' && isVisible(item.path)) {\n            const parts = item.path.split('/');\n            const fileName = parts.pop() ?? '';\n            const depth = parts.length;\n            const indent = '  '.repeat(depth);\n            const prefix = parts.length > 0 ? '  ' : '';\n            const icon = getFileIcon(fileName);\n            lines.push(`${indent}${prefix}${icon} ${fileName}`);\n        }\n    });\n\n    // Add navigation help\n    lines.push('');\n    lines.push('Navigation:');\n    lines.push('j: move down');\n    lines.push('k: move up');\n    lines.push('Enter: open file or toggle folder');\n    lines.push('e: close tree view');\n    lines.push('');\n\n    return lines.join('\\n');\n}\n\n// Helper function to get the item at a specific line\nexport function getItemAtLine(\n    items: TreeItem[],\n    treeState: TreeState,\n    lineNumber: number\n): { path: string; type: string; isDirectory: boolean } | null {\n    const content = formatTreeContent(items, treeState);\n    const lines = content.split('\\n');\n    const line = lines[lineNumber - 1];\n\n    if (!line || !line.match(/[▼▶]?\\s*[📁📄]/u)) {\n        return null;\n    }\n\n    // Extract path from the line\n    const match = line.match(/[▼▶]?\\s*[^\\s]+\\s+(.+?)\\/?\\s*$/u);\n    if (!match) return null;\n\n    const name = match[1];\n    const indent = line.match(/^\\s*/)?.[0].length || 0;\n    const depth = Math.floor(indent / 2);\n\n    // Reconstruct full path based on previous directory lines\n    const pathParts: string[] = [];\n    let currentDepth = 0;\n\n    for (let i = lineNumber - 2; i >= 0 && currentDepth < depth; i--) {\n        const prevLine = lines[i];\n        const prevMatch = prevLine.match(/[▼▶]?\\s*[^\\s]+\\s+(.+?)\\/\\s*$/u);\n        if (prevMatch) {\n            const prevIndent = prevLine.match(/^\\s*/)?.[0].length || 0;\n            const prevDepth = Math.floor(prevIndent / 2);\n            if (prevDepth === currentDepth) {\n                pathParts.unshift(prevMatch[1]);\n                currentDepth++;\n            }\n        }\n    }\n\n    pathParts.push(name);\n    const fullPath = pathParts.join('/');\n\n    const isDirectory = line.includes('📁');\n    return {\n        path: fullPath,\n        type: isDirectory ? 'tree' : 'blob',\n        isDirectory\n    };\n}\n\n// Helper function to get file icon based on extension\nfunction getFileIcon(fileName: string): string {\n    const ext = fileName.split('.').pop()?.toLowerCase();\n    switch (ext) {\n        case 'js':\n        case 'jsx':\n            return '📜';\n        case 'ts':\n        case 'tsx':\n            return '📘';\n        case 'json':\n            return '📋';\n        case 'md':\n            return '📝';\n        case 'html':\n            return '🌐';\n        case 'css':\n        case 'scss':\n        case 'sass':\n            return '🎨';\n        case 'py':\n            return '🐍';\n        case 'rb':\n            return '💎';\n        case 'java':\n            return '☕';\n        case 'go':\n            return '🐹';\n        case 'rs':\n            return '🦀';\n        case 'php':\n            return '🐘';\n        case 'sh':\n        case 'bash':\n            return '💻';\n        case 'yml':\n        case 'yaml':\n            return '⚙️';\n        case 'svg':\n        case 'png':\n        case 'jpg':\n        case 'jpeg':\n        case 'gif':\n            return '🖼️';\n        default:\n            return '📄';\n    }\n}\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/src/utils/typeSafetyUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/vitest-setup.ts","messages":[{"ruleId":null,"fatal":true,"severity":2,"message":"Parsing error: ';' expected.","line":269,"column":23,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import '@testing-library/jest-dom/vitest';\nimport { afterEach, vi } from 'vitest';\nimport { cleanup } from '@testing-library/react';\nimport { ImageData } from 'canvas';\n\n// Ensure ImageData is properly polyfilled before any mocks are created\nclass ImageDataPolyfill implements ImageData {\n  readonly data: Uint8ClampedArray;\n  readonly width: number;\n  readonly height: number;\n  readonly colorSpace: PredefinedColorSpace;\n\n  constructor(\n    width: number,\n    height: number,\n    data?: Uint8ClampedArray,\n    colorSpace: PredefinedColorSpace = 'srgb'\n  ) {\n    this.width = width;\n    this.height = height;\n    this.data = data || new Uint8ClampedArray(width * height * 4);\n    this.colorSpace = colorSpace;\n  }\n}\n\n// Create a type-safe ImageData constructor that matches both browser and Node.js environments\nconst createImageData = (\n  width: number,\n  height: number,\n  data?: Uint8ClampedArray,\n  colorSpace: PredefinedColorSpace = 'srgb'\n): ImageData => new ImageDataPolyfill(width, height, data, colorSpace);\n\nglobal.ImageData = createImageData as unknown as typeof ImageData;\n\n// Polyfill DOMMatrix if not available\nif (typeof DOMMatrix === 'undefined') {\n  class DOMMatrixPolyfill {\n    m11 = 1;\n    m12 = 0;\n    m13 = 0;\n    m14 = 0;\n    m21 = 0;\n    m22 = 1;\n    m23 = 0;\n    m24 = 0;\n    m31 = 0;\n    m32 = 0;\n    m33 = 1;\n    m34 = 0;\n    m41 = 0;\n    m42 = 0;\n    m43 = 0;\n    m44 = 1;\n    is2D = true;\n    isIdentity = true;\n\n    constructor(matrix?: string | number[]) {\n      if (matrix) {\n        const values = (typeof matrix === 'string'\n          ? matrix.split(',').map(Number)\n          : matrix).map(v => Number.isNaN(v) ? 0 : v);\n\n        this.m11 = values[0] ?? 1;\n        this.m12 = values[1] ?? 0;\n        this.m13 = values[2] ?? 0;\n        this.m14 = values[3] ?? 0;\n        this.m21 = values[4] ?? 0;\n        this.m22 = values[5] ?? 1;\n        this.m23 = values[6] ?? 0;\n        this.m24 = values[7] ?? 0;\n        this.m31 = values[8] ?? 0;\n        this.m32 = values[9] ?? 0;\n        this.m33 = values[10] ?? 1;\n        this.m34 = values[11] ?? 0;\n        this.m41 = values[12] ?? 0;\n        this.m42 = values[13] ?? 0;\n        this.m43 = values[14] ?? 0;\n        this.m44 = values[15] ?? 1;\n\n        this.isIdentity = this.m11 === 1 && this.m12 === 0 && this.m13 === 0 && this.m14 === 0 &&\n                         this.m21 === 0 && this.m22 === 1 && this.m23 === 0 && this.m24 === 0 &&\n                         this.m31 === 0 && this.m32 === 0 && this.m33 === 1 && this.m34 === 0 &&\n                         this.m41 === 0 && this.m42 === 0 && this.m43 === 0 && this.m44 === 1;\n      }\n    }\n\n    static fromFloat32Array(array: Float32Array): DOMMatrix {\n      return new DOMMatrixPolyfill([...array]) as unknown as DOMMatrix;\n    }\n\n    static fromFloat64Array(array: Float64Array): DOMMatrix {\n      return new DOMMatrixPolyfill([...array]) as unknown as DOMMatrix;\n    }\n\n    static fromMatrix(other?: DOMMatrixInit): DOMMatrix {\n      if (!other) {\n        return new DOMMatrixPolyfill() as unknown as DOMMatrix;\n      }\n\n      const values = [\n        other.m11 ?? 1, other.m12 ?? 0, other.m13 ?? 0, other.m14 ?? 0,\n        other.m21 ?? 0, other.m22 ?? 1, other.m23 ?? 0, other.m24 ?? 0,\n        other.m31 ?? 0, other.m32 ?? 0, other.m33 ?? 1, other.m34 ?? 0,\n        other.m41 ?? 0, other.m42 ?? 0, other.m43 ?? 0, other.m44 ?? 1\n      ];\n\n      return new DOMMatrixPolyfill(values) as unknown as DOMMatrix;\n    }\n  }\n\n  global.DOMMatrix = DOMMatrixPolyfill as unknown as typeof DOMMatrix;\n}\n\n// Automatically cleanup after each test\nafterEach(() => {\n  cleanup();\n});\n\ninterface MockCanvasContext extends Omit<CanvasRenderingContext2D, 'canvas' | 'getContextAttributes'> {\n  canvas: HTMLCanvasElement;\n  getContextAttributes(): CanvasRenderingContext2DSettings;\n}\n\n// Create a type-safe mock of CanvasRenderingContext2D\nconst createMockContext = (): MockCanvasContext => {\n  // First create a partial context with basic properties\n  const baseContext = {\n    canvas: document.createElement('canvas'),\n    getContextAttributes: vi.fn().mockReturnValue({\n      alpha: true,\n      desynchronized: false,\n      colorSpace: 'srgb'\n    }),\n    // Properties\n    globalAlpha: 1,\n    globalCompositeOperation: 'source-over',\n    fillStyle: '#000',\n    strokeStyle: '#000',\n    filter: 'none',\n    imageSmoothingEnabled: true,\n    imageSmoothingQuality: 'low' as const,\n    lineCap: 'butt' as const,\n    lineDashOffset: 0,\n    lineJoin: 'miter' as const,\n    lineWidth: 1,\n    miterLimit: 10,\n    shadowBlur: 0,\n    shadowColor: 'rgba(0, 0, 0, 0)',\n    shadowOffsetX: 0,\n    shadowOffsetY: 0,\n    direction: 'ltr' as const,\n    font: '10px sans-serif',\n    textAlign: 'start' as const,\n    textBaseline: 'alphabetic' as const,\n    fontKerning: 'auto',\n    fontStretch: 'normal',\n    fontVariantCaps: 'normal',\n    textRendering: 'auto',\n    letterSpacing: '0px',\n    wordSpacing: '0px',\n  };\n\n  // Create method mocks with proper overload signatures\n  const methodMocks = {\n    // Methods\n    arc: vi.fn(),\n    arcTo: vi.fn(),\n    beginPath: vi.fn(),\n    bezierCurveTo: vi.fn(),\n    clearRect: vi.fn(),\n    clip: vi.fn(),\n    closePath: vi.fn(),\n    createConicGradient: vi.fn().mockReturnValue({} as CanvasGradient),\n    createImageData: vi.fn().mockImplementation((width: number, height: number) => new ImageData(width || 1, height || 1)),\n    createLinearGradient: vi.fn().mockReturnValue({} as CanvasGradient),\n    createPattern: vi.fn().mockReturnValue(null),\n    createRadialGradient: vi.fn().mockReturnValue({} as CanvasGradient),\n    drawFocusIfNeeded: vi.fn(),\n    drawImage: vi.fn().mockImplementation(\n      (\n        _image: CanvasImageSource,\n        _dx: number,\n        _dy: number,\n        _dw?: number,\n        _dh?: number,\n        _sx?: number,\n        _sy?: number,\n        _sw?: number,\n        _sh?: number\n      ): void => {\n        // Count non-undefined arguments to determine which overload was called\n        const argCount = [_image, _dx, _dy, _dw, _dh, _sx, _sy, _sw, _sh].filter(\n          (arg) => arg !== undefined\n        ).length;\n\n        if (argCount === 3 || argCount === 5 || argCount === 9) {\n          return;\n        }\n        throw new Error('Invalid number of arguments for drawImage');\n      }\n    ),\n    ellipse: vi.fn(),\n    fill: vi.fn(),\n    fillRect: vi.fn(),\n    fillText: vi.fn(),\n    getImageData: vi.fn().mockReturnValue(new ImageData(1, 1)),\n    getLineDash: vi.fn().mockReturnValue([]),\n    getTransform: vi.fn().mockReturnValue(new DOMMatrix()),\n    isContextLost: vi.fn().mockReturnValue(false),\n    isPointInPath: vi.fn().mockReturnValue(false),\n    isPointInStroke: vi.fn().mockReturnValue(false),\n    lineTo: vi.fn(),\n    measureText: vi.fn().mockReturnValue({\n      width: 0,\n      actualBoundingBoxAscent: 0,\n      actualBoundingBoxDescent: 0,\n      actualBoundingBoxLeft: 0,\n      actualBoundingBoxRight: 0,\n      fontBoundingBoxAscent: 0,\n      fontBoundingBoxDescent: 0,\n      alphabeticBaseline: 0,\n      emHeightAscent: 0,\n      emHeightDescent: 0,\n      hangingBaseline: 0,\n      ideographicBaseline: 0\n    }),\n    moveTo: vi.fn(),\n    putImageData: vi.fn(),\n    quadraticCurveTo: vi.fn(),\n    rect: vi.fn(),\n    reset: vi.fn(),\n    resetTransform: vi.fn(),\n    restore: vi.fn(),\n    rotate: vi.fn(),\n    roundRect: vi.fn(),\n    save: vi.fn(),\n    scale: vi.fn(),\n    setLineDash: vi.fn(),\n    setTransform: vi.fn(),\n    stroke: vi.fn(),\n    strokeRect: vi.fn(),\n    strokeText: vi.fn(),\n    transform: vi.fn(),\n    translate: vi.fn()\n  };\n\n  // Combine base context and method mocks, then cast to the required type\n  return { ...baseContext, ...methodMocks } as unknown as MockCanvasContext;\n};\n\n// Type-safe mock canvas\nconst mockCanvasContext = createMockContext();\nconst getContextMock = vi.fn().mockImplementation((contextId: string): CanvasRenderingContext2D | null => {\n  return contextId === '2d' ? mockCanvasContext : null;\n});\n\n// Mock ResizeObserver\nclass ResizeObserverMock implements ResizeObserver {\n  constructor(private callback: ResizeObserverCallback) {}\n  observe = vi.fn();\n  unobserve = vi.fn();\n  disconnect = vi.fn();\n}\n\n// Setup global mocks\nglobal.ResizeObserver = ResizeObserverMock;\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn(),\n    dispatchEvent: vi.fn()\n  }))\n});\n\n// Mock IntersectionObserver\nclass IntersectionObserverMock implements IntersectionObserver {\n  readonly root: Element | null = null;\n  readonly rootMargin = '0px';\n  readonly thresholds: ReadonlyArray<number> = [0];\n\n  constructor(private callback: IntersectionObserverCallback) {}\n\n  observe = vi.fn();\n  unobserve = vi.fn();\n  disconnect = vi.fn();\n  takeRecords = vi.fn().mockReturnValue([]);\n}\n\nglobal.IntersectionObserver = IntersectionObserverMock;\n\n// Suppress console errors during tests but keep them available for inspection\nconst originalConsoleError = console.error;\nconsole.error = vi.fn((...args: unknown[]) => {\n  if (process.env.NODE_ENV === 'test') {\n    return;\n  }\n  originalConsoleError(...args);\n});\n\n// Cleanup function to restore console.error\nafterEach(() => {\n  vi.mocked(console.error).mockClear();\n});\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/home/mstouffer/repos/handterm-proj/handterm/vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]
